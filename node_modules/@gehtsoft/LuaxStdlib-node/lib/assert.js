'use strict';
let assertNative = require('assert');
let stdlib = require('./stdlib.js');

let chai    = require('chai');
let expect  = require('chai').expect;
let chaiXml = require('chai-xml');
chai.use(chaiXml);

//@@DocBrief("The library of assertions")
class StdlibAssert {
    static isTrue(condition, message) {
        assertNative.ok(condition, message);
    }
    static isFalse(condition, message) {
        assertNative.ok(!condition, message);
    }
    static approximatelyEquals(value, expected, delta, message) {
        if (Math.abs(value - expected) >= delta) {
            if (message !== null && typeof message !== 'undefined')
                message = " because " + message;
            else
                message = "";
            throw new Error("Expected the value to be " + expected + "+-" + delta + " but it is " + value + message);
        }
        return null;
    }
    static throws(action, message) {
        assertNative.throws(function(){action.invoke();}, null, message);
    }
    static doesNotThrow(action, message) {
        assertNative.doesNotThrow(function(){action.invoke();}, null, message);
    }
    static equalsXML(v1,v2, message) {
        if (v1 !== null && typeof v1 === 'object' && typeof v1.asString === 'function') {
            v1 = v1.asString();
        }
        if (v2 !== null && typeof v2 === 'object' && typeof v2.asString === 'function') {
            v2 = v2.asString();
        }
        expect(v1).xml.to.equal(v2, message);
    }
    static equals(v1, v2, message) {
        if (v1 !== null && typeof v1 === 'object' && typeof v1.asObject === 'function') {
            v1 = v1.asObject();
        }
        if (v2!== null && typeof v2 === 'object' && typeof v2.asObject === 'function') {
            v2 = v2.asObject();
        }
        if (v1 !== null  && typeof v1 !== 'undefined' && typeof v1.getTime === 'function' && v2 !== null  && typeof v2 !== 'undefined' && typeof v2.getTime === 'function') {
            v1 = v1.getTime();
            v2 = v2.getTime();
        } else if (v1 !== null && v2 !== null && typeof v1 === 'object' && typeof v2 === 'object') {
            assertNative.ok(assert._checkObjects(v1, v2), message);
            return;
        }
        assertNative.strictEqual(v1, v2, message);
    }
    static _checkObjects(v1, v2) {
        const props = Object.keys(v1);
        for (let prop in props) {
            const p1 = v1[props[prop]];
            const p2 = v2[props[prop]];
            if (typeof p1 === 'object' && typeof p2 === 'object') {
                if (!assert._checkObjects(p1, p2))
                 return false;
            } else if (p1 != p2)
                return false;
        }
        return true;
    }
    static doesNotEqual(v1, v2, message) {
        if (v1 !== null && typeof v1 === 'object' && typeof v1.asObject === 'function') {
            v1 = v1.asObject();
        }
        if (v2!== null && typeof v2 === 'object' && typeof v2.asObject === 'function') {
            v2 = v2.asObject();
        }
        if (v1 !== null  && typeof v1 !== 'undefined' && typeof v1.getTime === 'function' && v2 !== null  && typeof v2 !== 'undefined' && typeof v2.getTime === 'function') {
            v1 = v1.getTime();
            v2 = v2.getTime();
        } else if (v1 !== null && v2 !== null && typeof v1 === 'object' && typeof v2 === 'object') {
            assertNative.ok(!assert._checkObjects(v1, v2), message);
            return;
        }
        assertNative.notStrictEqual(v1, v2, message);
    }
    static greater(v1, v2, message) {
        if (v1 !== null  && typeof v1 !== 'undefined' && typeof v1.getTime === 'function' && v2 !== null  && typeof v2 !== 'undefined' && typeof v2.getTime === 'function') {
            v1 = v1.getTime();
            v2 = v2.getTime();
        }
        assertNative.ok(v1 > v2, message);
    }
    static greaterOrEqual(v1, v2, message) {
        if (v1 !== null  && typeof v1 !== 'undefined' && typeof v1.getTime === 'function' && v2 !== null  && typeof v2 !== 'undefined' && typeof v2.getTime === 'function') {
            v1 = v1.getTime();
            v2 = v2.getTime();
        }
        assertNative.ok(v1 >= v2, message);
    }
    static less(v1, v2, message) {
        if (v1 !== null  && typeof v1 !== 'undefined' && typeof v1.getTime === 'function' && v2 !== null  && typeof v2 !== 'undefined' && typeof v2.getTime === 'function') {
            v1 = v1.getTime();
            v2 = v2.getTime();
        }
        assertNative.ok(v1 < v2, message);
    }
    static lessOrEqual(v1, v2, message) {
        if (v1 !== null  && typeof v1 !== 'undefined' && typeof v1.getTime === 'function' && v2 !== null  && typeof v2 !== 'undefined' && typeof v2.getTime === 'function') {
            v1 = v1.getTime();
            v2 = v2.getTime();
        }
        assertNative.ok(v1 <= v2, message);
    }
    static matches(value, pattern, message) {
        assertNative.ok(stdlib.match(value, pattern), message);
    }
    static doesNotMatch(value, pattern, message) {
        assertNative.ok(!stdlib.match(value, pattern), message);
    }
}
let assert = StdlibAssert;
module.exports = assert;
