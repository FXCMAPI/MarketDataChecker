'use strict';
class StdlibXmlNode {
    static ELEMENT = "element";
    static TEXT = "text";
    static COMMENT = "comment";
    static CDATA = "cdata";
    static ATTRIBUTE = "attribute";

    static ELEMENT_NODE = 1;
    static TEXT_NODE = 3;
    static COMMENT_NODE = 8;
    static CDATA_SECTION_NODE = 4;
    static ATTRIBUTE_NODE = 2;

    documentElement;
    type;
    name;
    value;
    namespaceURI;
    localName;

    static createFromNode(sourceNode) {
        let node = new xmlNode();

        switch(sourceNode.nodeType) {
            case xmlNode.ELEMENT_NODE:
                node.type = xmlNode.ELEMENT;
                break;
            case xmlNode.TEXT_NODE:
                node.type = xmlNode.TEXT;
                break;
            case xmlNode.COMMENT_NODE:
                node.type = xmlNode.COMMENT;
                break;
            case xmlNode.CDATA_SECTION_NODE:
                node.type = xmlNode.CDATA;
                break;
            case xmlNode.ATTRIBUTE_NODE:
                node.type = xmlNode.ATTRIBUTE;
                break;
            default:
                throw new Error("Unknown XML node '" + sourceNode.nodeType + "'");
        }
        
        node.localName = sourceNode.localName;
        node.namespaceURI = sourceNode.namespaceURI;
        node.value = sourceNode.nodeValue != null ? sourceNode.nodeValue : "";
        node.localName = sourceNode.localName;
        node.namespaceURI = sourceNode.namespaceURI;
        node.documentElement = sourceNode;
        node.name = sourceNode.nodeName;

        return node;
    }

    getType() {
        return this.type;
    }

    getName() {
        return this.name;
    }

    getLocalName() {
        return this.localName;
    }

    getNamespaceURI() {
        return this.namespaceURI;
    }

    getChildrenCount() {
        if(this.type != xmlNode.ELEMENT)
            return 0;
        let nodes = this.documentElement.childNodes;
        return nodes.length;
    }

    getChild(index) {
        if(this.type != xmlNode.ELEMENT)
            return null;
        let nodes = this.documentElement.childNodes;
        return xmlNode.createFromNode(nodes[index]);
    }

    getAttributesCount() {
        if(this.type != xmlNode.ELEMENT)
            return 0;
        return this.documentElement.attributes.length;
    }

    getAttribute(index) {
        if(this.type != xmlNode.ELEMENT)
            return null;
        let attributes = this.documentElement.attributes;
        if(attributes.length == 0)
            return null;
        let attr = attributes[index];
        return xmlNode.createFromNode(attr);
    }

    getAttributeByName(localName) {
        if(this.type != xmlNode.ELEMENT)
            return null;
        let attributes = this.documentElement.attributes;
        if(attributes.length == 0)
            return null;
        let attr = attributes[0];
        let attrName = attr.name ? "name" : "nodeName";
        for(let i=0; i < attributes.length; i++) {
            attr = attributes.item(i);
            let curName = attr[attrName];
            let ind = curName.lastIndexOf(":");
            if(ind >= 0)
                curName = curName.substr(ind + 1);
            if(curName == localName) {
                return xmlNode.createFromNode(attr);
            }
        }
        return null;
    }

    getValue() {
        return this.value;
    }
}

let xmlNode = StdlibXmlNode;
module.exports = xmlNode;
