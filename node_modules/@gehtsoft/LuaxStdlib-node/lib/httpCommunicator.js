'use strict';
let list = require('./list');
let string_map = require('./string_map');
let {XMLHttpRequestLocal, nodeJs} = require('./importXmlHttpRequest');

const XHR_TIMEOUT = 60 * 1000;

//@@DocBrief("HTTP communication class")
class StdlibHttpCommunicator {
    requests;
    headers;
    xhrPool;
    timeout = XHR_TIMEOUT;
    usePool = nodeJs;

    get(url, callback) {
        this._pushRequest(url, "GET", null, callback);
    }
    post(url, body, callback) {
        this._pushRequest(url, "POST", body, callback);
    }
    setRequestHeader(name, value) {
        this.headers.set(name, value);
    }
    setTimeout(timeout) {
        this.timeout = timeout;
    }
    setUsePool(usePool) {
        this.usePool = usePool;
    }
    cancel() {
        for(let i = 0; i < this.requests.length(); i++) {
            this.requests.get(i).cancel();
        }
        this.requests = new list();
    }
    constructor() {
        this.xhrPool = new list();
        this.requests = new list();
        this.headers = new string_map();
    }
    _pushRequest(url, methodName, data, callback) {
        let xhr = null;

        if (this.usePool || this.xhrPool.length() == 0) {
            xhr = new XMLHttpRequestLocal();
        } else {
            xhr = this.xhrPool.get(0);
            this.xhrPool.remove(0);
        }

        let xhrWrapper = new XhrWrapper(xhr, url, methodName, callback, this.headers, ((request) => {
            if (!this.usePool)
                this.xhrPool.add(request.xhr);

            for(let i = 0; i < this.requests.length(); i++) {
                if(request === this.requests.get(i)) {
                    this.requests.remove(i);
                    break;
                }
            }
        }));
        this.requests.add(xhrWrapper);
        this.headers.clear();
        xhrWrapper.send(data, this.timeout);
    }
}

class XhrWrapper {
    xhr;
    callback;
    _aborted;
    _tmHandler;
    finishHandler;

    constructor(xhr, url, methodName, callback, headers, finishHandler) {
        this.xhr = xhr;
        this.xhr.open(methodName, url);
        let keys = headers.keys();
        let length = headers.length();
        for (let i=0; i < length; i++)
            this.xhr.setRequestHeader(keys[i], headers.get(keys[i]));

        this.callback = callback;
        this.finishHandler = finishHandler;
        this._aborted = false;
    }

    send(data, timeout) {
        this.xhr.onreadystatechange = this._onreadystatechange.bind(this);
        this.xhr.onerror = this._onerror.bind(this);
        this.xhr.ontimeout = this._ontimeout.bind(this);
        this._tmHandler = setTimeout((() => {
            this._tmHandler = null;
            if (!this._aborted)
                setTimeout((() => {
                    this.callback.onError("Timeout");
                }), 0);
        }), timeout)
        if(typeof data !== 'undefined' && data !== null)
            this.xhr.send(data);
        else
            this.xhr.send();
    }

    cancel() {
        this._aborted = true;
        this.xhr.abort();
    }

    _onreadystatechange() {
        if (this.xhr.readyState === 4) {
            clearTimeout(this._tmHandler);
            this._tmHandler = null;
            let responseText = this.xhr.responseText;
            let status = this.xhr.status;
            if (!this._aborted && status !== 0)
                setTimeout((() => {
                    this.callback.onComplete(status, responseText);
                    this.finishHandler(this);
                }), 0);
        }
    }

    _onerror() {
        let text = this.xhr.statusText;
        clearTimeout(this._tmHandler);
        this._tmHandler = null;

        if (typeof text === 'undefined' || text === null || text.length === 0) {
            text = "Connection failed";
        }
        if (!this._aborted)
            setTimeout((() => {
                this.callback.onError(text.toString());
                this.finishHandler(this);
            }), 0);
    }

    _ontimeout() {
        clearTimeout(this._tmHandler);
        this._tmHandler = null;
        if (!this._aborted)
            setTimeout((() => {
                this.callback.onError("Timeout");
                this.finishHandler(this);
            }), 0);
    }
}

let httpCommunicator = StdlibHttpCommunicator;
module.exports = httpCommunicator;