'use strict';
let buffer = require('./buffer');
let io = require('./io');
let cryptoJs = require('crypto-js');
let Buffer = require('buffer/').Buffer;
let pako = require('pako');
let btoaLocal = require('./importBtoa');;

class StdlibCryptography {
    static MD5(v) {
        let data = Buffer.from(v.toBase64(), 'base64').toString();
        let result = cryptoJs.enc.Base64.stringify(cryptoJs.MD5(data));
        return buffer.fromBase64(result);
    }
    static SHA1(v) {
        let data = Buffer.from(v.toBase64(), 'base64').toString();
        let result = cryptoJs.enc.Base64.stringify(cryptoJs.SHA1(data));
        return buffer.fromBase64(result);
    }
    static SHA256(v) {
        throw new Error("'SHA256' is not implemented yet.");
    }
    static SHA512(v) {
        throw new Error("'SHA512' is not implemented yet.");
    }

    static AES128(v, key, doEncryption) {

        if (doEncryption)
            throw new Error("'AES128' encryption is not implemented yet.");

        const decrypted = cryptoJs.AES.decrypt(
            {
                ciphertext: cryptoJs.enc.Base64.parse(v.toBase64())
            }, 
            cryptoJs.enc.Utf8.parse(key.getEncodedString(0, key.length(), io.CP_ANSI)),                                                                   
            {
                iv: cryptoJs.enc.Hex.parse("00000000000000000000000000000000")
            }
        );
        
        let result = decrypted.toString(cryptoJs.enc.Utf8);
        let resultBuffer = buffer.create(buffer.getEncodedStringLength(result, io.CP_ANSI));
        resultBuffer.setEncodedString(0, result, io.CP_ANSI);

        return resultBuffer;         
    }

    static DEFLATE(v, doEncryption) {
        if (doEncryption) {
            return buffer.fromBase64(btoaLocal(String.fromCharCode.apply(null, pako.deflate(v.getEncodedString(0, v.length(), io.CP_ANSI)))));
        } else {
            let arr = [];
            for (const value of v.innerBuffer.values()) {
                arr.push(value);
            }
            return buffer.fromBuffer(Buffer.from(pako.inflate(arr)));
        }
    }
}

let cryptography =  StdlibCryptography;
module.exports = cryptography;