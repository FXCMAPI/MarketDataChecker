'use strict';
let ABothFxmsgReader = require('./ABothFxmsgReader.js');
let csvParser = require('@gehtsoft/LuaxStdlib-node').csvParser;
let InstrumentDescriptorCsvParser = require('./InstrumentDescriptorCsvParser.js');
let RawOfferCsvParser = require('./RawOfferCsvParser.js');
let PdasRequestCommand = require('./PdasRequestCommand.js');
let xmlNode = require('@gehtsoft/LuaxStdlib-node').xmlNode;
let XmlReaderUtil = require('./XmlReaderUtil.js');
let PdasMessageFieldTag = require('./PdasMessageFieldTag.js');
let GetInstrumentDescriptorsMessageBuilder = require('./GetInstrumentDescriptorsMessageBuilder.js');
let GetRawOffersMessageBuilder = require('./GetRawOffersMessageBuilder.js');
let InstrumentDescriptorsList = require('./InstrumentDescriptorsList.js');
let RawOffersList = require('./RawOffersList.js');
class GetInstrumentDescriptorsAndRawOffersFxmsgReader extends ABothFxmsgReader {
    linesParser;
    instrumentCsvParser;
    rawOfferCsvParser;
    constructor() {
        super();
        this.linesParser = new csvParser();
        this.linesParser.valueSeparator = "\n";
        this.instrumentCsvParser = new InstrumentDescriptorCsvParser();
        this.rawOfferCsvParser = new RawOfferCsvParser();
    }
    getCommand() {
        return PdasRequestCommand.GET_INSTRUMENT_DESCRIPTORS_AND_RAW_OFFERS;
    }
    processData(responseList, data) {
        responseList.add(this.createLockedMessage(this.processInstrumentDescriptorsData(data).build()));
        responseList.add(this.createLockedMessage(this.processRawOffersData(data).build()));
    }
    processMessage(responseList, messageNode) {
        let i, child, foundMessage;
        foundMessage = false;
        for (i = 0; i <= messageNode.getChildrenCount() - 1; i += 1) {
            child = messageNode.getChild(i);
            if (child.getType() == xmlNode.ELEMENT) {
                foundMessage = this.processList(child, responseList);
            }
            if (foundMessage) {
                break;
            }
        }
    }
    processList(l, responseList) {
        let getInstrumentDescriptorsMessage, j, addedMessage, data;
        getInstrumentDescriptorsMessage = null;
        addedMessage = false;
        if (XmlReaderUtil.isAttrEqualTo(l, "n", PdasMessageFieldTag.FXCM_NO_PARAM)) {
            for (j = 0; j <= l.getChildrenCount() - 1; j += 1) {
                data = this.getTextFromGroup(l.getChild(j), "EXTRA.99");
                if (data != null) {
                    responseList.add(this.processInstrumentDescriptorsData(data).build());
                    responseList.add(this.processRawOffersData(data).build());
                    addedMessage = true;
                    break;
                }
            }
        }
        return addedMessage;
    }
    processInstrumentDescriptorsData(fieldText) {
        let instrumentDescriptorsList, responseMessage;
        instrumentDescriptorsList = this.parseInstrumentDescriptors(fieldText);
        responseMessage = new GetInstrumentDescriptorsMessageBuilder();
        responseMessage.addInstrumentDescriptors(instrumentDescriptorsList);
        return responseMessage;
    }
    processRawOffersData(fieldText) {
        let rawOffers, responseMessage;
        rawOffers = this.parseRawOffers(fieldText);
        responseMessage = new GetRawOffersMessageBuilder();
        responseMessage.addRawOffers(rawOffers);
        return responseMessage;
    }
    parseInstrumentDescriptors(data) {
        let lines, i, instrumentsList, instrumentDescriptor;
        instrumentsList = new InstrumentDescriptorsList();
        lines = this.linesParser.splitLine(data);
        for (i = 0; i <= lines.length - 1; i += 1) {
            instrumentDescriptor = this.instrumentCsvParser.parse(lines[i]);
            if (instrumentDescriptor != null) {
                instrumentsList.add(instrumentDescriptor);
            }
        }
        return instrumentsList;
    }
    parseRawOffers(data) {
        let lines, i, rawOffersList, rawOffer;
        rawOffersList = new RawOffersList();
        lines = this.linesParser.splitLine(data);
        for (i = 0; i <= lines.length - 1; i += 1) {
            rawOffer = this.rawOfferCsvParser.parse(lines[i]);
            if (rawOffer != null) {
                rawOffersList.add(rawOffer);
            }
        }
        return rawOffersList;
    }
}
module.exports = GetInstrumentDescriptorsAndRawOffersFxmsgReader
