'use strict';
let LogManager = require('./LogManager.js');
let list = require('@gehtsoft/LuaxStdlib-node').list;
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let PriceHistoryDxfRequest = require('./PriceHistoryDxfRequest.js');
let PriceHistoryValidator = require('./PriceHistoryValidator.js');
let FXConnectLiteErrorBuilder = require('./FXConnectLiteErrorBuilder.js');
let DXFeedSubscribeForTimeSeriesRequest = require('./DXFeedSubscribeForTimeSeriesRequest.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let DXFeedSubscribeForTimeSeriesMessage = require('./DXFeedSubscribeForTimeSeriesMessage.js');
let StringValueObject = require('./StringValueObject.js');
let TimeframeUtils = require('./TimeframeUtils.js');
let string_map = require('@gehtsoft/LuaxStdlib-node').string_map;
let IntValueObject = require('./IntValueObject.js');
class DXFeedPriceHistoryMediator {
    dXFeedConnection;
    logger;
    receiveTimeSeriesListener;
    requestsSent;
    requestsQueue;
    isOnRun;
    timeController;
    dXFeedUnsubscriptionCallback;
    schedulerInterval;
    timeoutInterval;
    timeoutScheduler;
    pollingCallback;
    dxFeedNamesProvider;
    uniqueInt;
    constructor() {
        this.logger = LogManager.getLogger();
        this.receiveTimeSeriesListener = new DXFeedPriceHistoryMediator.ReceiveTimeSeriesListener(this);
        this.dXFeedUnsubscriptionCallback = new DXFeedPriceHistoryMediator.DXFeedUnsubscriptionCallback(this);
        this.pollingCallback = new DXFeedPriceHistoryMediator.PollingCallback(this);
        this.requestsSent = new list();
        this.requestsQueue = new list();
        this.isOnRun = false;
        this.uniqueInt = 0;
    }
    static create(dXFeedConnection, timeController, dxFeedNamesProvider) {
        let instance;
        instance = new DXFeedPriceHistoryMediator();
        instance.dXFeedConnection = dXFeedConnection;
        instance.timeController = timeController;
        instance.dxFeedNamesProvider = dxFeedNamesProvider;
        instance.schedulerInterval = 1000;
        instance.timeoutInterval = 30;
        instance.timeoutScheduler = scheduler.create(instance.schedulerInterval, instance.pollingCallback);
        return instance;
    }
    start() {
        if (!this.isOnRun) {
            this.dXFeedConnection.subscribeToReceiveTimeSeries(this.receiveTimeSeriesListener);
            this.isOnRun = true;
        }
    }
    stop() {
        this.timeoutScheduler.stop();
        this.dXFeedConnection.unsubscribeFromReceiveTimeSeries(this.receiveTimeSeriesListener);
        this.requestsSent.clear();
        this.requestsQueue.clear();
        this.isOnRun = false;
    }
    stopCommand(identity) {
        let i, timeSeriesRequestsContainer;
        for (i = 0; i <= this.requestsSent.length() - 1; i += 1) {
            timeSeriesRequestsContainer = this.requestsSent.get(i);
            if (timeSeriesRequestsContainer.getUniqueId() == identity) {
                this.dXFeedConnection.unsubscribeFromTimeSeries(timeSeriesRequestsContainer.getSeriesRequests(), this.dXFeedUnsubscriptionCallback);
                this.requestsSent.remove(i);
                this.checkQueue();
                break;
            }
        }
        this.stopTimeoutSchedulerIfNoRequestsToSend();
        for (i = 0; i <= this.requestsQueue.length() - 1; i += 1) {
            timeSeriesRequestsContainer = this.requestsQueue.get(i);
            if (timeSeriesRequestsContainer.getUniqueId() == identity) {
                this.requestsQueue.remove(i);
                break;
            }
        }
    }
    getPrices(instrument, timeframe, from, to, quotesCount, callback) {
        let request;
        request = PriceHistoryDxfRequest.create(instrument, timeframe, from, to, quotesCount);
        return this.getMultiplePrices([request], callback);
    }
    getMultiplePrices(requests, callback) {
        let error, errorBuilder, instrument, i, areErrors, timeSeriesRequests, timeoutJulian, dXFeedSubscriptionCallback, request, uniqueId, timeSeriesRequestsContainer;
        this.logger.info("DXFeedPriceHistoryMediator. Get prices");
        uniqueId = null;
        if (this.dXFeedConnection.getState().isConnected()) {
            areErrors = false;
            for (i = 0; i <= requests.length - 1; i += 1) {
                instrument = requests[i].getInstrument();
                error = PriceHistoryValidator.validateParameters(instrument, requests[i].getTimeframe(), requests[i].getFrom(), requests[i].getTo(), requests[i].isToFilled(), callback);
                if (error != null) {
                    errorBuilder = new FXConnectLiteErrorBuilder();
                    errorBuilder.setMessage(error);
                    this.logger.warning("DXFeedPriceHistoryMediator: " + error);
                    callback.onError(instrument, errorBuilder.build());
                    areErrors = true;
                }
            }
            if (areErrors) {
                callback.onAllComplete();
                return uniqueId;
            }
            timeSeriesRequests = new Array(requests.length);
            for (i = 0; i <= requests.length - 1; i += 1) {
                request = requests[i];
                timeSeriesRequests[i] = DXFeedSubscribeForTimeSeriesRequest.create(this.dxFeedNamesProvider.getSymbolForDxFeed(request.getInstrument()), request.getTimeframe(), request.getFrom());
            }
            timeoutJulian = stdlib.toJdn(stdlib.nowutc());
            timeoutJulian = timeoutJulian + this.timeoutInterval / 86400;
            if (this.requestsSent.length() == 0) {
                this.timeoutScheduler.startWithDelay();
            }
            uniqueId = this.getKeyForTimeSeriesRequestsContainer(requests);
            timeSeriesRequestsContainer = DXFeedPriceHistoryMediator.TimeSeriesRequestsContainer.create(requests, timeSeriesRequests, callback, timeoutJulian, uniqueId, this.logger);
            if (this.canSendNow(timeSeriesRequestsContainer)) {
                dXFeedSubscriptionCallback = new DXFeedPriceHistoryMediator.DXFeedSubscriptionCallback(this);
                dXFeedSubscriptionCallback.setUniqueId(uniqueId);
                this.requestsSent.add(timeSeriesRequestsContainer);
                this.dXFeedConnection.subscribeForTimeSeries(timeSeriesRequests, dXFeedSubscriptionCallback);
            }
            else {
                this.requestsQueue.add(timeSeriesRequestsContainer);
            }
        }
        return uniqueId;
    }
    getKeyForTimeSeriesRequestsContainer(requests) {
        let request, i, key;
        this.uniqueInt = this.uniqueInt + 1;
        key = "" + (this.uniqueInt).toString();
        for (i = 0; i <= requests.length - 1; i += 1) {
            request = requests[i];
            key = key + request.getInstrument() + DXFeedSubscribeForTimeSeriesMessage.getTimeframeString(request.getTimeframe());
        }
        return key;
    }
    checkQueue() {
        let i, timeSeriesRequestsContainerToCheck, dXFeedSubscriptionCallback;
        i = 0;
        while(i < this.requestsQueue.length()) {
            timeSeriesRequestsContainerToCheck = this.requestsQueue.get(i);
            if (this.canSendNow(timeSeriesRequestsContainerToCheck)) {
                dXFeedSubscriptionCallback = new DXFeedPriceHistoryMediator.DXFeedSubscriptionCallback(this);
                dXFeedSubscriptionCallback.setUniqueId(timeSeriesRequestsContainerToCheck.getUniqueId());
                this.requestsSent.add(timeSeriesRequestsContainerToCheck);
                this.dXFeedConnection.subscribeForTimeSeries(timeSeriesRequestsContainerToCheck.getSeriesRequests(), dXFeedSubscriptionCallback);
                this.requestsQueue.remove(i);
                continue;
            }
            i = i + 1;
        }
    }
    canSendNow(timeSeriesRequestsContainerToCheck) {
        let symbol, timeframeString, i, j, k, requests, request, requestsToCheck, requestToCheck, timeSeriesRequestsContainer;
        requestsToCheck = timeSeriesRequestsContainerToCheck.getRequests();
        for (i = 0; i <= requestsToCheck.length - 1; i += 1) {
            requestToCheck = requestsToCheck[i];
            symbol = requestToCheck.getInstrument();
            timeframeString = DXFeedSubscribeForTimeSeriesMessage.getTimeframeString(requestToCheck.getTimeframe());
            for (j = 0; j <= this.requestsSent.length() - 1; j += 1) {
                timeSeriesRequestsContainer = this.requestsSent.get(j);
                requests = timeSeriesRequestsContainer.getRequests();
                for (k = 0; k <= requests.length - 1; k += 1) {
                    request = requests[k];
                    if (request.getInstrument() == symbol && DXFeedSubscribeForTimeSeriesMessage.getTimeframeString(request.getTimeframe()) == timeframeString) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    processSeries(series) {
        let i, wasRemove;
        i = 0;
        wasRemove = false;
        while(i < this.requestsSent.length()) {
            if (this.checkTimeSeriesRequests(this.requestsSent.get(i), series)) {
                this.requestsSent.remove(i);
                wasRemove = true;
                continue;
            }
            i = i + 1;
        }
        if (wasRemove) {
            this.checkQueue();
        }
        this.stopTimeoutSchedulerIfNoRequestsToSend();
    }
    stopTimeoutSchedulerIfNoRequestsToSend() {
        if (this.requestsSent.length() == 0) {
            this.timeoutScheduler.stop();
        }
    }
    checkTimeSeriesRequests(timeSeriesRequestsContainer, series) {
        let requests, request, seria, finishedSymbols, seriaSymbol, seriaTimeframeString, i, j;
        finishedSymbols = new list();
        requests = timeSeriesRequestsContainer.getRequests();
        for (i = 0; i <= series.length - 1; i += 1) {
            seria = series[i];
            seriaSymbol = this.extractSymbol(seria.getSymbol());
            seriaTimeframeString = this.extractTimeFrameString(seria.getSymbol());
            for (j = 0; j <= requests.length - 1; j += 1) {
                request = requests[j];
                if (request.getInstrument() == seriaSymbol && DXFeedSubscribeForTimeSeriesMessage.getTimeframeString(request.getTimeframe()) == seriaTimeframeString) {
                    this.processSeria(timeSeriesRequestsContainer, seriaSymbol, seria, finishedSymbols, request);
                    break;
                }
            }
        }
        if (finishedSymbols.length() > 0) {
            if (this.processFinishedSymbols(timeSeriesRequestsContainer, finishedSymbols)) {
                return true;
            }
        }
        return false;
    }
    processFinishedSymbols(timeSeriesRequestsContainer, finishedSymbols) {
        let callback, i, totalFinished, keys, seriaSymbol, timeSeriesRequests;
        callback = timeSeriesRequestsContainer.getCallback();
        for (i = 0; i <= finishedSymbols.length() - 1; i += 1) {
            seriaSymbol = finishedSymbols.get(i).get();
            callback.onSuccess(seriaSymbol, timeSeriesRequestsContainer.getResponsesList().getSeriaArray(seriaSymbol));
        }
        totalFinished = 0;
        keys = timeSeriesRequestsContainer.getResponsesList().getSymbols();
        for (i = 0; i <= keys.length - 1; i += 1) {
            if (timeSeriesRequestsContainer.getResponsesList().getFinished(keys[i])) {
                totalFinished = totalFinished + 1;
            }
        }
        if (totalFinished == keys.length) {
            timeSeriesRequests = timeSeriesRequestsContainer.getSeriesRequests();
            this.dXFeedConnection.unsubscribeFromTimeSeries(timeSeriesRequests, this.dXFeedUnsubscriptionCallback);
            callback.onAllComplete();
            return true;
        }
        return false;
    }
    processSeria(timeSeriesRequestsContainer, seriaSymbol, seria, finishedSymbols, request) {
        if (this.checkZeroValues(seria) && !timeSeriesRequestsContainer.getResponsesList().getFinished(seriaSymbol)) {
            finishedSymbols.add(StringValueObject.create(seriaSymbol));
            timeSeriesRequestsContainer.getResponsesList().setFinished(seriaSymbol);
            return;
        }
        if (this.checkWhetherContinue(timeSeriesRequestsContainer.getResponsesList().getToFill(seriaSymbol), seria, request)) {
            return;
        }
        timeSeriesRequestsContainer.getResponsesList().addSeria(seriaSymbol, seria);
        if (this.checkTime(seria, request)) {
            finishedSymbols.add(StringValueObject.create(seriaSymbol));
            timeSeriesRequestsContainer.getResponsesList().setFinished(seriaSymbol);
            timeSeriesRequestsContainer.getResponsesList().resetToFill(seriaSymbol);
            return;
        }
        if (this.checkCount(timeSeriesRequestsContainer, request, seriaSymbol)) {
            finishedSymbols.add(StringValueObject.create(seriaSymbol));
            timeSeriesRequestsContainer.getResponsesList().setFinished(seriaSymbol);
            timeSeriesRequestsContainer.getResponsesList().resetToFill(seriaSymbol);
        }
    }
    extractSymbol(line) {
        let index, result;
        index = stdlib.indexOf(line, "{", false);
        result = line;
        if (index > -1) {
            result = stdlib.substring(line, 0, index);
        }
        return result;
    }
    extractTimeFrameString(line) {
        let index1, index2, result;
        index1 = stdlib.indexOf(line, "{=", false);
        index2 = stdlib.indexOf(line, "}", false);
        result = line;
        if (index1 > -1 && index2 > -1 && index2 > index1) {
            result = stdlib.substring(line, index1 + 2, index2 - index1 - 2);
        }
        if (stdlib.len(result) == 1) {
            result = "1" + result;
        }
        return result;
    }
    checkCount(timeSeriesRequestsContainer, request, symbol) {
        return request.getQuotesCount() > 0 && timeSeriesRequestsContainer.getResponsesList().getSeriaArray(symbol).length >= request.getQuotesCount();
    }
    checkTime(seria, request) {
        return stdlib.toJdn(stdlib.toutc(seria.getTime())) - TimeframeUtils.getJdnIncrement(request.getTimeframe()) < stdlib.toJdn(request.getFrom());
    }
    checkWhetherContinue(toFill, seria, request) {
        return !toFill || request.isToFilled() && stdlib.toJdn(stdlib.toutc(seria.getTime())) >= stdlib.toJdn(request.getTo());
    }
    checkZeroValues(seria) {
        return seria.getOpen() == 0.0 && seria.getClose() == 0.0 && seria.getHigh() == 0.0 && seria.getLow() == 0.0;
    }
}
module.exports = DXFeedPriceHistoryMediator
DXFeedPriceHistoryMediator.PollingCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        let i, timeSeriesRequestsContainer, timeoutJulian, wasRemove;
        wasRemove = false;
        timeoutJulian = stdlib.toJdn(stdlib.nowutc());
        i = 0;
        while(i < this._owner_.requestsSent.length()) {
            timeSeriesRequestsContainer = this._owner_.requestsSent.get(i);
            if (timeSeriesRequestsContainer.getTimeout() <= timeoutJulian) {
                this.processTimeout(timeSeriesRequestsContainer);
                this._owner_.requestsSent.remove(i);
                wasRemove = true;
                continue;
            }
            i = i + 1;
        }
        if (wasRemove) {
            this._owner_.checkQueue();
        }
        this._owner_.stopTimeoutSchedulerIfNoRequestsToSend();
    }
    processTimeout(timeSeriesRequestsContainer) {
        let errorBuilder, mess, callback, i, keys, series;
        callback = timeSeriesRequestsContainer.getCallback();
        mess = "Timeout: not finished history receives";
        errorBuilder = new FXConnectLiteErrorBuilder();
        errorBuilder.setMessage(mess);
        keys = timeSeriesRequestsContainer.getResponsesList().getSymbols();
        for (i = 0; i <= keys.length - 1; i += 1) {
            if (!timeSeriesRequestsContainer.getResponsesList().getFinished(keys[i])) {
                series = timeSeriesRequestsContainer.getResponsesList().getSeriaArray(keys[i]);
                if (series.length == 0) {
                    callback.onError(keys[i], errorBuilder.build());
                }
                else {
                    callback.onSuccess(keys[i], series);
                }
            }
        }
        this._owner_.logger.error(mess);
        this._owner_.dXFeedConnection.unsubscribeFromTimeSeries(timeSeriesRequestsContainer.getSeriesRequests(), this._owner_.dXFeedUnsubscriptionCallback);
        callback.onAllComplete();
    }
}
DXFeedPriceHistoryMediator.TimeSeriesRequestsContainer = class {
    timeSeriesRequests;
    callback;
    timeout;
    responsesList;
    requests;
    uniqueId;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(requests, timeSeriesRequests, callback, timeout, uniqueId, logger) {
        let instance;
        instance = new DXFeedPriceHistoryMediator.TimeSeriesRequestsContainer(this);
        instance.requests = requests;
        instance.timeSeriesRequests = timeSeriesRequests;
        instance.callback = callback;
        instance.timeout = timeout;
        instance.uniqueId = uniqueId;
        instance.responsesList = DXFeedPriceHistoryMediator.ResponsesList.create(requests, logger);
        return instance;
    }
    getUniqueId() {
        return this.uniqueId;
    }
    getRequests() {
        return this.requests;
    }
    getSeriesRequests() {
        return this.timeSeriesRequests;
    }
    getCallback() {
        return this.callback;
    }
    getTimeout() {
        return this.timeout;
    }
    getResponsesList() {
        return this.responsesList;
    }
}
DXFeedPriceHistoryMediator.ResponsesList = class {
    mapa;
    logger;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(requests, logger) {
        let instance, i;
        instance = new DXFeedPriceHistoryMediator.ResponsesList(this);
        instance.mapa = new string_map();
        instance.logger = logger;
        for (i = 0; i <= requests.length - 1; i += 1) {
            instance.mapa.set(requests[i].getInstrument(), DXFeedPriceHistoryMediator.Response.create());
        }
        return instance;
    }
    getSymbols() {
        return this.mapa.keys();
    }
    addSeria(symbol, seria) {
        if (this.mapa.contains(symbol)) {
            this.mapa.get(symbol).addSeria(seria);
        }
    }
    getSeriaArray(symbol) {
        let i, len, result, response;
        if (this.mapa.contains(symbol)) {
            response = this.mapa.get(symbol);
            len = response.getSeriaLength();
            result = new Array(len);
            for (i = 0; i <= len - 1; i += 1) {
                result[i] = response.getSeriaAt(i);
            }
            return result;
        }
        return new Array(0);
    }
    getSeriaLength(symbol) {
        if (this.mapa.contains(symbol)) {
            return this.mapa.get(symbol).getSeriaLength();
        }
        return 0;
    }
    getFinished(symbol) {
        let ex;
        try {
            if (this.mapa.contains(symbol)) {
                return this.mapa.get(symbol).getFinished();
            }
        } catch(exTemp1) {
            ex = stdlib.ensureException(exTemp1);
            this.logger.warning("DXFeedPriceHistoryMediator.ResponsesList.getFinished() exception: " + ex.getMessage());
        }
        return false;
    }
    setFinished(symbol) {
        if (this.mapa.contains(symbol)) {
            this.mapa.get(symbol).setFinished();
        }
    }
    getToFill(symbol) {
        if (this.mapa.contains(symbol)) {
            return this.mapa.get(symbol).getToFill();
        }
        return false;
    }
    resetToFill(symbol) {
        if (this.mapa.contains(symbol)) {
            this.mapa.get(symbol).resetToFill();
        }
    }
}
DXFeedPriceHistoryMediator.Response = class {
    isFinished;
    toFill;
    lista;
    mapa;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.isFinished = false;
        this.toFill = true;
        this.lista = new list();
        this.mapa = new string_map();
    }
    static create() {
        return new DXFeedPriceHistoryMediator.Response(this);
    }
    addSeria(seria) {
        let indexField, foundN;
        indexField = seria.getIndex();
        if (!this.mapa.contains(indexField)) {
            this.lista.add(seria);
            this.mapa.set(indexField, IntValueObject.create(this.lista.length() - 1));
        }
        else {
            foundN = this.mapa.get(indexField).get();
            this.lista.set(foundN, seria);
        }
    }
    getSeriaAt(index) {
        if (index < this.lista.length()) {
            return this.lista.get(index);
        }
        return null;
    }
    getSeriaLength() {
        return this.lista.length();
    }
    getFinished() {
        return this.isFinished;
    }
    setFinished() {
        this.isFinished = true;
    }
    getToFill() {
        return this.toFill;
    }
    resetToFill() {
        this.toFill = false;
    }
}
DXFeedPriceHistoryMediator.DXFeedSubscriptionCallback = class {
    uniqueId;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccess() {
        this._owner_.logger.info("Subscription for time series was successful.");
    }
    onError(errorMessage) {
        let errorBuilder, mess, callback, timeSeriesRequestsContainer, i;
        for (i = 0; i <= this._owner_.requestsSent.length() - 1; i += 1) {
            timeSeriesRequestsContainer = this._owner_.requestsSent.get(i);
            if (timeSeriesRequestsContainer.getUniqueId() == this.uniqueId) {
                callback = timeSeriesRequestsContainer.getCallback();
                errorBuilder = new FXConnectLiteErrorBuilder();
                errorBuilder.setMessage(mess);
                callback.onError("", errorBuilder.build());
                this._owner_.dXFeedConnection.unsubscribeFromTimeSeries(timeSeriesRequestsContainer.getSeriesRequests(), this._owner_.dXFeedUnsubscriptionCallback);
                callback.onAllComplete();
                this._owner_.logger.error(mess);
                this._owner_.requestsSent.remove(i);
                this._owner_.checkQueue();
                break;
            }
        }
    }
    setUniqueId(uniqueId) {
        this.uniqueId = uniqueId;
    }
}
DXFeedPriceHistoryMediator.DXFeedUnsubscriptionCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccess() {
        this._owner_.logger.info("Unubscription for time series was successful.");
    }
    onError(errorMessage) {
        let mess;
        mess = "Unsubscription for time series failed. Error: " + errorMessage;
        this._owner_.logger.error(mess);
    }
}
DXFeedPriceHistoryMediator.ReceiveTimeSeriesListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onTimeSeriesReceived(series) {
        this._owner_.processSeries(series);
    }
}
