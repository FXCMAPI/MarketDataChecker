'use strict';
let InstrumentsStorage = require('./InstrumentsStorage.js');
let InstrumentDescriptorsStorage = require('./InstrumentDescriptorsStorage.js');
let InstrumentUpdatesStorage = require('./InstrumentUpdatesStorage.js');
let DataManagerState = require('./DataManagerState.js');
let DataManagerStatePublisher = require('./DataManagerStatePublisher.js');
let CommonPublisher = require('./CommonPublisher.js');
let LogManager = require('./LogManager.js');
let int_map = require('@gehtsoft/LuaxStdlib-node').int_map;
let TradingSessionProvider = require('./TradingSessionProvider.js');
let QueuedInstrumentsSubscriptionManager = require('./QueuedInstrumentsSubscriptionManager.js');
let InstrumentLoader = require('./InstrumentLoader.js');
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let FXConnectLiteErrorCodes = require('./FXConnectLiteErrorCodes.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let StringUtil = require('./StringUtil.js');
let ExecutionTimeEventName = require('./ExecutionTimeEventName.js');
let list = require('@gehtsoft/LuaxStdlib-node').list;
let StringValueObject = require('./StringValueObject.js');
let ExecutionTimeEvenUtil = require('./ExecutionTimeEvenUtil.js');
let CollectionUtils = require('./CollectionUtils.js');
let MessageType = require('./MessageType.js');
let UpdateCommandType = require('./UpdateCommandType.js');
let InstrumentsUpdater = require('./InstrumentsUpdater.js');
let InstrumentDescriptorUpdater = require('./InstrumentDescriptorUpdater.js');
let EventManager = require('./EventManager.js');
let ExecutionTimeEventBuilder = require('./ExecutionTimeEventBuilder.js');
//@@DocBrief("The class for getting access to instruments data")
class InstrumentsManager {
    storage;
    descriptorsStorage;
    instrumentUpdatesStorage;
    state;
    stateChangePublisher;
    instrumentChangePublisher;
    messageRouter;
    commandFactory;
    sessionProvider;
    messageFactory;
    requestNumberGenerator;
    messageExecutor;
    receiveNewMessageListener;
    connectionStatusManager;
    instrumentsSubscriptionManager;
    instrumentLoader;
    logger;
    accountBaseSymbolsProvider;
    eventRefresh;
    instrumentsLoaderMap;
    constructor() {
        this.storage = new InstrumentsStorage();
        this.descriptorsStorage = new InstrumentDescriptorsStorage();
        this.instrumentUpdatesStorage = new InstrumentUpdatesStorage();
        this.state = new DataManagerState();
        this.stateChangePublisher = new DataManagerStatePublisher();
        this.instrumentChangePublisher = new CommonPublisher();
        this.setReceiveNewMessageListener();
        this.logger = LogManager.getLogger();
        this.instrumentsLoaderMap = new int_map();
    }
    getInstrumentsStorage() {
        return this.storage;
    }
    getInstrumentDescriptorsStorage() {
        return this.descriptorsStorage;
    }
    getInstrumentUpdatesStorage() {
        return this.instrumentUpdatesStorage;
    }
    static create(commandFactory, messageRouter, messageExecutor, sessionStorage, messageFactory, requestNumberGenerator, connectionStatusManager, instrumentDescriptorsSeparator, dxFeedNamesProvider, clientCrossSymbolsProvider, manageOffersProvider, accountBaseSymbolsProvider) {
        let result;
        result = new InstrumentsManager();
        result.commandFactory = commandFactory;
        result.messageRouter = messageRouter;
        result.messageExecutor = messageExecutor;
        result.accountBaseSymbolsProvider = accountBaseSymbolsProvider;
        result.sessionProvider = TradingSessionProvider.create(sessionStorage);
        result.messageFactory = messageFactory;
        result.requestNumberGenerator = requestNumberGenerator;
        result.connectionStatusManager = connectionStatusManager;
        result.instrumentsSubscriptionManager = QueuedInstrumentsSubscriptionManager.create(commandFactory, messageRouter, messageExecutor, sessionStorage, messageFactory, requestNumberGenerator, result.descriptorsStorage, result.storage, instrumentDescriptorsSeparator, manageOffersProvider, result.instrumentUpdatesStorage);
        if (clientCrossSymbolsProvider != null) {
            result.instrumentsSubscriptionManager.setClientCrossSymbolsProvider(clientCrossSymbolsProvider);
        }
        result.instrumentLoader = InstrumentLoader.create(commandFactory, messageRouter, messageExecutor, sessionStorage, messageFactory, requestNumberGenerator);
        result.subscribeOnRequiredMessages();
        return result;
    }
    setClientCrossSymbolsProvider(clientCrossSymbolsProvider) {
        this.instrumentsSubscriptionManager.setClientCrossSymbolsProvider(clientCrossSymbolsProvider);
    }
    setLeverageProfilesUpdater(leverageProfilesUpdater) {
        this.instrumentsSubscriptionManager.setLeverageProfilesUpdater(leverageProfilesUpdater);
        this.instrumentLoader.setLeverageProfilesUpdater(leverageProfilesUpdater);
    }
    subscribeInstrumentChange(listener) {
        if (listener == null) {
            this.logger.error("InstrumentsManager.subscribeInstrumentChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.instrumentChangePublisher.subscribe(listener);
    }
    unsubscribeInstrumentChange(listener) {
        if (listener == null) {
            this.logger.error("InstrumentsManager.unsubscribeInstrumentChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.instrumentChangePublisher.unsubscribe(listener);
    }
    getAllInstruments() {
        this.logger.info("InstrumentsManager. Get all instruments");
        return this.storage.getAllInstruments();
    }
    getAllInstrumentDescriptors() {
        this.logger.debug("InstrumentsManager. Get all instrument descriptors");
        return this.descriptorsStorage.getAllInstrumentDescriptors();
    }
    getInstrumentBySymbol(symbol) {
        if (symbol == null || stdlib.len(symbol) == 0) {
            this.logger.error("InstrumentsManager.getInstrumentBySymbol(): symbol is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "symbol is not set");
        }
        this.logger.debug("InstrumentsManager. Get instrument by symbol: " + symbol);
        return this.storage.getInstrumentBySymbol(symbol);
    }
    getInstrumentByOfferId(offerId) {
        if (offerId == null || stdlib.len(offerId) == 0) {
            this.logger.error("InstrumentsManager.getInstrumentByOfferId(): offerId is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "offerId is not set");
        }
        this.logger.debug("InstrumentsManager. Get instrument by offerId: " + offerId);
        return this.storage.getInstrumentByOfferId(offerId);
    }
    subscribeStateChange(listener) {
        if (listener == null) {
            this.logger.error("InstrumentsManager.subscribeStateChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.stateChangePublisher.subscribe(listener);
    }
    unsubscribeStateChange(listener) {
        if (listener == null) {
            this.logger.error("InstrumentsManager.unsubscribeStateChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.stateChangePublisher.unsubscribe(listener);
    }
    getInstrumentDescriptorByOfferId(offerId) {
        if (offerId == null || stdlib.len(offerId) == 0) {
            this.logger.error("InstrumentsManager.getInstrumentDescriptorByOfferId(): offerId is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "offerId is not set");
        }
        return this.descriptorsStorage.getInstrumentDescriptorByOfferId(offerId);
    }
    getInstrumentDescriptorBySymbol(symbol) {
        if (symbol == null || stdlib.len(symbol) == 0) {
            this.logger.error("InstrumentsManager.getInstrumentDescriptorBySymbol(): symbol is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "symbol is not set");
        }
        return this.descriptorsStorage.getInstrumentDescriptorBySymbol(symbol);
    }
    getInstrumentDescriptorByDxfeedSymbol(symbol) {
        if (symbol == null || stdlib.len(symbol) == 0) {
            this.logger.error("InstrumentsManager.getInstrumentDescriptorByDxfeedSymbol(): symbol is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "symbol is not set");
        }
        return this.descriptorsStorage.getInstrumentDescriptorByDxfeedSymbol(symbol);
    }
    getDxfeedSymbolBySymbol(symbol) {
        if (symbol == null || stdlib.len(symbol) == 0) {
            this.logger.error("InstrumentsManager.getDxfeedSymbolBySymbol(): symbol is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "symbol is not set");
        }
        return this.descriptorsStorage.getDxfeedSymbolBySymbol(symbol);
    }
    checkSubscrParameters(funcName, symbols, callback) {
        if (symbols == null) {
            this.logger.error("InstrumentsManager." + funcName + "(): symbols is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "symbols is not set");
        }
        if (callback == null) {
            this.logger.error("InstrumentsManager." + funcName + "(): callback is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "callback is not set");
        }
    }
    subscribeInstruments(symbols, callback) {
        this.checkSubscrParameters("subscribeInstruments", symbols, callback);
        if (!this.connectionStatusManager.getConnectionStatus().isConnected()) {
            this.logger.warning("InstrumentsManager. Subscribe instruments: Session not connected");
            callback.onError("Session not connected.", symbols);
            return;
        }
        this.logger.info("InstrumentsManager.subscribeInstruments(" + StringUtil.arrayToString(symbols) + ")");
        this.instrumentsSubscriptionManager.subscribeInstruments(symbols, this.createLocalSubscribeInstrumentsCallback(ExecutionTimeEventName.SubscribeInstrumentsTime, callback), false);
    }
    checkAndLoadCrossCources(symbols, callback) {
        this.checkSubscrParameters("checkAndLoadCrossCources", symbols, callback);
        if (!this.connectionStatusManager.getConnectionStatus().isConnected()) {
            this.logger.warning("InstrumentsManager. checkAndLoadCrossCources: Session not connected");
            callback.onError("Session not connected.", symbols);
            return;
        }
        this.logger.info("InstrumentsManager.checkAndLoadCrossCources(" + StringUtil.arrayToString(symbols) + ")");
        this.instrumentsSubscriptionManager.checkAndLoadCrossCources(symbols, this.createLocalSubscribeInstrumentsCallback(ExecutionTimeEventName.CheckAndLoadCrossCoursesTime, callback));
    }
    unsubscribeInstruments(symbols, callback) {
        this.checkSubscrParameters("unsubscribeInstruments", symbols, callback);
        if (!this.connectionStatusManager.getConnectionStatus().isConnected()) {
            this.logger.warning("InstrumentsManager. Unsubscribe instruments: Session not connected");
            callback.onError("Session not connected.", symbols);
            return;
        }
        this.logger.info("InstrumentsManager.unsubscribeInstruments(" + StringUtil.arrayToString(symbols) + ")");
        this.instrumentsSubscriptionManager.unsubscribeInstruments(symbols, this.createLocalSubscribeInstrumentsCallback(ExecutionTimeEventName.UnsubscribeInstrumentsTime, callback), false);
    }
    subscribeInstrumentsAndStoreOnServer(symbols, callback) {
        this.checkSubscrParameters("subscribeInstrumentsAndStoreOnServer", symbols, callback);
        if (!this.connectionStatusManager.getConnectionStatus().isConnected()) {
            this.logger.warning("InstrumentsManager. Subscribe instruments: Session not connected");
            callback.onError("Session not connected.", symbols);
            return;
        }
        this.logger.info("InstrumentsManager.subscribeInstrumentsAndStoreOnServer(" + StringUtil.arrayToString(symbols) + ")");
        this.instrumentsSubscriptionManager.subscribeInstruments(symbols, this.createLocalSubscribeInstrumentsCallback(ExecutionTimeEventName.SubscribeInstrumentsAndStoreOnServerTime, callback), true);
    }
    unsubscribeInstrumentsAndStoreOnServer(symbols, callback) {
        this.checkSubscrParameters("unsubscribeInstrumentsAndStoreOnServer", symbols, callback);
        if (!this.connectionStatusManager.getConnectionStatus().isConnected()) {
            this.logger.warning("InstrumentsManager. Unsubscribe instruments: Session not connected");
            callback.onError("Session not connected.", symbols);
            return;
        }
        this.instrumentsSubscriptionManager.unsubscribeInstruments(symbols, this.createLocalSubscribeInstrumentsCallback(ExecutionTimeEventName.UnsubscribeInstrumentsAndStoreOnServerTime, callback), true);
    }
    createLocalSubscribeInstrumentsCallback(eventName, callback) {
        return InstrumentsManager.LocalSubscribeInstrumentsCallback.create(eventName, callback, this);
    }
    isPriceStreamHasSubscribedInstruments(streamId) {
        if (streamId == null || stdlib.len(streamId) == 0) {
            this.logger.error("InstrumentsManager.isPriceStreamHasSubscribedInstruments(): streamId is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "streamId is not set");
        }
        return this.descriptorsStorage.isPriceStreamHasSubscribedInstruments(streamId);
    }
    getSubscribedInstruments() {
        return this.storage.getSubscribedInstruments();
    }
    getState() {
        return this.state;
    }
    refresh() {
        let getAllInstrumentsCommand, i, offerIds, offerIdsList, instrumentDescriptors, instrumentDescriptor;
        this.logger.info("InstrumentsManager. Load all instruments from server");
        if (this.getState().isLoading()) {
            this.logger.warning("InstrumentsManager. Manager not loaded yet");
            return;
        }
        if (!this.connectionStatusManager.getConnectionStatus().isConnected()) {
            this.logger.warning("InstrumentsManager. Session not connected");
            return;
        }
        offerIdsList = new list();
        instrumentDescriptors = this.getAllInstrumentDescriptors();
        for (i = 0; i <= instrumentDescriptors.length - 1; i += 1) {
            instrumentDescriptor = instrumentDescriptors[i];
            if (instrumentDescriptor.getSubscriptionStatus() == "T" || instrumentDescriptor.getSubscriptionStatus() == "V") {
                offerIdsList.add(StringValueObject.create(instrumentDescriptor.getOfferId()));
            }
        }
        this.eventRefresh = ExecutionTimeEvenUtil.eventStart(ExecutionTimeEventName.InstrumentsManagerRefreshTime);
        if (offerIdsList.length() > 0) {
            offerIds = new Array(offerIdsList.length());
            for (i = 0; i <= offerIdsList.length() - 1; i += 1) {
                offerIds[i] = offerIdsList.get(i).get();
            }
            this.notifyStateChange(DataManagerState.LOADING);
            getAllInstrumentsCommand = this.commandFactory.createGetAllInstrumentsCommand(offerIds, this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator.getNextRequestNumber());
            getAllInstrumentsCommand.execute();
        }
        else {
            this.logger.warning("InstrumentsManager. No instruments descriptors found for refresh");
            ExecutionTimeEvenUtil.eventStop(this.eventRefresh);
            this.notifyStateChange(DataManagerState.LOADED);
        }
    }
    getOrLoadInstrumentsByOfferIds(offerIds, callback) {
        this.getOrLoadInstrumentsByOfferIdsCommon(offerIds, callback, true);
    }
    getInstrumentsSnapshot(offerIds, callback) {
        this.getOrLoadInstrumentsByOfferIdsCommon(offerIds, callback, false);
    }
    getOrLoadInstrumentsByOfferIdsCommon(offerIds, callback, loadLeverages) {
        let itemsForLoad, i, requestNumber, command;
        if (offerIds == null) {
            this.logger.error("InstrumentsManager.getOrLoadInstrumentsByOfferIds(): offerIds is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "offerIds is not set");
        }
        if (callback == null) {
            this.logger.error("InstrumentsManager.getOrLoadInstrumentsByOfferIds(): callback is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "callback is not set");
        }
        itemsForLoad = new list();
        for (i = 0; i <= offerIds.length - 1; i += 1) {
            if (this.storage.getInstrumentByOfferId(offerIds[i]) == null && this.descriptorsStorage.getInstrumentDescriptorByOfferId(offerIds[i]) != null) {
                itemsForLoad.add(StringValueObject.create(offerIds[i]));
            }
        }
        if (itemsForLoad.length() > 0) {
            if (loadLeverages) {
                this.instrumentLoader.loadInstrument(CollectionUtils.stringListToArray(itemsForLoad), InstrumentsManager.InstrumentsAndLeveragesLoaderCallback.create(this.storage, offerIds, callback));
            }
            else {
                requestNumber = this.requestNumberGenerator.getNextRequestNumber();
                this.instrumentsLoaderMap.set(requestNumber, InstrumentsManager.InstrumentsLoaderCallback.create(callback));
                command = this.commandFactory.createGetAllInstrumentsCommand(offerIds, this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, requestNumber);
                command.execute();
            }
        }
        else {
            callback.onSuccess(this.storage.getInstrumentsByOfferIds(offerIds));
        }
    }
    notifyInstrumentChanged(instrument) {
        this.instrumentChangePublisher.notifyAction(InstrumentsManager.InstrumentChangedAction.create(instrument));
    }
    notifyInstrumentAdded(instrument) {
        this.instrumentChangePublisher.notifyAction(InstrumentsManager.InstrumentAddedAction.create(instrument));
    }
    notifyStateChange(stateStatus) {
        this.logger.debug("InstrumentsManager. State status changed: " + (stateStatus).toString());
        this.state.setState(stateStatus);
        this.stateChangePublisher.notifyStateChange(this.state);
    }
    setReceiveNewMessageListener() {
        this.receiveNewMessageListener = InstrumentsManager.ReceiveNewMessageListener.create(this);
    }
    subscribeOnRequiredMessages() {
        this.messageRouter.subscribeNewMessageReceive(MessageType.GetInstruments, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Connected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.InstrumentUpdateMessage, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.GetInstrumentDescriptors, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.CreateInstrumentChangeNotification, this.receiveNewMessageListener);
    }
    processMessage(message) {
        let getInstrumentDescriptorsMessage, createInstrumentChangeNotificationMessage, getInstrumentsMessage, updateInstrumentMessage, instrumentDescriptors, i;
        this.logger.debug("InstrumentsManager. Receive message: " + message.getType());
        if (message.getType() == MessageType.GetInstruments) {
            getInstrumentsMessage = message;
            this.processGetInstruments(getInstrumentsMessage);
        } else if (message.getType() == MessageType.GetInstrumentDescriptors) {
            getInstrumentDescriptorsMessage = message;
            instrumentDescriptors = getInstrumentDescriptorsMessage.getInstrumentDescriptors();
            this.descriptorsStorage.clear();
            for (i = 0; i <= instrumentDescriptors.length - 1; i += 1) {
                this.descriptorsStorage.addInstrumentDescriptor(instrumentDescriptors[i]);
            }
        } else if (message.getType() == MessageType.InstrumentUpdateMessage) {
            updateInstrumentMessage = message;
            this.updateInstrument(updateInstrumentMessage.getUpdateCommand(), updateInstrumentMessage.getInstrument());
        } else if (message.getType() == MessageType.CreateInstrumentChangeNotification) {
            createInstrumentChangeNotificationMessage = message;
            this.processCreateChangeNotification(createInstrumentChangeNotificationMessage.getOfferId());
        } else if (message.getType() == MessageType.Disconnected) {
            this.storage.clear();
            this.instrumentsSubscriptionManager.stop();
            this.instrumentLoader.stop();
            this.notifyStateChange(DataManagerState.NOT_LOADED);
        } else if (message.getType() == MessageType.Connected) {
            this.updateStatusesForBaseInstruments();
        }
    }
    processGetInstruments(getInstrumentsMessage) {
        let updInstruments, oldInstrument, updInstrument, i, requestNumber, instruments, instrumentsLoaderCallback, baseSymbols;
        updInstruments = getInstrumentsMessage.getInstruments();
        requestNumber = StringUtil.getRequestNumber(getInstrumentsMessage.getRequestId());
        if (this.instrumentsLoaderMap.contains(requestNumber)) {
            instruments = new Array(updInstruments.length);
            for (i = 0; i <= updInstruments.length - 1; i += 1) {
                instruments[i] = updInstruments[i].getInstrument();
            }
            instrumentsLoaderCallback = this.instrumentsLoaderMap.get(requestNumber);
            this.instrumentsLoaderMap.remove(requestNumber);
            instrumentsLoaderCallback.onSuccess(instruments);
            return;
        }
        baseSymbols = this.accountBaseSymbolsProvider.getBaseSymbols();
        for (i = 0; i <= updInstruments.length - 1; i += 1) {
            updInstrument = updInstruments[i];
            oldInstrument = this.storage.getInstrumentByOfferId(updInstrument.getInstrument().getOfferId());
            if (oldInstrument != null) {
                updInstrument.mergeToInstrument(oldInstrument);
                this.processUpd(updInstrument);
            }
            else {
                this.storage.addInstrument(updInstrument.getInstrument());
            }
            this.updateStatusIfBaseInstrument(updInstrument.getInstrument(), baseSymbols);
        }
        if (this.getState().isLoading()) {
            ExecutionTimeEvenUtil.eventStop(this.eventRefresh);
            this.notifyStateChange(DataManagerState.LOADED);
        }
    }
    updateStatusIfBaseInstrument(instrument, baseSymbols) {
        let builder, i;
        if (instrument.getSubscriptionStatus() == "D") {
            for (i = 0; i <= baseSymbols.length - 1; i += 1) {
                if (baseSymbols[i] == instrument.getSymbol()) {
                    builder = instrument;
                    builder.setSubscriptionStatus("V");
                    return;
                }
            }
        }
    }
    updateStatusesForBaseInstruments() {
        let baseSymbols, builder, i;
        baseSymbols = this.accountBaseSymbolsProvider.getBaseSymbols();
        for (i = 0; i <= baseSymbols.length - 1; i += 1) {
            builder = this.descriptorsStorage.getInstrumentDescriptorBySymbol(baseSymbols[i]);
            if (builder.getSubscriptionStatus() == "D") {
                builder.setSubscriptionStatus("V");
            }
        }
    }
    updateInstrument(updateType, updInstrument) {
        if (updateType == UpdateCommandType.UPDATE) {
            this.processUpd(updInstrument);
        } else if (updateType == UpdateCommandType.INSERT) {
            this.storage.addInstrument(updInstrument.getInstrument());
            this.notifyInstrumentAdded(updInstrument.getInstrument());
        }
    }
    processCreateChangeNotification(offerId) {
        let oldInstrument;
        if (!this.getState().isLoaded()) {
            return;
        }
        oldInstrument = this.storage.getInstrumentByOfferId(offerId);
        if (oldInstrument == null) {
            return;
        }
        this.notifyInstrumentChanged(oldInstrument);
    }
    processUpd(updInstrument) {
        let oldInstrument, oldInstrumentBuilder, instrumentDescriptor, changedMainProperties, subscriptionStatusChanged, symbol;
        if (!this.getState().isLoaded()) {
            return;
        }
        oldInstrument = this.storage.getInstrumentByOfferId(updInstrument.getInstrument().getOfferId());
        if (oldInstrument == null) {
            return;
        }
        symbol = oldInstrument.getSymbol();
        oldInstrumentBuilder = oldInstrument;
        changedMainProperties = InstrumentsUpdater.processMainPropertiesUpdate(updInstrument, oldInstrumentBuilder);
        subscriptionStatusChanged = false;
        if (this.checkOurInitiatedUpdates(symbol)) {
            instrumentDescriptor = this.descriptorsStorage.getInstrumentDescriptorBySymbol(symbol);
            InstrumentDescriptorUpdater.processUpdate(updInstrument, instrumentDescriptor);
            subscriptionStatusChanged = InstrumentsUpdater.processSubscriptionStatus(updInstrument, oldInstrumentBuilder);
            if (subscriptionStatusChanged) {
                this.removeFromOurInitiatedUpdates(symbol);
            }
        }
        if (changedMainProperties || subscriptionStatusChanged) {
            this.notifyInstrumentChanged(oldInstrumentBuilder);
        }
    }
    checkOurInitiatedUpdates(symbol) {
        return this.instrumentUpdatesStorage.hasSymbol(symbol);
    }
    removeFromOurInitiatedUpdates(symbol) {
        this.instrumentUpdatesStorage.removeSymbol(symbol);
    }
}
module.exports = InstrumentsManager
InstrumentsManager.LocalSubscribeInstrumentsCallback = class {
    callback;
    event;
    manager;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccess() {
        this.event.stop();
        EventManager.getLogger().performance(this.event.build());
        this.callback.onSuccess();
    }
    onError(error, unsucceededSymbols) {
        let i, symbolsList, s, instrumentDescriptor;
        symbolsList = new list();
        for (i = 0; i <= unsucceededSymbols.length - 1; i += 1) {
            s = unsucceededSymbols[i];
            if (StringUtil.isIntNumber(s)) {
                instrumentDescriptor = this.manager.getInstrumentDescriptorByOfferId(s);
                if (instrumentDescriptor != null) {
                    symbolsList.add(StringValueObject.create(instrumentDescriptor.getSymbol()));
                }
            }
            else {
                symbolsList.add(StringValueObject.create(s));
            }
        }
        this.event.stopWithError(error);
        this.callback.onError(error, CollectionUtils.stringListToArray(symbolsList));
    }
    static create(eventName, callback, manager) {
        let instance;
        instance = new InstrumentsManager.LocalSubscribeInstrumentsCallback(this);
        instance.manager = manager;
        instance.callback = callback;
        instance.event = ExecutionTimeEventBuilder.create(eventName);
        instance.event.start();
        return instance;
    }
}
InstrumentsManager.ReceiveNewMessageListener = class {
    owner;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        this.owner.processMessage(message);
    }
    static create(owner) {
        let instance;
        instance = new InstrumentsManager.ReceiveNewMessageListener(this);
        instance.owner = owner;
        return instance;
    }
}
InstrumentsManager.InstrumentChangedAction = class {
    listener;
    instrument;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(instrument) {
        let result;
        result = new InstrumentsManager.InstrumentChangedAction(this);
        result.instrument = instrument;
        return result;
    }
    setListener(listener) {
        this.listener = listener;
    }
    execute() {
        this.listener.onChange(this.instrument);
    }
}
InstrumentsManager.InstrumentAddedAction = class {
    listener;
    instrument;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(instrument) {
        let result;
        result = new InstrumentsManager.InstrumentAddedAction(this);
        result.instrument = instrument;
        return result;
    }
    setListener(listener) {
        this.listener = listener;
    }
    execute() {
        this.listener.onAdd(this.instrument);
    }
}
InstrumentsManager.InstrumentsAndLeveragesLoaderCallback = class {
    offerIds;
    callback;
    storage;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(storage, offerIds, callback) {
        let result;
        result = new InstrumentsManager.InstrumentsAndLeveragesLoaderCallback(this);
        result.offerIds = offerIds;
        result.callback = callback;
        result.storage = storage;
        return result;
    }
    onSuccess() {
        this.callback.onSuccess(this.storage.getInstrumentsByOfferIds(this.offerIds));
    }
    onError(error) {
        this.callback.onError(error);
    }
}
InstrumentsManager.InstrumentsLoaderCallback = class {
    callback;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(callback) {
        let result;
        result = new InstrumentsManager.InstrumentsLoaderCallback(this);
        result.callback = callback;
        return result;
    }
    onSuccess(instruments) {
        this.callback.onSuccess(instruments);
    }
}
