'use strict';
let CommonSubscribeInstrumentAction = require('./CommonSubscribeInstrumentAction.js');
let LogManager = require('./LogManager.js');
let TradingSessionProvider = require('./TradingSessionProvider.js');
let StringUtil = require('./StringUtil.js');
let InstrumentDescriptorFinderBySymbol = require('./InstrumentDescriptorFinderBySymbol.js');
let InstrumentDescriptorsTransform = require('./InstrumentDescriptorsTransform.js');
let InstrumentDescriptorFindingResult = require('./InstrumentDescriptorFindingResult.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let InstrumentDescriptorSplitterByPriceStream = require('./InstrumentDescriptorSplitterByPriceStream.js');
let GetProfilesQuery = require('./GetProfilesQuery.js');
let emptyAction = require('./emptyAction.js');
let CompositeSubscriptionRequest = require('./CompositeSubscriptionRequest.js');
let SubscriptionInstrumentRequest = require('./SubscriptionInstrumentRequest.js');
let MessageType = require('./MessageType.js');
let MediatorBeforeCallback = require('./MediatorBeforeCallback.js');
let SubscribeInstrumentMediatorAction = require('./SubscribeInstrumentMediatorAction.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let list = require('@gehtsoft/LuaxStdlib-node').list;
let CollectionUtils = require('./CollectionUtils.js');
let IPriceFeedCommandCallback = require('./IPriceFeedCommandCallback.js');
class SubscribeInstrumentAction extends CommonSubscribeInstrumentAction {
    messageExecutor;
    sessionProvider;
    messageFactory;
    commandFactory;
    messageRouter;
    subscriptionInstrumentCommandFactory;
    instrumentDescriptorsResult;
    instrumentAllDescriptorsResult;
    allCrossSymbolsResult;
    timeOutScheduler;
    logger;
    clientCrossSymbolsProvider;
    getAllInstrumentsCommandRequestNumber;
    cancelled;
    trackNumber;
    checkCrosses;
    leverageProfilesUpdater;
    rolloverProfilesUpdater;
    accountCommissionsUpdater;
    constructor() {
        super();
        this.logger = LogManager.getLogger();
        this.timeOutScheduler = null;
        this.cancelled = false;
        this.leverageProfilesUpdater = null;
        this.rolloverProfilesUpdater = null;
        this.accountCommissionsUpdater = null;
    }
    setRolloverProfilesUpdater(rolloverProfilesUpdater) {
        this.rolloverProfilesUpdater = rolloverProfilesUpdater;
    }
    setAccountCommissionsUpdater(accountCommissionsUpdater) {
        this.accountCommissionsUpdater = accountCommissionsUpdater;
    }
    static create(commandFactory, messageRouter, messageExecutor, sessionStorage, messageFactory, requestNumberGenerator, descriptorsStorage, instrumentsStorage, instrumentDescriptorsSeparator, clientCrossSymbolsProvider, subscriptionInstrumentCommandFactory, subscriptionStatusTracker, instrumentUpdatesStorage, sendInCW, leverageProfilesUpdater) {
        let result;
        result = new SubscribeInstrumentAction();
        result.subscriptionInstrumentCommandFactory = subscriptionInstrumentCommandFactory;
        result.requestNumberGenerator = requestNumberGenerator;
        result.descriptorsStorage = descriptorsStorage;
        result.instrumentUpdatesStorage = instrumentUpdatesStorage;
        result.subscriptionStatusTracker = subscriptionStatusTracker;
        result.instrumentsStorage = instrumentsStorage;
        result.sessionStorage = sessionStorage;
        result.instrumentDescriptorsSeparator = instrumentDescriptorsSeparator;
        result.clientCrossSymbolsProvider = clientCrossSymbolsProvider;
        result.messageExecutor = messageExecutor;
        result.commandFactory = commandFactory;
        result.messageFactory = messageFactory;
        result.messageRouter = messageRouter;
        result.sendInCW = sendInCW;
        result.leverageProfilesUpdater = leverageProfilesUpdater;
        result.sessionProvider = TradingSessionProvider.create(sessionStorage);
        result.checkCrosses = false;
        return result;
    }
    stop() {
        super.stop();
        if (this.timeOutScheduler != null) {
            this.timeOutScheduler.stop();
            this.timeOutScheduler = null;
        }
    }
    setCheckCrosses() {
        this.checkCrosses = true;
    }
    run() {
        let crossSymbols, updateFlag;
        if (this.symbols == null || this.symbols.length == 0) {
            this.callback.onError("Array of symbols is empty", new Array(0));
            return;
        }
        this.logger.info("SubscribeInstrumentAction.run(" + StringUtil.arrayToString(this.symbols) + ")");
        if (this.checkCrosses) {
            this.checkAndLoadCrossCources();
            return;
        }
        crossSymbols = [];
        updateFlag = this.updateInstrumentDescriptorsResult(this.symbols, crossSymbols);
        if (!updateFlag) {
            return;
        }
        this.loadProfiles();
    }
    getSymbols() {
        return this.symbols;
    }
    updateInstrumentDescriptorsResult(_symbols, crossSymbols) {
        let instrumentDescriptorFinderBySymbol, instrumentDescriptorsTransform;
        instrumentDescriptorFinderBySymbol = InstrumentDescriptorFinderBySymbol.create(this.descriptorsStorage);
        instrumentDescriptorsTransform = InstrumentDescriptorsTransform.create(this.descriptorsStorage, this.instrumentDescriptorsSeparator);
        this.instrumentDescriptorsResult = instrumentDescriptorFinderBySymbol.find(_symbols);
        if (this.instrumentDescriptorsResult.getError() != null) {
            this.callback.onError(this.instrumentDescriptorsResult.getError(), _symbols);
            return false;
        }
        this.instrumentAllDescriptorsResult = instrumentDescriptorsTransform.selectPdasInstruments(_symbols);
        if (this.instrumentAllDescriptorsResult.getError() != null) {
            this.callback.onError(this.instrumentAllDescriptorsResult.getError(), _symbols);
            return false;
        }
        if (crossSymbols.length > 0) {
            this.allCrossSymbolsResult = instrumentDescriptorFinderBySymbol.find(crossSymbols);
            if (this.allCrossSymbolsResult.getError() != null) {
                this.callback.onError(this.allCrossSymbolsResult.getError(), _symbols);
                return false;
            }
        }
        else {
            this.allCrossSymbolsResult = InstrumentDescriptorFindingResult.create(new Array(0), "");
        }
        return true;
    }
    loadProfiles() {
        let actionStopRefresh, splitter, groupedResult, offerIds, timeoutAction, queueItem, count;
        timeoutAction = SubscribeInstrumentAction.TimeoutAction.create(this.callback, this.symbols);
        this.timeOutScheduler = scheduler.create(30000, timeoutAction);
        timeoutAction.setScheduler(this.timeOutScheduler);
        this.timeOutScheduler.startWithDelay();
        splitter = new InstrumentDescriptorSplitterByPriceStream();
        groupedResult = splitter.split(this.instrumentDescriptorsResult.getResult());
        offerIds = groupedResult.getAllOffersIds();
        actionStopRefresh = new SubscribeInstrumentAction.ProfilesLoadFinishAction(this);
        actionStopRefresh.setInstruments(this.symbols);
        actionStopRefresh.setCallback(this.callback);
        count = 1;
        if (this.rolloverProfilesUpdater != null) {
            count = count + 1;
        }
        if (this.accountCommissionsUpdater != null) {
            count = count + 1;
        }
        actionStopRefresh.setCount(count);
        queueItem = GetProfilesQuery.create(offerIds, new emptyAction(), actionStopRefresh);
        this.leverageProfilesUpdater.updateLeverageProfiles(queueItem);
        if (this.rolloverProfilesUpdater != null) {
            this.rolloverProfilesUpdater.updateRolloverProfiles(queueItem);
        }
        if (this.accountCommissionsUpdater != null) {
            this.accountCommissionsUpdater.updateAccountCommissions(queueItem);
        }
    }
    subscribeInstrumentsWithCrossCourses(_symbols) {
        let command, subscribeInstrumentDescriptors, splitter, compositeSubscriptionRequest, groupedResult, instrumentDescriptorFinderBySymbol, priceStreams, offerIds, groupedAllResult, i, ex, beforeCallback, priceFeedCommandCallback;
        this.logger.info("SubscribeInstrumentAction.subscribeInstrumentsWithCrossCourses(" + StringUtil.arrayToString(_symbols) + ")");
        splitter = new InstrumentDescriptorSplitterByPriceStream();
        instrumentDescriptorFinderBySymbol = InstrumentDescriptorFinderBySymbol.create(this.descriptorsStorage);
        subscribeInstrumentDescriptors = instrumentDescriptorFinderBySymbol.find(_symbols);
        compositeSubscriptionRequest = CompositeSubscriptionRequest.create();
        groupedResult = splitter.split(this.instrumentDescriptorsResult.getResult());
        groupedAllResult = splitter.split(this.instrumentAllDescriptorsResult.getResult());
        priceStreams = groupedResult.getPriceStreams();
        priceFeedCommandCallback = new SubscribeInstrumentAction.PriceFeedCommandCallback(this);
        for (i = 0; i <= priceStreams.length - 1; i += 1) {
            if (this.sessionStorage.getPriceTerminalInitializerByPriceStreamId(priceStreams[i]) == null) {
                continue;
            }
            offerIds = groupedResult.getOffersIds(priceStreams[i]);
            compositeSubscriptionRequest.addRequest(SubscriptionInstrumentRequest.createPriceFeed(this.requestNumberGenerator.getNextRequestNumber(), MessageType.PriceFeed, offerIds, priceFeedCommandCallback));
        }
        if (this.sendInCW) {
            compositeSubscriptionRequest.addRequest(SubscriptionInstrumentRequest.create(this.requestNumberGenerator.getNextRequestNumber(), MessageType.InstrumentSubscribingStatus, this.transformToOfferIDs(_symbols)));
        }
        this.getInstrumentsForSymbols(compositeSubscriptionRequest, groupedResult.getAllOffersIds());
        if (groupedAllResult.getAllOffersIds().length > 0) {
            compositeSubscriptionRequest.addRequest(SubscriptionInstrumentRequest.create(this.requestNumberGenerator.getNextRequestNumber(), MessageType.GetOffers, groupedAllResult.getAllOffersIds()));
        }
        if (compositeSubscriptionRequest.length() > 0) {
            this.instrumentUpdatesStorage.addSymbols(_symbols);
            beforeCallback = MediatorBeforeCallback.create(_symbols, this.instrumentUpdatesStorage);
            this.trackNumber = this.subscriptionStatusTracker.track(compositeSubscriptionRequest, SubscribeInstrumentMediatorAction.create(this.instrumentsStorage, this.callback, subscribeInstrumentDescriptors.getResult(), this.allCrossSymbolsResult.getResult(), beforeCallback, this.messageRouter, this.sendInCW));
            try {
                for (i = 0; i <= compositeSubscriptionRequest.length() - 1; i += 1) {
                    command = this.subscriptionInstrumentCommandFactory.createCommandByRequest(compositeSubscriptionRequest.getRequest(i));
                    command.execute();
                }
            } catch(exTemp1) {
                ex = stdlib.ensureException(exTemp1);
                this.cancel(ex.getMessage());
            }
        }
        else {
            SubscribeInstrumentMediatorAction.create(this.instrumentsStorage, this.callback, subscribeInstrumentDescriptors.getResult(), this.allCrossSymbolsResult.getResult(), new emptyAction(), this.messageRouter, this.sendInCW).onSuccess();
        }
    }
    getInstrumentsForSymbols(compositeSubscriptionRequest, offerIdsToGetInstruments) {
        if (offerIdsToGetInstruments.length > 0) {
            compositeSubscriptionRequest.addRequest(SubscriptionInstrumentRequest.create(this.requestNumberGenerator.getNextRequestNumber(), MessageType.GetInstruments, offerIdsToGetInstruments));
        }
    }
    checkAndLoadCrossCources() {
        let allCrossSymbolsList, allCrossSymbols, i, descriptor, s;
        allCrossSymbols = this.getAllCrossSymbolsForRequiredInstruments();
        this.logger.info("SubscribeInstrumentAction.checkAndLoadCrossCources(" + StringUtil.arrayToString(allCrossSymbols) + ")");
        if (allCrossSymbols.length > 0) {
            allCrossSymbolsList = new list();
            for (i = 0; i <= allCrossSymbols.length - 1; i += 1) {
                s = allCrossSymbols[i];
                descriptor = this.descriptorsStorage.getInstrumentDescriptorBySymbol(s);
                if (descriptor != null && descriptor.getSubscriptionStatus() == "D") {
                    CollectionUtils.addStringToList(allCrossSymbolsList, s);
                }
            }
            allCrossSymbols = CollectionUtils.stringListToArray(allCrossSymbolsList);
            if (allCrossSymbols.length > 0) {
                if (this.updateInstrumentDescriptorsResult(allCrossSymbols, allCrossSymbols)) {
                    this.subscribeInstrumentsWithCrossCourses(new Array(0));
                }
                return;
            }
        }
        this.callback.onSuccess();
    }
    getAllCrossSymbolsForRequiredInstruments() {
        let allCrossSymbolsList, allCrossSymbols, i, j, found;
        allCrossSymbolsList = new list();
        for (i = 0; i <= this.symbols.length - 1; i += 1) {
            allCrossSymbols = this.clientCrossSymbolsProvider.findNotLoadedCrossSymbols(this.symbols[i]);
            for (j = 0; j <= allCrossSymbols.length - 1; j += 1) {
                found = CollectionUtils.containsStringInList(allCrossSymbolsList, allCrossSymbols[j]);
                if (!found) {
                    CollectionUtils.addStringToList(allCrossSymbolsList, allCrossSymbols[j]);
                }
            }
        }
        return CollectionUtils.stringListToArray(allCrossSymbolsList);
    }
    cancel(error) {
        if (!this.cancelled) {
            this.cancelled = true;
            this.instrumentUpdatesStorage.removeSymbols(this.symbols);
            this.subscriptionStatusTracker.cancel(this.trackNumber);
            this.callback.onError(error, this.symbols);
        }
    }
    getAllCrossSymbols(allCrossSymbolsList, instruments) {
        let allCrossSymbols, found, i, j;
        for (i = 0; i <= instruments.length - 1; i += 1) {
            allCrossSymbols = this.clientCrossSymbolsProvider.findNotLoadedCrossSymbols(instruments[i]);
            for (j = 0; j <= allCrossSymbols.length - 1; j += 1) {
                found = CollectionUtils.containsStringInList(allCrossSymbolsList, allCrossSymbols[j]);
                if (!found) {
                    CollectionUtils.addStringToList(allCrossSymbolsList, allCrossSymbols[j]);
                }
            }
        }
        return CollectionUtils.stringListToArray(allCrossSymbolsList);
    }
    transformToOfferIDs(_symbols) {
        let i, j, descriptor, offerIDs;
        offerIDs = new Array(_symbols.length);
        j = 0;
        for (i = 0; i <= _symbols.length - 1; i += 1) {
            descriptor = this.descriptorsStorage.getInstrumentDescriptorBySymbol(_symbols[i]);
            offerIDs[j] = descriptor.getOfferId();
            j = j + 1;
        }
        return offerIDs;
    }
}
module.exports = SubscribeInstrumentAction
SubscribeInstrumentAction.ProfilesLoadFinishAction = class {
    instruments;
    callback;
    count;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setCallback(callback) {
        this.callback = callback;
    }
    setInstruments(instruments) {
        this.instruments = instruments;
    }
    setCount(count) {
        this.count = count;
    }
    invoke() {
        let allSymbolsForSubscription, allCrossSymbols, allCrossSymbolsList, i, symbols;
        this.count = this.count - 1;
        if (this.count == 0) {
            symbols = this._owner_.getSymbols();
            allCrossSymbolsList = new list();
            allCrossSymbols = this._owner_.getAllCrossSymbols(allCrossSymbolsList, this.instruments);
            for (i = 0; i <= symbols.length - 1; i += 1) {
                CollectionUtils.addStringToList(allCrossSymbolsList, symbols[i]);
            }
            if (this._owner_.timeOutScheduler != null) {
                this._owner_.timeOutScheduler.stop();
                this._owner_.timeOutScheduler = null;
            }
            allSymbolsForSubscription = CollectionUtils.stringListToArray(allCrossSymbolsList);
            if (this._owner_.updateInstrumentDescriptorsResult(allSymbolsForSubscription, allCrossSymbols)) {
                this._owner_.subscribeInstrumentsWithCrossCourses(symbols);
            }
        }
    }
    invokeWithError(error) {
        this.count = 0;
        if (this._owner_.timeOutScheduler != null) {
            this._owner_.timeOutScheduler.stop();
            this._owner_.timeOutScheduler = null;
        }
        this.callback.onError(error, this._owner_.getSymbols());
    }
}
SubscribeInstrumentAction.PriceFeedCommandCallback = class extends IPriceFeedCommandCallback {
    _owner_;
    constructor(_owner_) {
        super();
        this._owner_ = _owner_;
    }
    onError(error) {
        this._owner_.cancel(error);
    }
}
SubscribeInstrumentAction.TimeoutAction = class {
    callback;
    schedulerObj;
    symbols;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(callback, symbols) {
        let result;
        result = new SubscribeInstrumentAction.TimeoutAction(this);
        result.callback = callback;
        result.symbols = symbols;
        return result;
    }
    setScheduler(schedulerObj) {
        this.schedulerObj = schedulerObj;
    }
    invoke() {
        this.schedulerObj.stop();
        this.callback.onError("Load instruments timeout error", this.symbols);
    }
}
