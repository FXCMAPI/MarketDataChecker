'use strict';
let AFxmsgReader = require('./AFxmsgReader.js');
let LogManager = require('./LogManager.js');
let csvParser = require('@gehtsoft/LuaxStdlib-node').csvParser;
let PriceHistoryCsvParser = require('./PriceHistoryCsvParser.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let Timeframe = require('./Timeframe.js');
let TimeframeUnit = require('./TimeframeUnit.js');
let GetPriceHistoryMessageBuilder = require('./GetPriceHistoryMessageBuilder.js');
let PdasMessageFieldTag = require('./PdasMessageFieldTag.js');
let PdasMessageType = require('./PdasMessageType.js');
let variantCast = require('@gehtsoft/LuaxStdlib-node').variantCast;
let PriceHistoryList = require('./PriceHistoryList.js');
class GetPriceHistoryFxmsgReader extends AFxmsgReader {
    linesParser;
    priceHistoryCsvParser;
    timeframes;
    constructor() {
        let loggerInstance, ex;
        super();
        loggerInstance = LogManager.getLogger();
        this.linesParser = new csvParser();
        this.linesParser.valueSeparator = "\n";
        this.priceHistoryCsvParser = new PriceHistoryCsvParser();
        try {
            this.timeframes = [Timeframe.create(TimeframeUnit.Tick, 1), Timeframe.create(TimeframeUnit.Minute, 1), Timeframe.create(TimeframeUnit.Minute, 5), Timeframe.create(TimeframeUnit.Minute, 15), Timeframe.create(TimeframeUnit.Minute, 30), Timeframe.create(TimeframeUnit.Hour, 1), Timeframe.create(TimeframeUnit.Day, 1), Timeframe.create(TimeframeUnit.Week, 1), Timeframe.create(TimeframeUnit.Month, 1), Timeframe.create(TimeframeUnit.Year, 1)];
        } catch(exTemp1) {
            ex = stdlib.ensureException(exTemp1);
            loggerInstance.error("FXConnectLiteSession initialization: " + ex.getMessage());
        }
    }
    read(responseList, xmlRootNode, messages) {
        let data, symbol, i, messageBuilder, tags, stream, intervalString, timeframeString, requestId, timeframe;
        if (messages == null || messages.length == 0) {
            return;
        }
        for (i = 0; i <= messages.length - 1; i += 1) {
            if (messages[i].getType() == PdasMessageType.FXCM_RESPONSE && messages[i].getFieldValue(PdasMessageFieldTag.REF_MSG_TYPE) == PdasMessageType.PRICE_HISTORY_MESSAGE) {
                messageBuilder = new GetPriceHistoryMessageBuilder();
                tags = messages[i].getList(PdasMessageFieldTag.FXCM_NO_PARAM);
                symbol = tags.getGroupParamValueByParamName(PdasMessageFieldTag.SYMBOL);
                data = tags.getGroupParamValueByParamName("DAS");
                stream = tags.getGroupParamValueByParamName(PdasMessageFieldTag.FXCM_DAS_MESSAGE_PRICE_STREAM);
                intervalString = tags.getGroupParamValueByParamName(PdasMessageFieldTag.FXCM_TIMING_INTERVAL);
                timeframeString = tags.getGroupParamValueByParamName(PdasMessageFieldTag.TIMEFRAME);
                requestId = messages[i].getFieldValue(PdasMessageFieldTag.FXCM_COMMAND_ID);
                if (data != null && symbol != null && requestId != null && stream != null && intervalString != null) {
                    messageBuilder.addPriceHistoryList(this.parsePriceHistory(data));
                    messageBuilder.setSymbol(symbol);
                    messageBuilder.setRequestId(requestId);
                    messageBuilder.setStream(stream);
                    timeframe = this.parseTimeframe(timeframeString);
                    if (timeframe == null) {
                        timeframe = this.parseInterval(intervalString);
                    }
                    messageBuilder.setTimeframe(timeframe);
                    responseList.add(this.createLockedMessage(messageBuilder.build()));
                }
            } else if (messages[i].getType() == PdasMessageType.MARKET_DATA_REQUEST_REJECT) {
                messageBuilder = new GetPriceHistoryMessageBuilder();
                requestId = messages[i].getFieldValue(PdasMessageFieldTag.MD_REQ_ID);
                messageBuilder.setError(messages[i].getFieldValue(PdasMessageFieldTag.FLD_TEXT));
                messageBuilder.setRequestId(requestId);
                responseList.add(this.createLockedMessage(messageBuilder.build()));
            }
        }
    }
    parseInterval(intervalString) {
        let index;
        index = variantCast.castToInt(variantCast.fromString(intervalString));
        return this.timeframes[index];
    }
    parseTimeframe(timeframeString) {
        let unit;
        if (timeframeString != null && stdlib.len(timeframeString) > 1) {
            unit = TimeframeUnit.fromString(stdlib.substring(timeframeString, 0, 1));
            if (unit > -1) {
                return Timeframe.create(unit, variantCast.fromString(stdlib.substring(timeframeString, 1, stdlib.len(timeframeString) - 1)).asInt());
            }
        }
        return null;
    }
    parsePriceHistory(data) {
        let lines, i, priceHistoryList, priceHistory;
        priceHistoryList = new PriceHistoryList();
        lines = this.linesParser.splitLine(data);
        for (i = 0; i <= lines.length - 1; i += 1) {
            priceHistory = this.priceHistoryCsvParser.parse(lines[i]);
            if (priceHistory != null) {
                priceHistoryList.add(priceHistory);
            }
        }
        return priceHistoryList;
    }
}
module.exports = GetPriceHistoryFxmsgReader
