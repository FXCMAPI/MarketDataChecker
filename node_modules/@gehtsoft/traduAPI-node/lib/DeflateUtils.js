'use strict';
let buffer = require('@gehtsoft/LuaxStdlib-node').buffer;
let io = require('@gehtsoft/LuaxStdlib-node').io;
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let cryptography = require('@gehtsoft/LuaxStdlib-node').cryptography;
class DeflateUtils {
    static extractPossibleBase64DeflatedText(textSource) {
        let text, index, textBuffer, v, bufLength, tagLength;
        text = textSource;
        tagLength = buffer.getEncodedStringLength("<BASE64-DATA>", io.CP_ANSI);
        if (tagLength < stdlib.len(text)) {
            index = stdlib.indexOf(text, "<BASE64-DATA>", false);
            if (index >= 0) {
                text = stdlib.substring(text, index + 13, stdlib.len(text) - index - 13);
                index = stdlib.indexOf(text, "</BASE64-DATA>", false);
                text = stdlib.substring(text, 0, index);
                textBuffer = buffer.fromBase64(text);
                text = textBuffer.getEncodedString(0, textBuffer.length(), io.CP_ANSI);
                tagLength = buffer.getEncodedStringLength("<DEFLATE-DATA>", io.CP_ANSI);
                if (tagLength < textBuffer.length() && stdlib.indexOf(text, "<DEFLATE-DATA>", false) == 0) {
                    bufLength = textBuffer.length() - tagLength - buffer.getEncodedStringLength("</DEFLATE-DATA>", io.CP_ANSI);
                    v = buffer.create(bufLength);
                    v.setBuffer(0, textBuffer, tagLength, bufLength);
                    textBuffer = cryptography.DEFLATE(v, false);
                }
                text = textBuffer.getEncodedString(0, textBuffer.length(), io.CP_ANSI);
            }
        }
        return text;
    }
    static createDeflatedBase64Text(sourceText) {
        const header = "<DEFLATE-DATA>";
        const footer = "</DEFLATE-DATA>";
        let headerEncodedStringLength, footerEncodedStringLength, sourceTextEncodedStringLength, deflateBuf, resultBuf;
        if (sourceText == null || stdlib.len(sourceText) == 0) {
            return "";
        }
        headerEncodedStringLength = buffer.getEncodedStringLength(header, io.CP_ANSI);
        footerEncodedStringLength = buffer.getEncodedStringLength(footer, io.CP_ANSI);
        sourceTextEncodedStringLength = buffer.getEncodedStringLength(sourceText, io.CP_ANSI);
        deflateBuf = buffer.create(sourceTextEncodedStringLength);
        deflateBuf.setEncodedString(0, sourceText, io.CP_ANSI);
        deflateBuf = cryptography.DEFLATE(deflateBuf, true);
        resultBuf = buffer.create(deflateBuf.length() + headerEncodedStringLength + footerEncodedStringLength);
        resultBuf.setEncodedString(0, header, io.CP_ANSI);
        resultBuf.setBuffer(headerEncodedStringLength, deflateBuf, 0, deflateBuf.length());
        resultBuf.setEncodedString(deflateBuf.length() + headerEncodedStringLength, footer, io.CP_ANSI);
        return "<BASE64-DATA>" + resultBuf.toBase64() + "</BASE64-DATA>";
    }
}
module.exports = DeflateUtils
