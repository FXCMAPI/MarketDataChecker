'use strict';
let LogManager = require('./LogManager.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let Session = require('./Session.js');
let MessageType = require('./MessageType.js');
//@@DocBrief("The class for perform login operation to authenticate to price terminal")
class GetPriceSessionCommandExecutor {
    static get DEFAULT_PERIOD() { return 300; }
    static get DEFAULT_TIMEOUT() { return 120; }
    commandEnvironment;
    getPriceSessionCommand;
    timeoutScheduler;
    logger;
    timeoutConnectionCallback;
    mPriceSessionCommandExecutor;
    pdasPriceSessionProvider;
    tempPriceSessionIdProvider;
    login;
    commandFactory;
    priceTerminal;
    constructor() {
        this.logger = LogManager.getLogger();
        this.timeoutScheduler = null;
        this.mPriceSessionCommandExecutor = null;
        this.getPriceSessionCommand = null;
        this.commandFactory = null;
        this.commandEnvironment = null;
    }
    static create(commandEnvironment, commandFactory, login, tempPriceSessionIdProvider, pdasPriceSessionProvider, priceTerminal) {
        let getPriceSessionCommandExecutor;
        getPriceSessionCommandExecutor = new GetPriceSessionCommandExecutor();
        getPriceSessionCommandExecutor.login = login;
        getPriceSessionCommandExecutor.commandEnvironment = commandEnvironment;
        getPriceSessionCommandExecutor.commandFactory = commandFactory;
        getPriceSessionCommandExecutor.tempPriceSessionIdProvider = tempPriceSessionIdProvider;
        getPriceSessionCommandExecutor.pdasPriceSessionProvider = pdasPriceSessionProvider;
        getPriceSessionCommandExecutor.priceTerminal = priceTerminal;
        getPriceSessionCommandExecutor.initScheduler();
        return getPriceSessionCommandExecutor;
    }
    initScheduler() {
        this.timeoutConnectionCallback = new GetPriceSessionCommandExecutor.TimeoutConnectionCallback(this);
        this.timeoutScheduler = scheduler.create(this.commandEnvironment.getConnectionParameters().getLoginTimeoutInSeconds() * 1000, this.timeoutConnectionCallback);
    }
    setSuccessor(priceSessionCommandExecutor) {
        this.mPriceSessionCommandExecutor = priceSessionCommandExecutor;
    }
    execute(pdasPriceTerminalControllerCallback) {
        let priceSessionCommandListener;
        this.logger.debug("request price session");
        this.timeoutConnectionCallback.setCallback(pdasPriceTerminalControllerCallback);
        this.getPriceSessionCommand = this.commandFactory.createGetPriceSessionCommand(this.commandEnvironment, this.login, this.tempPriceSessionIdProvider.getSessionId(), GetPriceSessionCommandExecutor.DEFAULT_PERIOD, GetPriceSessionCommandExecutor.DEFAULT_TIMEOUT, this.priceTerminal);
        this.timeoutScheduler.startWithDelay();
        priceSessionCommandListener = new GetPriceSessionCommandExecutor.PriceSessionCommandListener(this);
        priceSessionCommandListener.setTerminal(this.commandEnvironment.getTradingTerminal());
        priceSessionCommandListener.setCallback(pdasPriceTerminalControllerCallback);
        priceSessionCommandListener.setNextExecutor(this.mPriceSessionCommandExecutor);
        this.getPriceSessionCommand.subscribeStatusChange(priceSessionCommandListener);
        this.getPriceSessionCommand.execute();
    }
    stop() {
        this.timeoutScheduler.stop();
    }
}
module.exports = GetPriceSessionCommandExecutor
GetPriceSessionCommandExecutor.TimeoutConnectionCallback = class {
    pdasPriceTerminalControllerCallback;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setCallback(pdasPriceTerminalControllerCallback) {
        this.pdasPriceTerminalControllerCallback = pdasPriceTerminalControllerCallback;
    }
    invoke() {
        this._owner_.timeoutScheduler.stop();
        this.pdasPriceTerminalControllerCallback.onError("Timeout");
    }
}
GetPriceSessionCommandExecutor.PriceSessionCommandListener = class {
    tradingTerminal;
    pdasPriceTerminalControllerCallback;
    nextExecutor;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setTerminal(tradingTerminal) {
        this.tradingTerminal = tradingTerminal;
    }
    setNextExecutor(nextExecutor) {
        this.nextExecutor = nextExecutor;
    }
    setCallback(pdasPriceTerminalControllerCallback) {
        this.pdasPriceTerminalControllerCallback = pdasPriceTerminalControllerCallback;
    }
    onSuccess(message) {
        let getPriceSessionMessage, priceSession;
        this._owner_.timeoutScheduler.stop();
        this._owner_.getPriceSessionCommand.unsubscribeStatusChange(this);
        if (message != null && message.getType() == MessageType.GetPriceSession) {
            getPriceSessionMessage = message;
            priceSession = getPriceSessionMessage.getPersistentSession();
            this._owner_.logger.debug("price session received. session: " + priceSession);
            this._owner_.pdasPriceSessionProvider.setSession(Session.create(priceSession, getPriceSessionMessage.getUserId(), this.tradingTerminal, getPriceSessionMessage.getOptions()));
            this.nextExecutor.execute(this.pdasPriceTerminalControllerCallback);
        }
        else {
            this.pdasPriceTerminalControllerCallback.onError("The message in 'Terminal CommandStatusListener' is invalid or has an unexpected type");
        }
    }
    onError(error) {
        this._owner_.getPriceSessionCommand.unsubscribeStatusChange(this);
        this._owner_.timeoutScheduler.stop();
        this.pdasPriceTerminalControllerCallback.onError("Get price session: " + error);
    }
    onCancel() {
        this._owner_.timeoutScheduler.stop();
        this._owner_.getPriceSessionCommand.unsubscribeStatusChange(this);
        this.pdasPriceTerminalControllerCallback.onError("Cancel");
    }
}
