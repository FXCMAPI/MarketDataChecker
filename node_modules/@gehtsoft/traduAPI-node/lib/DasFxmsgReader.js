'use strict';
let AFxmsgReader = require('./AFxmsgReader.js');
let csvParser = require('@gehtsoft/LuaxStdlib-node').csvParser;
let DasUpdateMessageBuilder = require('./DasUpdateMessageBuilder.js');
let PdasMessageFieldTag = require('./PdasMessageFieldTag.js');
let PdasMessageType = require('./PdasMessageType.js');
let PdasRequestCommand = require('./PdasRequestCommand.js');
let list = require('@gehtsoft/LuaxStdlib-node').list;
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let CollectionUtils = require('./CollectionUtils.js');
class DasFxmsgReader extends AFxmsgReader {
    linesParser;
    dasUpdateMessageBuilder;
    constructor() {
        super();
        this.linesParser = new csvParser();
        this.linesParser.valueSeparator = "\n";
        this.dasUpdateMessageBuilder = new DasUpdateMessageBuilder();
    }
    read(responseList, xmlRootNode, messages) {
        let data, i;
        if (messages == null || messages.length == 0) {
            return;
        }
        for (i = 0; i <= messages.length - 1; i += 1) {
            if (messages[i].getType() == PdasMessageType.DAS_MESSAGE && messages[i].getFieldValue(PdasMessageFieldTag.FXCM_COMMAND_ID) == PdasRequestCommand.DAS && messages[i].getFieldValue(PdasMessageFieldTag.MSG_TYPE) == PdasMessageType.DAS_MESSAGE) {
                data = messages[i].getFieldValue(PdasMessageFieldTag.FLD_TEXT);
                if (data != null) {
                    this.parseMessage(responseList, data);
                }
            }
        }
    }
    parseMessage(responseList, data) {
        let lines, i, separatedData, message;
        lines = this.collectLines(data);
        for (i = 0; i <= lines.length - 1; i += 1) {
            separatedData = this.separateData(lines[i]);
            if (separatedData[0] == null) {
                continue;
            }
            if (this.dasUpdateMessageBuilder.isSupportType(separatedData[0])) {
                message = this.createLockedMessage(this.dasUpdateMessageBuilder.create(separatedData[0], separatedData[1], separatedData[2]));
                if (message != null) {
                    responseList.add(message);
                }
            }
        }
    }
    collectLines(data) {
        let lines, line, result, i, separatedData;
        result = new list();
        line = null;
        lines = this.linesParser.splitLine(data);
        for (i = 0; i <= lines.length - 1; i += 1) {
            separatedData = this.separateData(lines[i]);
            if (separatedData[0] == null) {
                continue;
            }
            if (line != null && stdlib.substring(line, 0, 4) == "MAIL" && !this.dasUpdateMessageBuilder.isSupportType(separatedData[0])) {
                line = line + "\n" + lines[i];
                continue;
            }
            if (line != null) {
                CollectionUtils.addStringToList(result, line);
            }
            line = lines[i];
        }
        if (line != null) {
            CollectionUtils.addStringToList(result, line);
        }
        return CollectionUtils.stringListToArray(result);
    }
    separateData(data) {
        let separatedData, separator, indexS, indexE, dataLength;
        separatedData = new Array(3);
        separator = stdlib.unicode(";", 0);
        dataLength = stdlib.len(data);
        if (dataLength > 0) {
            indexS = stdlib.charIndex(data, separator, 0, false);
            if (indexS != -1) {
                indexE = stdlib.charIndex(data, separator, indexS + 1, false);
                if (indexE != -1) {
                    separatedData[0] = stdlib.substring(data, 0, indexS);
                    indexS = indexS + 1;
                    separatedData[1] = stdlib.substring(data, indexS, indexE - indexS);
                    indexE = indexE + 1;
                    separatedData[2] = stdlib.substring(data, indexE, dataLength - indexE);
                }
            }
        }
        return separatedData;
    }
}
module.exports = DasFxmsgReader
