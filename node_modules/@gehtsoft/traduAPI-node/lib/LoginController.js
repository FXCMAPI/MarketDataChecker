'use strict';
let LoginParametersChecker = require('./LoginParametersChecker.js');
let LogManager = require('./LogManager.js');
let ExecutionTimeEventBuilder = require('./ExecutionTimeEventBuilder.js');
let ExecutionTimeEventName = require('./ExecutionTimeEventName.js');
let TradingSessionProvider = require('./TradingSessionProvider.js');
let MessageType = require('./MessageType.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let LoginError = require('./LoginError.js');
let ConnectionStatus = require('./ConnectionStatus.js');
let HostsReceiver = require('./HostsReceiver.js');
let PasswordSaltGenerator = require('./PasswordSaltGenerator.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let buffer = require('@gehtsoft/LuaxStdlib-node').buffer;
let io = require('@gehtsoft/LuaxStdlib-node').io;
let cryptography = require('@gehtsoft/LuaxStdlib-node').cryptography;
let DisconnectedMessageBuilder = require('./DisconnectedMessageBuilder.js');
let EventManager = require('./EventManager.js');
let ReconnectingMessageBuilder = require('./ReconnectingMessageBuilder.js');
let Session = require('./Session.js');
let TradingSessionReceivedMessageBuilder = require('./TradingSessionReceivedMessageBuilder.js');
let ConnectedMessageBuilder = require('./ConnectedMessageBuilder.js');
//@@DocBrief("The class for checking the current connection status of the session")
class LoginController {
    static get INCORRECT_CREDENTIALS_ERROR() { return "Incorrect user name or password"; }
    static get INCORRECT_CONNECTION_ERROR() { return "Incorrect connection"; }
    static get CONNECTION_TIMEOUT_ERROR() { return "Connection timeout"; }
    timeoutScheduler;
    reconnectionScheduler;
    loginParametersChecker;
    timeoutCallback;
    connectionParameters;
    terminalCommandStatusListener;
    temporarySessionCommandListener;
    tradingSessionCommandListener;
    tradingTerminalsCommand;
    getTemporarySessionCommand;
    getTradingSessionCommand;
    loginMultiPriceTerminalsCommand;
    connectionStatusManager;
    loginCallback;
    communicator;
    commandFactory;
    messageFactory;
    requestNumberGenerator;
    messageExecutor;
    messageRouter;
    tradingTerminalSelector;
    sessionStorage;
    tradingTerminalCurrent;
    loginCurrent;
    passwordCurrent;
    ssoTokenCurrent;
    ssoProviderCurrent;
    totalReconnectAttempts;
    receiveNewMessageListener;
    tradingSessionProvider;
    logger;
    commandEnvironment;
    ssoTokenController;
    aliveControllerFactory;
    rakeOutControllerFactory;
    instrumentsProvider;
    dxfeedConnectionFactory;
    systemSettingsProvider;
    allowReconnecting;
    fullLoginExecutionTimeEvent;
    getTradingSessionExecutionTimeEvent;
    configFlags;
    rawOffersStorage;
    testRequestControllerFactory;
    getTerminalsLoginExecutionTimeEvent;
    constructor() {
        this.timeoutCallback = new LoginController.TimeoutConnectionCallback(this);
        this.loginParametersChecker = new LoginParametersChecker();
        this.tradingTerminalSelector = new LoginController.TradingTerminalSelector(this);
        this.sessionStorage = null;
        this.tradingSessionProvider = null;
        this.commandEnvironment = null;
        this.ssoTokenController = null;
        this.loginMultiPriceTerminalsCommand = null;
        this.getTradingSessionCommand = null;
        this.getTemporarySessionCommand = null;
        this.tradingTerminalsCommand = null;
        this.aliveControllerFactory = null;
        this.rakeOutControllerFactory = null;
        this.getTradingSessionExecutionTimeEvent = null;
        this.getTerminalsLoginExecutionTimeEvent = null;
        this.totalReconnectAttempts = 0;
        this.passwordCurrent = "";
        this.ssoTokenCurrent = "";
        this.ssoProviderCurrent = "";
        this.logger = LogManager.getLogger();
        this.allowReconnecting = false;
        this.fullLoginExecutionTimeEvent = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.FullLoginTime);
        this.configFlags = [];
        this.rawOffersStorage = null;
    }
    static create(commandEnvironment, commandFactory, communicator, connectionStatusManager, sessionStorage, ssoTokenController, aliveControllerFactory, rakeOutControllerFactory, instrumentsProvider, dxfeedConnectionFactory, systemSettingsProvider, testRequestControllerFactory) {
        let loginController;
        loginController = new LoginController();
        loginController.setConnectionParameters(commandEnvironment.getConnectionParameters());
        loginController.setConnectionStatusManager(connectionStatusManager);
        loginController.setHttpCommunicator(communicator);
        loginController.commandFactory = commandFactory;
        loginController.messageFactory = commandEnvironment.getMessageFactory();
        loginController.requestNumberGenerator = commandEnvironment.getRequestNumberGenerator();
        loginController.messageExecutor = commandEnvironment.getMessageExecutor();
        loginController.messageRouter = commandEnvironment.getMessageRouter();
        loginController.sessionStorage = sessionStorage;
        loginController.commandEnvironment = commandEnvironment;
        loginController.createReceiveNewMessageListener();
        loginController.tradingSessionProvider = TradingSessionProvider.create(sessionStorage);
        loginController.ssoTokenController = ssoTokenController;
        loginController.aliveControllerFactory = aliveControllerFactory;
        loginController.rakeOutControllerFactory = rakeOutControllerFactory;
        loginController.instrumentsProvider = instrumentsProvider;
        loginController.dxfeedConnectionFactory = dxfeedConnectionFactory;
        loginController.systemSettingsProvider = systemSettingsProvider;
        loginController.testRequestControllerFactory = testRequestControllerFactory;
        commandEnvironment.getMessageRouter().subscribeNewMessageReceive(MessageType.Reconnecting, loginController.receiveNewMessageListener);
        loginController.init();
        return loginController;
    }
    setConfigFlags(configFlags) {
        this.configFlags = configFlags;
    }
    setRawOffersStorage(rawOffersStorage) {
        this.rawOffersStorage = rawOffersStorage;
    }
    init() {
        this.timeoutScheduler = scheduler.create(this.connectionParameters.getLoginTimeoutInSeconds() * 1000, this.timeoutCallback);
        this.reconnectionScheduler = scheduler.create(this.connectionParameters.getReconnectionDelayInSeconds() * 1000, new LoginController.ReconnectionCallback(this));
    }
    setConnectionParameters(connectionParameters) {
        this.connectionParameters = connectionParameters;
    }
    setConnectionStatusManager(connectionStatusManager) {
        this.connectionStatusManager = connectionStatusManager;
    }
    setHttpCommunicator(communicator) {
        this.communicator = communicator;
    }
    login(user, password, tradingSystemUrl, connection, loginCallback) {
        let checkResult;
        this.logger.info("start login by username/password. user: '" + user + "' url: '" + tradingSystemUrl + "' connection: '" + connection + "'");
        this.fullLoginExecutionTimeEvent.start();
        checkResult = this.loginParametersChecker.check(user, password, tradingSystemUrl, connection, loginCallback, false);
        this.loginCallback = loginCallback;
        if (checkResult.isCheckPassed()) {
            this.allowReconnecting = true;
            this.loginCurrent = user;
            this.passwordCurrent = password;
            this.ssoTokenCurrent = "";
            this.ssoProviderCurrent = "";
            this.sendCommandForTerminals(tradingSystemUrl, connection, loginCallback);
        }
        else {
            this.logger.warning("credentials not valid. code: " + (checkResult.getCode()).toString() + " error: " + checkResult.getError());
            loginCallback.onLoginError(LoginError.create(checkResult.getCode(), checkResult.getError()));
            this.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
        }
    }
    loginBySsoToken(user, ssoToken, tradingSystemUrl, connection, loginCallback) {
        let checkResult;
        this.logger.info("start login by username/sso. user: '" + user + "' url: '" + tradingSystemUrl + "' connection: '" + connection + "'");
        this.fullLoginExecutionTimeEvent.setName("FullSSOLoginTime");
        this.fullLoginExecutionTimeEvent.start();
        checkResult = this.loginParametersChecker.check(user, ssoToken, tradingSystemUrl, connection, loginCallback, true);
        this.loginCallback = loginCallback;
        if (checkResult.isCheckPassed()) {
            this.allowReconnecting = false;
            this.loginCurrent = user;
            this.ssoTokenCurrent = ssoToken;
            this.ssoProviderCurrent = "";
            this.sendCommandForTerminals(tradingSystemUrl, connection, loginCallback);
        }
        else {
            this.logger.warning("credentials not valid. code: " + (checkResult.getCode()).toString() + " error: " + checkResult.getError());
            loginCallback.onLoginError(LoginError.create(checkResult.getCode(), checkResult.getError()));
            this.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
        }
    }
    loginByExternalSsoToken(ssoToken, tradingSystemUrl, connection, loginCallback) {
        let checkResult;
        this.logger.info("start login by external sso: '" + ssoToken + "' url: '" + tradingSystemUrl + "' connection: '" + connection + "'");
        this.fullLoginExecutionTimeEvent.setName("FullExternalSSOLoginTime");
        this.fullLoginExecutionTimeEvent.start();
        checkResult = this.loginParametersChecker.check("external_provider", ssoToken, tradingSystemUrl, connection, loginCallback, true);
        this.loginCallback = loginCallback;
        if (checkResult.isCheckPassed()) {
            this.allowReconnecting = false;
            this.loginCurrent = "";
            this.ssoTokenCurrent = ssoToken;
            this.ssoProviderCurrent = "okta";
            this.sendCommandForTerminals(tradingSystemUrl, connection, loginCallback);
        }
        else {
            this.logger.warning("credentials not valid. code: " + (checkResult.getCode()).toString() + " error: " + checkResult.getError());
            loginCallback.onLoginError(LoginError.create(checkResult.getCode(), checkResult.getError()));
            this.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
        }
    }
    sendCommandForTerminals(tradingSystemUrl, connection, loginCallback) {
        let hostsReceiver;
        this.logger.debug("request trading terminals");
        this.getTerminalsLoginExecutionTimeEvent = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.GetTerminalsLoginTime);
        this.getTerminalsLoginExecutionTimeEvent.start();
        this.timeoutScheduler.startWithDelay();
        hostsReceiver = HostsReceiver.create(this.communicator, this.connectionParameters.getApplicationName());
        this.tradingTerminalsCommand = this.commandFactory.createGetTradingTerminalsCommand(this.loginCurrent, tradingSystemUrl, connection, hostsReceiver, this.ssoTokenCurrent, this.ssoProviderCurrent);
        this.terminalCommandStatusListener = new LoginController.TerminalCommandStatusListener(this);
        this.tradingTerminalsCommand.subscribeStatusChange(this.terminalCommandStatusListener);
        this.tradingTerminalsCommand.execute();
    }
    sendCommandForTemporarySession(tradingTerminal) {
        let saltedPassword, saltGenerator, length, b;
        this.logger.debug("request temporary trading session");
        this.getTradingSessionExecutionTimeEvent = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.TradingTerminalLoginTime);
        this.getTradingSessionExecutionTimeEvent.start();
        this.timeoutScheduler.startWithDelay();
        saltGenerator = new PasswordSaltGenerator();
        if (tradingTerminal.getSalt() != null && stdlib.len(tradingTerminal.getSalt()) > 0) {
            saltedPassword = saltGenerator.generate(this.passwordCurrent, tradingTerminal.getSalt());
        }
        else {
            length = buffer.getEncodedStringLength(this.passwordCurrent, io.CP_ANSI);
            b = buffer.create(length);
            b.setEncodedString(0, this.passwordCurrent, io.CP_ANSI);
            b = cryptography.SHA1(b);
            saltedPassword = b.toHexString();
        }
        this.commandEnvironment.setTradingTerminal(tradingTerminal);
        this.getTemporarySessionCommand = this.commandFactory.createGetTemporarySessionCommand(this.commandEnvironment.build(), saltedPassword, this.loginCurrent);
        this.temporarySessionCommandListener = new LoginController.TemporarySessionCommandListener(this);
        this.temporarySessionCommandListener.setTerminal(tradingTerminal);
        this.getTemporarySessionCommand.subscribeStatusChange(this.temporarySessionCommandListener);
        this.getTemporarySessionCommand.execute();
    }
    sendCommandForTemporarySessionBySsoToken(tradingTerminal) {
        this.logger.debug("request temporary trading session");
        this.getTradingSessionExecutionTimeEvent = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.TradingTerminalLoginTime);
        this.getTradingSessionExecutionTimeEvent.start();
        this.timeoutScheduler.startWithDelay();
        this.commandEnvironment.setTradingTerminal(tradingTerminal);
        this.getTemporarySessionCommand = this.commandFactory.createGetTemporarySessionBySsoTokenCommand(this.commandEnvironment.build(), this.ssoTokenCurrent, this.loginCurrent);
        this.temporarySessionCommandListener = new LoginController.TemporarySessionCommandListener(this);
        this.temporarySessionCommandListener.setTerminal(tradingTerminal);
        this.getTemporarySessionCommand.subscribeStatusChange(this.temporarySessionCommandListener);
        this.getTemporarySessionCommand.execute();
    }
    sendCommandForTemporarySessionByExternalSsoToken(tradingTerminal) {
        this.logger.debug("request temporary trading session");
        this.getTradingSessionExecutionTimeEvent = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.TradingTerminalLoginTime);
        this.getTradingSessionExecutionTimeEvent.start();
        this.timeoutScheduler.startWithDelay();
        this.commandEnvironment.setTradingTerminal(tradingTerminal);
        this.getTemporarySessionCommand = this.commandFactory.createGetTemporarySessionByExternalSsoTokenCommand(this.commandEnvironment.build(), this.ssoTokenCurrent, this.ssoProviderCurrent);
        this.temporarySessionCommandListener = new LoginController.TemporarySessionCommandListener(this);
        this.temporarySessionCommandListener.setTerminal(tradingTerminal);
        this.getTemporarySessionCommand.subscribeStatusChange(this.temporarySessionCommandListener);
        this.getTemporarySessionCommand.execute();
    }
    sendCommandForTradingSession(tradingTerminal, login, temporarySession) {
        this.logger.debug("request trading session");
        this.timeoutScheduler.startWithDelay();
        this.commandEnvironment.setTradingTerminal(tradingTerminal);
        this.getTradingSessionCommand = this.commandFactory.createGetTradingSessionCommand(this.commandEnvironment.build(), login, temporarySession, 300, 120);
        this.tradingSessionCommandListener = new LoginController.TradingSessionCommandListener(this);
        this.tradingSessionCommandListener.setTerminal(tradingTerminal);
        this.getTradingSessionCommand.subscribeStatusChange(this.tradingSessionCommandListener);
        this.getTradingSessionCommand.execute();
    }
    stop() {
        this.logger.debug("stop login controller");
        this.reconnectionScheduler.stop();
        this.timeoutScheduler.stop();
        if (this.tradingTerminalsCommand != null) {
            this.tradingTerminalsCommand.unsubscribeStatusChange(this.terminalCommandStatusListener);
            this.tradingTerminalsCommand.stop();
            this.tradingTerminalsCommand = null;
        }
        if (this.getTemporarySessionCommand != null) {
            this.getTemporarySessionCommand.unsubscribeStatusChange(this.temporarySessionCommandListener);
            this.getTemporarySessionCommand.stop();
            this.getTemporarySessionCommand = null;
        }
        if (this.getTradingSessionCommand != null) {
            this.getTradingSessionCommand.unsubscribeStatusChange(this.tradingSessionCommandListener);
            this.getTradingSessionCommand.stop();
            this.getTradingSessionCommand = null;
        }
        if (this.loginMultiPriceTerminalsCommand != null) {
            this.loginMultiPriceTerminalsCommand.stop();
            this.loginMultiPriceTerminalsCommand = null;
        }
    }
    parseError(error) {
        if (error != null) {
            if (stdlib.trim(error) == "Login failed. Incorrect user name or password") {
                return LoginError.create(LoginError.CODE_WRONG_USERNAME_OR_PASSWORD, LoginController.INCORRECT_CREDENTIALS_ERROR);
            }
            if (stdlib.indexOf(error, "ORA-20174", false) >= 0) {
                return LoginError.create(LoginError.CODE_LOCKED_USER, "You have been locked out of your account. Please contact us to regain access");
            }
            if (stdlib.indexOf(error, "Timeout", false) >= 0) {
                return LoginError.create(LoginError.CODE_TIMEOUT, error);
            }
            return LoginError.create(LoginError.CODE_SERVER_ERROR, error);
        }
        else {
            return LoginError.create(LoginError.CODE_SERVER_ERROR, "");
        }
    }
    logParsedError(message, parsedError) {
        let loggerMessage;
        loggerMessage = message + " code: " + (parsedError.getCode()).toString() + " error: " + parsedError.getMessage();
        if (parsedError.getCode() == LoginError.CODE_SERVER_ERROR) {
            this.logger.error(loggerMessage);
        }
        else {
            this.logger.warning(loggerMessage);
        }
    }
    createReceiveNewMessageListener() {
        this.receiveNewMessageListener = new LoginController.ReceiveNewMessageListener(this);
    }
    sendCommandFTS() {
        if (stdlib.len(this.passwordCurrent) > 0) {
            this.sendCommandForTemporarySession(this.tradingTerminalCurrent);
        }
        else {
            if (stdlib.len(this.ssoProviderCurrent) > 0) {
                this.sendCommandForTemporarySessionByExternalSsoToken(this.tradingTerminalCurrent);
            }
            else {
                this.sendCommandForTemporarySessionBySsoToken(this.tradingTerminalCurrent);
            }
        }
    }
}
module.exports = LoginController
LoginController.ReceiveNewMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        if (message.getType() == MessageType.Reconnecting) {
            if (!this._owner_.allowReconnecting) {
                this._owner_.messageRouter.publishNewMessage([new DisconnectedMessageBuilder().build()]);
                this._owner_.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.DISCONNECTED, this._owner_.connectionStatusManager.getConnectionStatus().getError().getMessage());
                return;
            }
            this._owner_.messageExecutor.cancel();
            this._owner_.timeoutScheduler.stop();
            if (this._owner_.loginMultiPriceTerminalsCommand != null) {
                this._owner_.loginMultiPriceTerminalsCommand.stop();
                this._owner_.loginMultiPriceTerminalsCommand = null;
            }
            this._owner_.totalReconnectAttempts = this._owner_.totalReconnectAttempts + 1;
            if (this._owner_.totalReconnectAttempts <= this._owner_.connectionParameters.getReconnectionsNumber()) {
                this._owner_.reconnectionScheduler.startWithDelay();
            }
            else {
                this._owner_.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.DISCONNECTED, "Reconnection attempts number is over");
            }
        }
    }
}
LoginController.ReconnectionCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        this._owner_.logger.info("start reconnection");
        this._owner_.reconnectionScheduler.stop();
        this._owner_.sendCommandFTS();
    }
}
LoginController.TimeoutConnectionCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        this._owner_.logger.error("login failed. " + " code: " + (LoginError.CODE_TIMEOUT).toString() + " error: " + LoginController.CONNECTION_TIMEOUT_ERROR);
        this._owner_.loginCallback.onLoginError(LoginError.create(LoginError.CODE_TIMEOUT, LoginController.CONNECTION_TIMEOUT_ERROR));
        if (this._owner_.connectionStatusManager != null) {
            this._owner_.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.DISCONNECTED, LoginController.CONNECTION_TIMEOUT_ERROR);
        }
        this._owner_.timeoutScheduler.stop();
    }
}
LoginController.TerminalCommandStatusListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccess(message) {
        let getTradingTerminalsMessage, terminals;
        this._owner_.timeoutScheduler.stop();
        this._owner_.tradingTerminalsCommand.unsubscribeStatusChange(this._owner_.terminalCommandStatusListener);
        if (this._owner_.getTerminalsLoginExecutionTimeEvent != null) {
            this._owner_.getTerminalsLoginExecutionTimeEvent.stop();
            EventManager.getLogger().performance(this._owner_.getTerminalsLoginExecutionTimeEvent.build());
        }
        if (message != null && message.getType() == MessageType.GetTradingTerminals) {
            getTradingTerminalsMessage = message;
            terminals = getTradingTerminalsMessage.getTradingTerminals();
            this._owner_.logger.debug("terminals received. count: " + (terminals.length).toString());
            if (terminals.length == 0) {
                this._owner_.logger.warning("no trading terminal found");
                this._owner_.loginCallback.onLoginError(LoginError.create(LoginError.CODE_WRONG_USERNAME_OR_PASSWORD, LoginController.INCORRECT_CREDENTIALS_ERROR));
                this._owner_.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
                return;
            }
            if (terminals.length > 1) {
                if (this._owner_.loginCallback != null) {
                    this._owner_.logger.debug("request terminal from user");
                    this._owner_.loginCallback.onTradingTerminalRequest(this._owner_.tradingTerminalSelector, terminals);
                }
            }
            else {
                this._owner_.logger.debug("1 terminal received. use it");
                this._owner_.tradingTerminalCurrent = terminals[0];
                this._owner_.sendCommandFTS();
            }
        }
        else {
            this._owner_.loginCallback.onLoginError(LoginError.create(LoginError.CODE_SERVER_ERROR, "The message in 'Terminal CommandStatusListener' is invalid or has an unexpected type"));
            this._owner_.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
        }
    }
    onError(error) {
        let loggerMessage, parsedError;
        this._owner_.timeoutScheduler.stop();
        this._owner_.tradingTerminalsCommand.unsubscribeStatusChange(this._owner_.terminalCommandStatusListener);
        if (this._owner_.getTerminalsLoginExecutionTimeEvent != null) {
            this._owner_.getTerminalsLoginExecutionTimeEvent.stop();
            EventManager.getLogger().performance(this._owner_.getTerminalsLoginExecutionTimeEvent.build());
        }
        loggerMessage = "request terminals failed.";
        if (error == "INCORRECT_CREDENTIALS") {
            this._owner_.logger.warning(loggerMessage + " code: " + (LoginError.CODE_WRONG_USERNAME_OR_PASSWORD).toString() + " error: " + LoginController.INCORRECT_CREDENTIALS_ERROR);
            this._owner_.loginCallback.onLoginError(LoginError.create(LoginError.CODE_WRONG_USERNAME_OR_PASSWORD, LoginController.INCORRECT_CREDENTIALS_ERROR));
        } else if (error == "INCORRECT_CONNECTION") {
            this._owner_.logger.warning(loggerMessage + " code: " + (LoginError.CODE_INCORRECT_CONNECTION_NAME).toString() + " error: " + LoginController.INCORRECT_CONNECTION_ERROR);
            this._owner_.loginCallback.onLoginError(LoginError.create(LoginError.CODE_INCORRECT_CONNECTION_NAME, LoginController.INCORRECT_CONNECTION_ERROR));
        }         else {
            parsedError = this._owner_.parseError(error);
            this._owner_.logParsedError("request terminals failed.", parsedError);
            this._owner_.loginCallback.onLoginError(parsedError);
        }
        if (this._owner_.connectionStatusManager != null) {
            this._owner_.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
        }
    }
    onCancel() {
        this._owner_.tradingTerminalsCommand.unsubscribeStatusChange(this._owner_.terminalCommandStatusListener);
        this._owner_.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
        this._owner_.timeoutScheduler.stop();
    }
}
LoginController.TradingTerminalSelector = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    selectTerminal(terminal) {
        this._owner_.timeoutScheduler.stop();
        if (terminal == null) {
            if (this._owner_.loginCallback != null) {
                this._owner_.logger.warning("a trading terminal is not selected");
                this._owner_.loginCallback.onLoginError(LoginError.create(LoginError.CODE_EMPTY_PARAMETER, "A trading terminal is not selected."));
            }
            this._owner_.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
        }
        else {
            this._owner_.logger.debug("a trading terminal is selected");
            this._owner_.tradingTerminalCurrent = terminal;
            this._owner_.sendCommandFTS();
        }
    }
}
LoginController.TemporarySessionCommandListener = class {
    tradingTerminal;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setTerminal(tradingTerminal) {
        this.tradingTerminal = tradingTerminal;
    }
    onSuccess(message) {
        let getTemporarySessionMessage, temporarySession;
        this._owner_.timeoutScheduler.stop();
        this._owner_.getTemporarySessionCommand.unsubscribeStatusChange(this._owner_.temporarySessionCommandListener);
        if (message != null && message.getType() == MessageType.GetTemporarySession) {
            getTemporarySessionMessage = message;
            temporarySession = getTemporarySessionMessage.getTemporarySession();
            this._owner_.logger.debug("temporary trading session received. session: " + temporarySession);
            this._owner_.sendCommandForTradingSession(this.tradingTerminal, this._owner_.loginCurrent, temporarySession);
        }
        else {
            this._owner_.loginCallback.onLoginError(LoginError.create(LoginError.CODE_SERVER_ERROR, "The message in 'Terminal CommandStatusListener' is invalid or has an unexpected type"));
            this._owner_.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
        }
    }
    onError(error) {
        let isReconnecting, messages, reconnectingMessageBuilder, parsedError;
        this._owner_.timeoutScheduler.stop();
        isReconnecting = this._owner_.connectionStatusManager.getConnectionStatus().isReconnecting();
        this._owner_.getTemporarySessionCommand.unsubscribeStatusChange(this._owner_.temporarySessionCommandListener);
        if (isReconnecting) {
            messages = new Array(1);
            reconnectingMessageBuilder = new ReconnectingMessageBuilder();
            messages[0] = reconnectingMessageBuilder.build();
            this._owner_.messageRouter.publishNewMessage(messages);
        }
        else {
            parsedError = this._owner_.parseError(error);
            this._owner_.logParsedError("request temporary trading session failed.", parsedError);
            this._owner_.loginCallback.onLoginError(parsedError);
            this._owner_.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
        }
    }
    onCancel() {
        this._owner_.timeoutScheduler.stop();
        this._owner_.getTemporarySessionCommand.unsubscribeStatusChange(this._owner_.temporarySessionCommandListener);
        this._owner_.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
    }
}
LoginController.TradingSessionCommandListener = class {
    tradingTerminal;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setTerminal(tradingTerminal) {
        this.tradingTerminal = tradingTerminal;
    }
    onSuccess(message) {
        let getTradingSessionMessage, tradingSession, messages, tradingSessionReceivedMessageBuilder;
        this._owner_.timeoutScheduler.stop();
        this._owner_.getTradingSessionCommand.unsubscribeStatusChange(this._owner_.tradingSessionCommandListener);
        if (message != null && message.getType() == MessageType.GetTradingSession) {
            getTradingSessionMessage = message;
            tradingSession = getTradingSessionMessage.getPersistentSession();
            if (tradingSession != null) {
                this._owner_.totalReconnectAttempts = 0;
                this._owner_.logger.debug("trading session received. session: " + tradingSession);
                this._owner_.sessionStorage.setTradingSession(Session.create(tradingSession, getTradingSessionMessage.getUserId(), this.tradingTerminal, getTradingSessionMessage.getOptions()));
                messages = new Array(1);
                tradingSessionReceivedMessageBuilder = new TradingSessionReceivedMessageBuilder();
                messages[0] = tradingSessionReceivedMessageBuilder.build();
                this._owner_.messageRouter.publishNewMessage(messages);
                this._owner_.commandEnvironment.setTradingTerminal(this.tradingTerminal);
                if (this._owner_.getTradingSessionExecutionTimeEvent != null) {
                    this._owner_.getTradingSessionExecutionTimeEvent.stop();
                    EventManager.getLogger().performance(this._owner_.getTradingSessionExecutionTimeEvent.build());
                }
                this._owner_.loginMultiPriceTerminalsCommand = this._owner_.commandFactory.createLoginInMultiPriceTerminalsCommand(this._owner_.commandFactory, this._owner_.commandEnvironment.build(), this._owner_.sessionStorage, this._owner_.ssoTokenController, this._owner_.connectionStatusManager, this._owner_.loginCurrent, this._owner_.ssoTokenCurrent, this._owner_.aliveControllerFactory, this._owner_.rakeOutControllerFactory, this._owner_.instrumentsProvider, this._owner_.dxfeedConnectionFactory, new LoginController.LoginInMultiPriceTerminalsCallback(this._owner_), this._owner_.systemSettingsProvider, this.tradingTerminal, this._owner_.testRequestControllerFactory);
                this._owner_.loginMultiPriceTerminalsCommand.setConfigFlags(this._owner_.configFlags);
                this._owner_.loginMultiPriceTerminalsCommand.setRawOffersStorage(this._owner_.rawOffersStorage);
                this._owner_.loginMultiPriceTerminalsCommand.execute();
            }
            else {
                this._owner_.logger.warning("request trading session failed. code: " + (LoginError.CODE_SERVER_ERROR).toString() + " error: " + getTradingSessionMessage.getError());
                this._owner_.loginCallback.onLoginError(LoginError.create(LoginError.CODE_SERVER_ERROR, getTradingSessionMessage.getError()));
                this._owner_.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
            }
        }
    }
    onError(error) {
        let messages, reconnectingMessageBuilder, isReconnecting, parsedError;
        this._owner_.timeoutScheduler.stop();
        isReconnecting = this._owner_.connectionStatusManager.getConnectionStatus().isReconnecting();
        this._owner_.getTradingSessionCommand.unsubscribeStatusChange(this._owner_.tradingSessionCommandListener);
        if (this._owner_.getTradingSessionExecutionTimeEvent != null) {
            this._owner_.getTradingSessionExecutionTimeEvent.stop();
            EventManager.getLogger().performance(this._owner_.getTradingSessionExecutionTimeEvent.build());
        }
        if (isReconnecting) {
            messages = new Array(1);
            reconnectingMessageBuilder = new ReconnectingMessageBuilder();
            messages[0] = reconnectingMessageBuilder.build();
            this._owner_.messageRouter.publishNewMessage(messages);
        }
        else {
            parsedError = this._owner_.parseError(error);
            this._owner_.logParsedError("request trading session failed.", parsedError);
            this._owner_.loginCallback.onLoginError(parsedError);
            this._owner_.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
        }
    }
    onCancel() {
        this._owner_.timeoutScheduler.stop();
        this._owner_.getTradingSessionCommand.unsubscribeStatusChange(this._owner_.tradingSessionCommandListener);
        this._owner_.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
    }
}
LoginController.LoginInMultiPriceTerminalsCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onError(error) {
        let parsedError, disconnectedMessageBuilder;
        parsedError = this._owner_.parseError(error);
        this._owner_.logParsedError("price terminal auth failed.", parsedError);
        disconnectedMessageBuilder = new DisconnectedMessageBuilder();
        this.publishRouterMessage(disconnectedMessageBuilder.build());
        this._owner_.loginCallback.onLoginError(parsedError);
        this._owner_.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
    }
    onSuccess() {
        let connectedMessageBuilder;
        this._owner_.fullLoginExecutionTimeEvent.stop();
        EventManager.getLogger().performance(this._owner_.fullLoginExecutionTimeEvent.build());
        connectedMessageBuilder = new ConnectedMessageBuilder();
        this.publishRouterMessage(connectedMessageBuilder.build());
        this._owner_.connectionStatusManager.changeConnectionStatus(ConnectionStatus.CONNECTED);
    }
    publishRouterMessage(message) {
        let messages;
        messages = new Array(1);
        messages[0] = message;
        this._owner_.messageRouter.publishNewMessage(messages);
    }
}
