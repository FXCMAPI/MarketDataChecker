'use strict';
let CommandEnvironmentBuilder = require('./CommandEnvironmentBuilder.js');
let GetTempPriceSessionCommandExecutor = require('./GetTempPriceSessionCommandExecutor.js');
let GetPriceSessionCommandExecutor = require('./GetPriceSessionCommandExecutor.js');
let AlivePriceSessionCommandExecutor = require('./AlivePriceSessionCommandExecutor.js');
let RakeOutPriceSessionCommandExecutor = require('./RakeOutPriceSessionCommandExecutor.js');
let SuccessPriceSessionCommandExecutor = require('./SuccessPriceSessionCommandExecutor.js');
let TestRequestCommandExecutor = require('./TestRequestCommandExecutor.js');
let PdasPriceSessionProvider = require('./PdasPriceSessionProvider.js');
let PdasTempPriceSessionIdProvider = require('./PdasTempPriceSessionIdProvider.js');
let LogManager = require('./LogManager.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let MessageType = require('./MessageType.js');
let CommonErrorType = require('./CommonErrorType.js');
//@@DocBrief("The class for perform login operation to authenticate to price terminal")
class PdasPriceTerminalController {
    sessionProvider;
    timeoutScheduler;
    alivePriceSessionCommandExecutor;
    rakeOutPriceSessionCommandExecutor;
    getTempPriceSessionCommandExecutor;
    testRequestCommandExecutor;
    getPriceSessionCommandExecutor;
    pdasPriceTerminalControllerCallback;
    loginCurrent;
    connectionParameters;
    commandFactory;
    messageFactory;
    requestNumberGenerator;
    messageExecutor;
    messageRouter;
    ssoTokenController;
    getTokenCallback;
    connectionStatusManager;
    pdasPriceSessionProvider;
    logger;
    tempPriceSessionIdProvider;
    aliveControllerFactory;
    rakeOutControllerFactory;
    receiveNewMessageListener;
    errorObserver;
    testRequestControllerFactory;
    login(tradeSession, login, ssoToken, tradingTerminal, priceTerminal, pdasPriceTerminalControllerCallback) {
        this.logger.debug("start login in price terminal");
        this.loginCurrent = login;
        this.pdasPriceTerminalControllerCallback = pdasPriceTerminalControllerCallback;
        this.sendGetSSOCommand(tradeSession, tradingTerminal, priceTerminal);
    }
    sendCommandForTemporarySession(tradeSession, login, token, tradingTerminal, priceTerminal) {
        let successPriceSessionCommandExecutor, commandEnvironment;
        this.logger.debug("request temporary price session using SSO token");
        commandEnvironment = new CommandEnvironmentBuilder();
        commandEnvironment.setMessageRouter(this.messageRouter);
        commandEnvironment.setMessageExecutor(this.messageExecutor);
        commandEnvironment.setConnectionParameters(this.connectionParameters);
        commandEnvironment.setMessageFactory(this.messageFactory);
        commandEnvironment.setTradingTerminal(tradingTerminal);
        commandEnvironment.setRequestNumberGenerator(this.requestNumberGenerator);
        this.getTempPriceSessionCommandExecutor = GetTempPriceSessionCommandExecutor.create(commandEnvironment, this.commandFactory, this.loginCurrent, token, tradeSession, priceTerminal, this.tempPriceSessionIdProvider);
        this.getPriceSessionCommandExecutor = GetPriceSessionCommandExecutor.create(commandEnvironment, this.commandFactory, this.loginCurrent, this.tempPriceSessionIdProvider, this.pdasPriceSessionProvider, priceTerminal);
        this.alivePriceSessionCommandExecutor = AlivePriceSessionCommandExecutor.create(commandEnvironment, this.commandFactory, this.pdasPriceSessionProvider, this.connectionStatusManager, priceTerminal, this.aliveControllerFactory, new PdasPriceTerminalController.AlivePriceControllerCallback(this));
        this.rakeOutPriceSessionCommandExecutor = RakeOutPriceSessionCommandExecutor.create(commandEnvironment, this.commandFactory, this.pdasPriceSessionProvider, this.connectionStatusManager, priceTerminal, this.rakeOutControllerFactory, new PdasPriceTerminalController.RakeOutPriceControllerCallback(this));
        successPriceSessionCommandExecutor = SuccessPriceSessionCommandExecutor.create(this.pdasPriceSessionProvider);
        this.testRequestCommandExecutor = TestRequestCommandExecutor.create(commandEnvironment, this.commandFactory, this.pdasPriceSessionProvider, this.connectionStatusManager, priceTerminal, this.testRequestControllerFactory, new PdasPriceTerminalController.TestRequestControllerCallback(this));
        this.rakeOutPriceSessionCommandExecutor.setSuccessor(successPriceSessionCommandExecutor);
        this.testRequestCommandExecutor.setSuccessor(this.rakeOutPriceSessionCommandExecutor);
        this.alivePriceSessionCommandExecutor.setSuccessor(this.testRequestCommandExecutor);
        this.getPriceSessionCommandExecutor.setSuccessor(this.alivePriceSessionCommandExecutor);
        this.getTempPriceSessionCommandExecutor.setSuccessor(this.getPriceSessionCommandExecutor);
        this.getTempPriceSessionCommandExecutor.execute(this.pdasPriceTerminalControllerCallback);
    }
    sendGetSSOCommand(tradeSession, tradingTerminal, priceTerminal) {
        this.logger.debug("request getSSOToken for price session.");
        this.timeoutScheduler.startWithDelay();
        this.getTokenCallback = new PdasPriceTerminalController.GetTokenCallback(this);
        this.getTokenCallback.setTradingSession(tradeSession);
        this.getTokenCallback.setTradingTerminal(tradingTerminal);
        this.getTokenCallback.setPriceTerminal(priceTerminal);
        this.ssoTokenController.getSsoToken(this.getTokenCallback);
    }
    static create(commandFactory, commandEnvironment, sessionProvider, ssoTokenController, connectionStatusManager, aliveControllerFactory, rakeOutControllerFactory, testRequestControllerFactory) {
        let controller;
        controller = new PdasPriceTerminalController();
        controller.sessionProvider = sessionProvider;
        controller.connectionParameters = commandEnvironment.getConnectionParameters();
        controller.pdasPriceTerminalControllerCallback = null;
        controller.commandFactory = commandFactory;
        controller.messageFactory = commandEnvironment.getMessageFactory();
        controller.requestNumberGenerator = commandEnvironment.getRequestNumberGenerator();
        controller.messageExecutor = commandEnvironment.getMessageExecutor();
        controller.messageRouter = commandEnvironment.getMessageRouter();
        controller.sessionProvider = sessionProvider;
        controller.ssoTokenController = ssoTokenController;
        controller.connectionStatusManager = connectionStatusManager;
        controller.aliveControllerFactory = aliveControllerFactory;
        controller.rakeOutControllerFactory = rakeOutControllerFactory;
        controller.pdasPriceSessionProvider = new PdasPriceSessionProvider();
        controller.tempPriceSessionIdProvider = new PdasTempPriceSessionIdProvider();
        controller.getTempPriceSessionCommandExecutor = null;
        controller.alivePriceSessionCommandExecutor = null;
        controller.getTempPriceSessionCommandExecutor = null;
        controller.rakeOutPriceSessionCommandExecutor = null;
        controller.errorObserver = null;
        controller.testRequestControllerFactory = testRequestControllerFactory;
        controller.init();
        return controller;
    }
    init() {
        this.logger = LogManager.getLogger();
        this.timeoutScheduler = scheduler.create(this.connectionParameters.getLoginTimeoutInSeconds() * 1000, new PdasPriceTerminalController.TimeoutConnectionCallback(this));
        this.receiveNewMessageListener = new PdasPriceTerminalController.ReceiveNewMessageListener(this);
        this.messageRouter.subscribeNewMessageReceive(MessageType.KeepAlive, this.receiveNewMessageListener);
    }
    stop() {
        this.timeoutScheduler.stop();
        if (this.getTempPriceSessionCommandExecutor != null) {
            this.getTempPriceSessionCommandExecutor.stop();
        }
        if (this.getPriceSessionCommandExecutor != null) {
            this.getPriceSessionCommandExecutor.stop();
        }
        if (this.alivePriceSessionCommandExecutor != null) {
            this.alivePriceSessionCommandExecutor.stop();
        }
        if (this.rakeOutPriceSessionCommandExecutor != null) {
            this.rakeOutPriceSessionCommandExecutor.stop();
        }
        if (this.testRequestCommandExecutor != null) {
            this.testRequestCommandExecutor.stop();
        }
        this.messageRouter.unsubscribeNewMessageReceive(MessageType.KeepAlive, this.receiveNewMessageListener);
    }
    processMessage(message) {
        let specifiedMessage;
        if (message.getType() == MessageType.KeepAlive) {
            specifiedMessage = message;
            if (specifiedMessage.getError() == CommonErrorType.SessionExpired) {
                this.messageRouter.unsubscribeNewMessageReceive(MessageType.KeepAlive, this.receiveNewMessageListener);
                this.timeoutScheduler.stop();
                this.errorObserver.onTradingSessionExpiredError();
                this.pdasPriceTerminalControllerCallback.onError("Session expired");
            }
        }
    }
    setSessionErrorObserver(errorObserver) {
        this.errorObserver = errorObserver;
    }
}
module.exports = PdasPriceTerminalController
PdasPriceTerminalController.TimeoutConnectionCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        this._owner_.timeoutScheduler.stop();
        this._owner_.pdasPriceTerminalControllerCallback.onError("Price terminal connection timeout");
    }
}
PdasPriceTerminalController.GetTokenCallback = class {
    tradingTerminal;
    tradingSession;
    priceTerminal;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setTradingTerminal(tradingTerminal) {
        this.tradingTerminal = tradingTerminal;
    }
    setTradingSession(tradingSession) {
        this.tradingSession = tradingSession;
    }
    setPriceTerminal(priceTerminal) {
        this.priceTerminal = priceTerminal;
    }
    onError(error) {
        this._owner_.timeoutScheduler.stop();
        this._owner_.pdasPriceTerminalControllerCallback.onError(error);
    }
    onSuccess(token) {
        this._owner_.timeoutScheduler.stop();
        this._owner_.sendCommandForTemporarySession(this.tradingSession, this._owner_.loginCurrent, token, this.tradingTerminal, this.priceTerminal);
    }
}
PdasPriceTerminalController.ReceiveNewMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        this._owner_.processMessage(message);
    }
}
PdasPriceTerminalController.RakeOutPriceControllerCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onError(error) {
        this._owner_.stop();
        if (error == CommonErrorType.SessionExpired) {
            this._owner_.errorObserver.onSessionExpiredError();
        }
        else {
            this._owner_.errorObserver.onConnectionError(error);
        }
    }
}
PdasPriceTerminalController.AlivePriceControllerCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onError(error) {
        this._owner_.stop();
        if (error == CommonErrorType.SessionExpired) {
            this._owner_.errorObserver.onSessionExpiredError();
        }
        else {
            this._owner_.errorObserver.onConnectionError(error);
        }
    }
}
PdasPriceTerminalController.TestRequestControllerCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onError(error) {
        this._owner_.stop();
        if (error == CommonErrorType.SessionExpired) {
            this._owner_.errorObserver.onSessionExpiredError();
        }
        else {
            this._owner_.errorObserver.onConnectionError(error);
        }
    }
}
