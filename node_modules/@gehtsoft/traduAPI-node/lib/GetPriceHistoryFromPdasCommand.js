'use strict';
let int_map = require('@gehtsoft/LuaxStdlib-node').int_map;
let LogManager = require('./LogManager.js');
let LocalPriceHistoryCommandCallback = require('./LocalPriceHistoryCommandCallback.js');
let ExecutionTimeEventName = require('./ExecutionTimeEventName.js');
let MessageType = require('./MessageType.js');
let IntValueObject = require('./IntValueObject.js');
let PriceHistoryRequest = require('./PriceHistoryRequest.js');
let StringUtil = require('./StringUtil.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let TimeframeUtils = require('./TimeframeUtils.js');
let FXConnectLiteErrorBuilder = require('./FXConnectLiteErrorBuilder.js');
let list = require('@gehtsoft/LuaxStdlib-node').list;
let PriceHistoryResultCompiler = require('./PriceHistoryResultCompiler.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
class GetPriceHistoryFromPdasCommand {
    static get TIMEOUT() { return 30000; }
    request;
    callback;
    pendingRequests;
    linkRequestsToParent;
    responses;
    logger;
    messageRouter;
    commandFactory;
    priceTerminalData;
    messageFactory;
    requestNumberGenerator;
    messageExecutor;
    timeoutScheduler;
    timeController;
    receiveNewMessageListener;
    systemSettingsProvider;
    constructor() {
        this.linkRequestsToParent = new int_map();
        this.responses = new int_map();
        this.pendingRequests = new int_map();
        this.logger = LogManager.getLogger();
        this.setReceiveNewMessageListener();
    }
    static create(request, callback, messageRouter, commandFactory, priceTerminalData, messageFactory, requestNumberGenerator, messageExecutor, timeController, systemSettingsProvider) {
        let result;
        result = new GetPriceHistoryFromPdasCommand();
        result.request = request;
        result.callback = LocalPriceHistoryCommandCallback.create(ExecutionTimeEventName.GetPricesPdasTime, callback);
        result.messageRouter = messageRouter;
        result.commandFactory = commandFactory;
        result.priceTerminalData = priceTerminalData;
        result.messageFactory = messageFactory;
        result.requestNumberGenerator = requestNumberGenerator;
        result.messageExecutor = messageExecutor;
        result.timeController = timeController;
        result.systemSettingsProvider = systemSettingsProvider;
        result.subscribeOnRequiredMessages();
        return result;
    }
    stop() {
        if (this.timeoutScheduler != null) {
            this.timeoutScheduler.stop();
        }
        this.pendingRequests.clear();
        this.linkRequestsToParent.clear();
    }
    execute() {
        let requestNumber, timeoutCallback;
        requestNumber = this.requestNumberGenerator.getNextRequestNumber();
        this.logger.debug("PriceHistoryManager. Execute request: P-" + (requestNumber).toString() + ". " + this.request.getInstrument() + " / " + (this.request.getFrom()).toString() + "-" + (this.request.getTo()).toString() + " / " + (this.request.getQuotesCount()).toString());
        timeoutCallback = new GetPriceHistoryFromPdasCommand.TimeoutCallback(this);
        timeoutCallback.setRequestNumber(requestNumber);
        this.timeoutScheduler = GetPriceHistoryFromPdasCommand.TimeoutScheduler.create(GetPriceHistoryFromPdasCommand.TIMEOUT, timeoutCallback);
        this.pendingRequests.set(requestNumber, this.request);
        this.executeNextCommand(requestNumber, true, this.request.getTo());
    }
    subscribeOnRequiredMessages() {
        this.messageRouter.subscribeNewMessageReceive(MessageType.PriceHistory, this.receiveNewMessageListener);
    }
    setReceiveNewMessageListener() {
        this.receiveNewMessageListener = new GetPriceHistoryFromPdasCommand.ReceiveNewMessageListener(this);
    }
    unsubscribeMessages() {
        this.messageRouter.unsubscribeNewMessageReceive(MessageType.PriceHistory, this.receiveNewMessageListener);
    }
    executeNextCommand(parentRequestNumber, firstRequest, to) {
        let command, request, requestNumber, quotesCountReal, receivedCount;
        if (this.pendingRequests.contains(parentRequestNumber)) {
            request = this.pendingRequests.get(parentRequestNumber);
            quotesCountReal = request.getQuotesCount();
            if (request.getQuotesCount() <= 0) {
                quotesCountReal = 300;
            } else if (request.getQuotesCount() > 300) {
                receivedCount = this.getReceivedQuoteCount(parentRequestNumber);
                if (request.getQuotesCount() - receivedCount > 300) {
                    quotesCountReal = 300;
                }
                else {
                    quotesCountReal = request.getQuotesCount() - receivedCount;
                }
            }
            requestNumber = parentRequestNumber;
            if (!firstRequest) {
                requestNumber = this.requestNumberGenerator.getNextRequestNumber();
                this.linkRequestsToParent.set(requestNumber, IntValueObject.create(parentRequestNumber));
                this.logger.debug("PriceHistoryManager. Execute request: " + (requestNumber).toString() + ". Parent request: P-" + (parentRequestNumber).toString());
            }
            request = PriceHistoryRequest.create(request.getInstrument(), request.getTimeframe(), request.getFrom(), to, quotesCountReal, request.getInstrumentDescriptor());
            command = this.commandFactory.createGetPriceHistoryCommand(request, this.messageExecutor, this.priceTerminalData, this.messageFactory, requestNumber);
            this.timeoutScheduler.startWithDelay();
            command.execute();
        }
    }
    processMessage(message) {
        let getPriceHistoryMessage, requestNumber, parentRequestNumber;
        this.logger.debug("PriceHistoryManager. Receive message: " + message.getType());
        if (message.getType() == MessageType.PriceHistory) {
            getPriceHistoryMessage = message;
            requestNumber = StringUtil.getRequestNumber(getPriceHistoryMessage.getRequestId());
            if (this.isOurResponse(requestNumber)) {
                parentRequestNumber = this.processBatchRequest(requestNumber);
                this.logger.debug("PriceHistoryManager. Receive response. Request: " + (requestNumber).toString() + ". Parent request: P-" + (parentRequestNumber).toString());
                if (getPriceHistoryMessage.getError() != null) {
                    if (this.processError(getPriceHistoryMessage, parentRequestNumber, requestNumber)) {
                        return;
                    }
                }
                this.finishProcess(getPriceHistoryMessage, parentRequestNumber, requestNumber);
            }
        }
    }
    isOurResponse(requestNumber) {
        let contains;
        contains = this.pendingRequests.contains(requestNumber);
        if (!contains) {
            contains = this.linkRequestsToParent.contains(requestNumber);
            if (!contains) {
                return false;
            }
        }
        return true;
    }
    finishProcess(getPriceHistoryMessage, parentRequestNumber, requestNumber) {
        let result, prices, lastTo, request;
        this.timeoutScheduler.stop();
        lastTo = this.timeController.toServerTime(stdlib.mkdate(1900, 1, 1));
        prices = getPriceHistoryMessage.getPrices();
        if (prices.length > 0) {
            lastTo = this.timeController.toServerTime(prices[0].getDate());
            if (this.pendingRequests.contains(parentRequestNumber)) {
                request = this.pendingRequests.get(parentRequestNumber);
                lastTo = stdlib.fromJdn(stdlib.toJdn(lastTo) - TimeframeUtils.getJdnIncrement(request.getTimeframe()));
            }
        }
        if (this.isBatchCompleted(parentRequestNumber, lastTo, prices.length)) {
            this.logger.debug("PriceHistoryManager. Batch with parent request (P-" + (parentRequestNumber).toString() + ") is complete");
            this.addResponse(parentRequestNumber, getPriceHistoryMessage);
            result = this.prepareResult(parentRequestNumber, false);
            this.clearBatchRequest(parentRequestNumber);
            this.callback.onSuccess(result);
        }
        else {
            this.logger.debug("PriceHistoryManager. Collect response on request: " + (requestNumber).toString());
            this.addResponse(parentRequestNumber, getPriceHistoryMessage);
            this.executeNextCommand(parentRequestNumber, false, lastTo);
        }
    }
    processError(getPriceHistoryMessage, parentRequestNumber, requestNumber) {
        let errorBuilder;
        if (this.hasResult(parentRequestNumber) && stdlib.indexOf(getPriceHistoryMessage.getError(), "No data found", false) > -1) {
            this.logger.debug("PriceHistoryManager. Response (" + (requestNumber).toString() + ") has not data but we has data from previous response chain");
            return false;
        }
        else {
            errorBuilder = new FXConnectLiteErrorBuilder();
            errorBuilder.setMessage(getPriceHistoryMessage.getError());
            this.clearBatchRequest(parentRequestNumber);
            this.logger.debug("PriceHistoryManager. Response (" + (requestNumber).toString() + ") failed: " + getPriceHistoryMessage.getError());
            this.callback.onError(errorBuilder.build());
        }
        return true;
    }
    addResponse(parentRequestNumber, getPriceHistoryMessage) {
        let responseList;
        if (this.responses.contains(parentRequestNumber)) {
            responseList = this.responses.get(parentRequestNumber);
        }
        else {
            responseList = new list();
            this.responses.set(parentRequestNumber, responseList);
        }
        responseList.add(getPriceHistoryMessage);
    }
    isBatchCompleted(parentRequestNumber, lastTo, lastQuotesCount) {
        let request, totalReceivedQuotes;
        if (this.pendingRequests.contains(parentRequestNumber)) {
            request = this.pendingRequests.get(parentRequestNumber);
            if (request.getQuotesCount() > 0) {
                if (this.responses.contains(parentRequestNumber)) {
                    totalReceivedQuotes = lastQuotesCount + this.getReceivedQuoteCount(parentRequestNumber);
                    if (totalReceivedQuotes >= request.getQuotesCount()) {
                        return true;
                    }
                } else if (lastQuotesCount >= request.getQuotesCount()) {
                    return true;
                }
            }
            return stdlib.toJdn(request.getFrom()) >= stdlib.toJdn(lastTo) || stdlib.toJdn(lastTo) - stdlib.toJdn(request.getFrom()) < TimeframeUtils.getJdnIncrement(request.getTimeframe());
        }
        return true;
    }
    getReceivedQuoteCount(parentRequestNumber) {
        let totalReceivedQuotes, message, responseList, i;
        totalReceivedQuotes = 0;
        if (this.pendingRequests.contains(parentRequestNumber) && this.responses.contains(parentRequestNumber)) {
            responseList = this.responses.get(parentRequestNumber);
            for (i = 0; i <= responseList.length() - 1; i += 1) {
                message = responseList.get(i);
                totalReceivedQuotes = totalReceivedQuotes + message.getPrices().length;
            }
        }
        return totalReceivedQuotes;
    }
    processBatchRequest(request) {
        let parentRequestNumber;
        parentRequestNumber = request;
        if (this.linkRequestsToParent.contains(request)) {
            parentRequestNumber = this.linkRequestsToParent.get(request).get();
            this.linkRequestsToParent.remove(request);
        }
        return parentRequestNumber;
    }
    clearBatchRequest(parentRequestNumber) {
        this.unsubscribeMessages();
        this.timeoutScheduler.stop();
        if (this.responses.contains(parentRequestNumber)) {
            this.responses.remove(parentRequestNumber);
        }
        if (this.pendingRequests.contains(parentRequestNumber)) {
            this.pendingRequests.remove(parentRequestNumber);
        }
    }
    hasResult(parentRequestNumber) {
        let responseList;
        if (this.responses.contains(parentRequestNumber)) {
            responseList = this.responses.get(parentRequestNumber);
            return responseList.length() > 0;
        }
        return false;
    }
    prepareResult(parentRequestNumber, suppressTime) {
        let responseList, compiler;
        responseList = this.responses.get(parentRequestNumber);
        compiler = new PriceHistoryResultCompiler();
        return compiler.compileResult(responseList, this.request.getBidAdjustment(), this.request.getAskAdjustment(), suppressTime);
    }
    subscribeStatusChange(callback) {
        return void(0);
    }
    unsubscribeStatusChange(callback) {
        return void(0);
    }
}
module.exports = GetPriceHistoryFromPdasCommand
GetPriceHistoryFromPdasCommand.TimeoutScheduler = class {
    isStartedField;
    mScheduler;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    isStarted() {
        return this.isStartedField;
    }
    startImmediately() {
        this.isStartedField = true;
        this.mScheduler.startImmediately();
    }
    startWithDelay() {
        this.isStartedField = true;
        this.mScheduler.startWithDelay();
    }
    stop() {
        this.isStartedField = false;
        this.mScheduler.stop();
    }
    static create(periodInMilliseconds, pAction) {
        let instance;
        instance = new GetPriceHistoryFromPdasCommand.TimeoutScheduler(this);
        instance.isStartedField = false;
        instance.mScheduler = scheduler.create(periodInMilliseconds, pAction);
        return instance;
    }
}
GetPriceHistoryFromPdasCommand.TimeoutCallback = class {
    requestNumber;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        let errorBuilder, error, request, parentRequestNumber;
        parentRequestNumber = this._owner_.processBatchRequest(this.requestNumber);
        request = this._owner_.pendingRequests.get(parentRequestNumber);
        error = "Get history is timed out on instrument '" + request.getInstrument() + "'";
        errorBuilder = new FXConnectLiteErrorBuilder();
        errorBuilder.setMessage(error);
        this._owner_.clearBatchRequest(parentRequestNumber);
        this._owner_.logger.debug("PriceHistoryManager. " + error);
        this._owner_.callback.onError(errorBuilder.build());
    }
    setRequestNumber(requestNumber) {
        this.requestNumber = requestNumber;
    }
}
GetPriceHistoryFromPdasCommand.ReceiveNewMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        this._owner_.processMessage(message);
    }
}
