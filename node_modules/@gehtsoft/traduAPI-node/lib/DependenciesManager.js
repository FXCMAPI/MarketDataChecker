'use strict';
let LogManager = require('./LogManager.js');
let queue = require('@gehtsoft/LuaxStdlib-node').queue;
let SubscriptionInstrumentCommandFactory = require('./SubscriptionInstrumentCommandFactory.js');
let TradingSessionProvider = require('./TradingSessionProvider.js');
let SubscriptionStatusTracker = require('./SubscriptionStatusTracker.js');
let MessageType = require('./MessageType.js');
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let FXConnectLiteErrorCodes = require('./FXConnectLiteErrorCodes.js');
let SubscribeInstrumentAction = require('./SubscribeInstrumentAction.js');
let StringUtil = require('./StringUtil.js');
let SubscribeInstrumentsInQueueCallback = require('./SubscribeInstrumentsInQueueCallback.js');
let ExecutionTimeEvenUtil = require('./ExecutionTimeEvenUtil.js');
let ExecutionTimeEventName = require('./ExecutionTimeEventName.js');
let CollectionUtils = require('./CollectionUtils.js');
class DependenciesManager {
    logger;
    commandFactory;
    messageRouter;
    messageExecutor;
    sessionStorage;
    messageFactory;
    requestNumberGenerator;
    descriptorsStorage;
    storage;
    instrumentDescriptorsSeparator;
    clientCrossSymbolsProvider;
    subscriptionInstrumentCommandFactory;
    subscriptionStatusTracker;
    instrumentUpdatesStorage;
    leverageProfilesUpdater;
    accountCommissionsUpdater;
    rolloverProfilesUpdater;
    requestsQueue;
    receiveNewMessageListener;
    eventSubscribe;
    static create(commandFactory, messageRouter, messageExecutor, sessionStorage, messageFactory, requestNumberGenerator, descriptorsStorage, storage, instrumentDescriptorsSeparator, clientCrossSymbolsProvider, instrumentUpdatesStorage, leverageProfilesUpdater, accountCommissionsUpdater, rolloverProfilesUpdater) {
        let instance;
        instance = new DependenciesManager();
        instance.logger = LogManager.getLogger();
        instance.commandFactory = commandFactory;
        instance.messageRouter = messageRouter;
        instance.messageExecutor = messageExecutor;
        instance.sessionStorage = sessionStorage;
        instance.messageFactory = messageFactory;
        instance.requestNumberGenerator = requestNumberGenerator;
        instance.descriptorsStorage = descriptorsStorage;
        instance.storage = storage;
        instance.instrumentDescriptorsSeparator = instrumentDescriptorsSeparator;
        instance.clientCrossSymbolsProvider = clientCrossSymbolsProvider;
        instance.instrumentUpdatesStorage = instrumentUpdatesStorage;
        instance.leverageProfilesUpdater = leverageProfilesUpdater;
        instance.accountCommissionsUpdater = accountCommissionsUpdater;
        instance.rolloverProfilesUpdater = rolloverProfilesUpdater;
        instance.requestsQueue = new queue();
        instance.eventSubscribe = null;
        instance.subscriptionInstrumentCommandFactory = SubscriptionInstrumentCommandFactory.create(commandFactory, messageExecutor, messageFactory, TradingSessionProvider.create(sessionStorage), descriptorsStorage);
        instance.subscriptionStatusTracker = SubscriptionStatusTracker.create(messageRouter);
        instance.setReceiveNewMessageListener();
        instance.subscribeOnRequiredMessages();
        return instance;
    }
    setReceiveNewMessageListener() {
        this.receiveNewMessageListener = new DependenciesManager.ReceiveNewMessageListener(this);
    }
    subscribeOnRequiredMessages() {
        this.messageRouter.subscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
    }
    subscribeInstruments(symbols, callback) {
        let act;
        if (symbols == null || symbols.length == 0) {
            this.logger.error("DependenciesManager.subscribeInstruments(): symbols are not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "symbols are not set");
        }
        if (callback == null) {
            this.logger.error("DependenciesManager.subscribeInstruments(): callback is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "callback is not set");
        }
        act = SubscribeInstrumentAction.create(this.commandFactory, this.messageRouter, this.messageExecutor, this.sessionStorage, this.messageFactory, this.requestNumberGenerator, this.descriptorsStorage, this.storage, this.instrumentDescriptorsSeparator, this.clientCrossSymbolsProvider, this.subscriptionInstrumentCommandFactory, this.subscriptionStatusTracker, this.instrumentUpdatesStorage, false, this.leverageProfilesUpdater);
        act.setRolloverProfilesUpdater(this.rolloverProfilesUpdater);
        act.setAccountCommissionsUpdater(this.accountCommissionsUpdater);
        this.logger.info("DependenciesManager.subscribeInstruments(" + StringUtil.arrayToString(symbols) + ")");
        this.executeCommonAction(act, symbols, callback);
    }
    executeCommonAction(act, symbols, callback) {
        let innerCallback;
        act.setSymbols(symbols);
        innerCallback = SubscribeInstrumentsInQueueCallback.create(callback, this.requestsQueue, this.logger, new DependenciesManager.ExecuteNextAction(this));
        act.setCallback(innerCallback);
        this.requestsQueue.enqueue(act);
        this.checkNextActionAndExecute();
    }
    checkNextActionAndExecute() {
        if (this.requestsQueue.length() == 1) {
            this.executeNext();
        }
    }
    executeNext() {
        let requestAction;
        if (this.eventSubscribe != null) {
            ExecutionTimeEvenUtil.eventStop(this.eventSubscribe);
            this.eventSubscribe = null;
        }
        if (this.requestsQueue.length() > 0) {
            requestAction = this.requestsQueue.peek();
            this.logger.info("DependenciesManager.executeNext()");
            this.eventSubscribe = ExecutionTimeEvenUtil.eventStart(ExecutionTimeEventName.SubscribeInstrumentsViaDependenciesManagerTime);
            requestAction.invoke();
        }
    }
    stop() {
        let i, requestAction;
        for (i = 0; i <= this.requestsQueue.length() - 1; i += 1) {
            requestAction = this.requestsQueue.peek();
            requestAction.stop();
        }
        CollectionUtils.clearQueue(this.requestsQueue);
    }
    processMessage(message) {
        this.logger.debug("DependenciesManager. Receive message: " + message.getType());
        if (message.getType() == MessageType.Disconnected) {
            this.stop();
        }
    }
}
module.exports = DependenciesManager
DependenciesManager.ExecuteNextAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        this._owner_.executeNext();
    }
}
DependenciesManager.ReceiveNewMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        this._owner_.processMessage(message);
    }
}
