'use strict';
let DxFeedHandshakeDataReader = require('./DxFeedHandshakeDataReader.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
class DxFeedHandshakeCommand {
    authToken;
    socketCommunicator;
    dXFeedMessageFactory;
    socketReceiveJsonListener;
    dxFeedHandshakeCommandCallback;
    logger;
    reader;
    constructor() {
        this.socketCommunicator = null;
        this.authToken = "";
        this.socketReceiveJsonListener = new DxFeedHandshakeCommand.SocketReceiveMessageListener(this);
        this.dxFeedHandshakeCommandCallback = null;
        this.reader = new DxFeedHandshakeDataReader();
    }
    setAuthToken(authToken) {
        this.authToken = authToken;
    }
    onChange(state) {
        if (!state.isOpen() && state.hasError()) {
            if (this.dxFeedHandshakeCommandCallback != null) {
                this.dxFeedHandshakeCommandCallback.onError(state.getError().getMessage());
            }
        }
        if (state.isOpen() && !state.hasError()) {
            this.socketCommunicator.subscribeJsonReceive(this.socketReceiveJsonListener);
            this.socketCommunicator.send(this.dXFeedMessageFactory.createAuthorizeMessage(this.authToken));
        }
    }
    processMessage(json) {
        let data, ex;
        try {
            data = this.reader.read(json);
            if (data != null) {
                if (data.getSuccessful()) {
                    if (this.dxFeedHandshakeCommandCallback != null) {
                        this.dxFeedHandshakeCommandCallback.onSuccess(data);
                    }
                }
                else {
                    if (this.dxFeedHandshakeCommandCallback != null) {
                        this.dxFeedHandshakeCommandCallback.onError(data.getError());
                    }
                }
                this.socketCommunicator.unsubscribeStateChange(this);
                this.socketCommunicator.unsubscribeJsonReceive(this.socketReceiveJsonListener);
            }
        } catch(exTemp1) {
            ex = stdlib.ensureException(exTemp1);
            this.logger.error("can not process DxFeedHandshake response: " + ex.getMessage());
        }
    }
    static create(socketCommunicator, dXFeedMessageFactory, dxFeedHandshakeCommandCallback, logger) {
        let dxFeedAuthorizeCommand;
        dxFeedAuthorizeCommand = new DxFeedHandshakeCommand();
        dxFeedAuthorizeCommand.socketCommunicator = socketCommunicator;
        dxFeedAuthorizeCommand.dXFeedMessageFactory = dXFeedMessageFactory;
        dxFeedAuthorizeCommand.dxFeedHandshakeCommandCallback = dxFeedHandshakeCommandCallback;
        dxFeedAuthorizeCommand.logger = logger;
        socketCommunicator.subscribeStateChange(dxFeedAuthorizeCommand);
        return dxFeedAuthorizeCommand;
    }
}
module.exports = DxFeedHandshakeCommand
DxFeedHandshakeCommand.SocketReceiveMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onReceive(json) {
        this._owner_.processMessage(json);
    }
}
