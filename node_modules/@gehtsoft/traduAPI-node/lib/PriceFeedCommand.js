'use strict';
let SendSingleCommandWithoutResponse = require('./SendSingleCommandWithoutResponse.js');
let PriceFeedCommandDescriptorBuilder = require('./PriceFeedCommandDescriptorBuilder.js');
let logger = require('@gehtsoft/LuaxStdlib-node').logger;
let PriceTerminalTypes = require('./PriceTerminalTypes.js');
let GetPriceFeedMessageBuilder = require('./GetPriceFeedMessageBuilder.js');
let MessageBuilder = require('./MessageBuilder.js');
//@@DocBrief("The price feed command")
class PriceFeedCommand extends SendSingleCommandWithoutResponse {
    terminal;
    instruments;
    descriptor;
    requestNumber;
    priceSession;
    sessionStorage;
    priceTerminalInitializer;
    messageRouter;
    dxFeedNamesProvider;
    priceFeedCommandCallback;
    constructor() {
        super();
        this.commandName = "PriceFeedCommand";
        this.priceFeedCommandCallback = null;
    }
    execute() {
        let callback;
        this.priceTerminalInitializer = this.sessionStorage.getPriceTerminalInitializerByPriceStreamId(this.descriptor.getFxcmDasMessagePriceStream());
        if (this.priceTerminalInitializer != null) {
            callback = this.createGetInitializedPriceTerminalCallback();
            this.priceTerminalInitializer.getInitializedPriceTerminal(callback);
        }
        else {
            this.logger.error("Not found price terminal for price stream '" + this.descriptor.getFxcmDasMessagePriceStream() + "'");
        }
    }
    executeCommand() {
        super.execute();
    }
    createTransportMessage() {
        return this.messageFactory.createPriceFeedCommandMessage(this.priceSession, this.terminal, this.instruments, this.descriptor, this.requestNumber);
    }
    getSymbols() {
        let result, i;
        result = new Array(this.instruments.length);
        for (i = 0; i <= this.instruments.length - 1; i += 1) {
            result[i] = this.instruments[i].getSymbol();
        }
        return result;
    }
    startDxfeedCommand(dxfeedConnection) {
        let dxFeedPriceTerminalLazyInitializer, parametersController, dxfeedCallback;
        dxFeedPriceTerminalLazyInitializer = this.priceTerminalInitializer;
        parametersController = dxFeedPriceTerminalLazyInitializer.getDXFeedOfferParametersController();
        dxfeedCallback = new PriceFeedCommand.DXFeedSubscriptionCallback(this);
        if (this.descriptor.getSubscriptionRequestType() == PriceFeedCommandDescriptorBuilder.SUBSCRIBE) {
            parametersController.loadHighAndLowForSymbols(this.getSymbols());
            dxfeedConnection.subscribeForQuotes(this.dxFeedNamesProvider.getSymbolsForDxFeed(this.getSymbols()), dxfeedCallback);
        }
        else {
            dxfeedConnection.unsubscribeFromQuotes(this.dxFeedNamesProvider.getSymbolsForDxFeed(this.getSymbols()), dxfeedCallback);
        }
    }
    startPdasCommand(result) {
        let data;
        data = result;
        this.terminal = data.getPriceTerminal();
        this.priceSession = data.getPriceSession();
        this.executeCommand();
    }
    createGetInitializedPriceTerminalCallback() {
        return new PriceFeedCommand.GetInitializedPriceTerminalCallback(this);
    }
}
module.exports = PriceFeedCommand
PriceFeedCommand.GetInitializedPriceTerminalCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onError(error) {
        logger.error(error);
        if (this._owner_.priceFeedCommandCallback != null) {
            this._owner_.priceFeedCommandCallback.onError(error);
        }
    }
    onSuccess(result) {
        let dxfeedConnection;
        if (result != null) {
            if (this._owner_.priceTerminalInitializer.getPriceTerminalType() == PriceTerminalTypes.PDAS) {
                this._owner_.startPdasCommand(result);
            } else if (this._owner_.priceTerminalInitializer.getPriceTerminalType() == PriceTerminalTypes.DXFEED) {
                dxfeedConnection = result;
                this._owner_.startDxfeedCommand(dxfeedConnection);
            }
        }
    }
}
PriceFeedCommand.DXFeedSubscriptionCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccess() {
        let messageBuilder, result, i;
        result = new Array(this._owner_.instruments.length);
        for (i = 0; i <= this._owner_.instruments.length - 1; i += 1) {
            messageBuilder = new GetPriceFeedMessageBuilder();
            messageBuilder.setSymbol(this._owner_.instruments[i].getSymbol());
            messageBuilder.setRequestId("requestid-" + (this._owner_.requestNumber).toString());
            messageBuilder.setOfferId(this._owner_.instruments[i].getOfferId());
            result[i] = MessageBuilder.createLockedMessage(messageBuilder.build());
        }
        this._owner_.messageRouter.publishNewMessage(result);
    }
    onError(errorMessage) {
        logger.error(errorMessage);
        if (this._owner_.priceFeedCommandCallback != null) {
            this._owner_.priceFeedCommandCallback.onError(errorMessage);
        }
    }
}
