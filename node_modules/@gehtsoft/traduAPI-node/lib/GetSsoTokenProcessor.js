'use strict';
let LogManager = require('./LogManager.js');
let MessageType = require('./MessageType.js');
let EventManager = require('./EventManager.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let ExecutionTimeEventBuilder = require('./ExecutionTimeEventBuilder.js');
let ExecutionTimeEventName = require('./ExecutionTimeEventName.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
class GetSsoTokenProcessor {
    static get GET_TOKEN_TIMEOUT() { return 10000; }
    static get MAX_REQUEST_ATTEMPTS() { return 3; }
    sessionProvider;
    messageRouter;
    logger;
    connectionParameters;
    commandFactory;
    messageFactory;
    messageExecutor;
    requestNumberGenerator;
    ssoTokenDecoder;
    receiveNewMessageListener;
    provider;
    clientCallback;
    commandCallback;
    delayedCommandRunner;
    command;
    resilience;
    constructor() {
        this.logger = LogManager.getLogger();
        this.commandCallback = null;
        this.command = null;
        this.delayedCommandRunner = null;
        this.receiveNewMessageListener = null;
    }
    static create(commandFactory, connectionParameters, sessionProvider, messageFactory, messageExecutor, messageRouter, requestNumberGenerator, ssoTokenDecoder, provider, callback) {
        let controller;
        controller = new GetSsoTokenProcessor();
        controller.sessionProvider = sessionProvider;
        controller.messageRouter = messageRouter;
        controller.connectionParameters = connectionParameters;
        controller.commandFactory = commandFactory;
        controller.messageFactory = messageFactory;
        controller.messageExecutor = messageExecutor;
        controller.requestNumberGenerator = requestNumberGenerator;
        controller.ssoTokenDecoder = ssoTokenDecoder;
        controller.provider = provider;
        controller.clientCallback = callback;
        controller.resilience = connectionParameters.getResilience();
        controller.subscribeOnRequiredMessages();
        return controller;
    }
    stop() {
        if (this.command != null) {
            this.command.stop();
        }
        this.unsubscribeOnRequiredMessages();
        this.stopRunningCommand();
    }
    execute() {
        this.sendCommand(1);
    }
    stopRunningCommand() {
        if (this.commandCallback != null) {
            this.commandCallback.done();
        }
        if (this.delayedCommandRunner != null) {
            this.delayedCommandRunner.stop();
        }
    }
    sendCommand(attempt) {
        let commandStatusListener, requestId;
        this.stopRunningCommand();
        requestId = this.requestNumberGenerator.getNextRequestNumber();
        this.commandCallback = new GetSsoTokenProcessor.GetTokenCommandCallback(this);
        this.commandCallback.setAndStart(this.clientCallback, requestId, attempt);
        this.initDelayedCommandRunner(this.resilience.getPeriodInMilliseconds());
        this.command = this.commandFactory.createGetSsoTokenCommand(this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, requestId, this.connectionParameters.getApplicationName(), this.provider);
        commandStatusListener = new GetSsoTokenProcessor.CommandStatusListener(this);
        this.command.subscribeStatusChange(commandStatusListener);
        this.command.execute();
    }
    subscribeOnRequiredMessages() {
        this.receiveNewMessageListener = new GetSsoTokenProcessor.ReceiveNewMessageListener(this);
        this.messageRouter.subscribeNewMessageReceive(MessageType.GetSsoToken, this.receiveNewMessageListener);
    }
    unsubscribeOnRequiredMessages() {
        if (this.receiveNewMessageListener != null) {
            this.messageRouter.unsubscribeNewMessageReceive(MessageType.GetSsoToken, this.receiveNewMessageListener);
        }
    }
    initDelayedCommandRunner(repeatTimeout) {
        this.delayedCommandRunner = new GetSsoTokenProcessor.DelayedCommandRunner(this);
        this.delayedCommandRunner.setAction(new GetSsoTokenProcessor.DelayedCommandRunnerAction(this));
        this.delayedCommandRunner.initDelayStart(repeatTimeout);
    }
    processMessage(message) {
        let getSsoTokenMessage;
        if (message.getType() == MessageType.GetSsoToken) {
            if (this.commandCallback != null && !this.commandCallback.isDone()) {
                getSsoTokenMessage = message;
                if (getSsoTokenMessage.getRequestNumber() == this.commandCallback.getRequestNumber()) {
                    this.logger.debug("GetSsoTokenProcessor. Receive message: " + message.getType() + " Request: " + (this.commandCallback.getRequestNumber()).toString());
                    this.commandCallback.done();
                    this.unsubscribeOnRequiredMessages();
                    EventManager.getLogger().performance(this.commandCallback.getEvent());
                    this.processGetSSOTokenMessage(getSsoTokenMessage, this.clientCallback, this.provider);
                }
            }
        }
    }
    processGetSSOTokenMessage(getSsoTokenMessage, callback, providerName) {
        let tokenKey, token, encryptedToken, sessionOptions;
        if (getSsoTokenMessage.getError() != null) {
            callback.onError("Get SSO Token error: " + getSsoTokenMessage.getError());
            return;
        }
        encryptedToken = getSsoTokenMessage.getToken();
        if (encryptedToken == "") {
            callback.onError("Token is empty");
            return;
        }
        sessionOptions = this.sessionProvider.getSession().getOptions();
        tokenKey = sessionOptions.getOption("TokenKey");
        if (tokenKey == null) {
            callback.onError("TokenKey is empty");
            return;
        }
        token = encryptedToken;
        if (providerName == "") {
            token = this.ssoTokenDecoder.decrypt(encryptedToken, tokenKey);
        } else if (stdlib.indexOf(token, "\n", false) > -1) {
            token = stdlib.substring(token, 0, stdlib.len(token) - 1);
        }
        callback.onSuccess(token);
    }
}
module.exports = GetSsoTokenProcessor
GetSsoTokenProcessor.ReceiveNewMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        this._owner_.processMessage(message);
    }
}
GetSsoTokenProcessor.GetTokenCommandCallback = class {
    timeoutScheduler;
    timeoutCallback;
    executionTimeEvent;
    requestNumber;
    attempt;
    isDoneFlag;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.timeoutScheduler = null;
        this.timeoutCallback = null;
        this.isDoneFlag = false;
    }
    getRequestNumber() {
        return this.requestNumber;
    }
    getAttempt() {
        return this.attempt;
    }
    done() {
        this.timeoutScheduler.stop();
        this.executionTimeEvent.stop();
        this.isDoneFlag = true;
    }
    isDone() {
        return this.isDoneFlag;
    }
    getEvent() {
        return this.executionTimeEvent.build();
    }
    setAndStart(callback, requestNumber, attempt) {
        this.requestNumber = requestNumber;
        this.attempt = attempt;
        this.executionTimeEvent = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.SSOReceiveTime);
        this.startScheduler();
        this.executionTimeEvent.start();
    }
    startScheduler() {
        this.timeoutCallback = new GetSsoTokenProcessor.TimeoutConnectionCallback(this._owner_);
        this.timeoutScheduler = scheduler.create(GetSsoTokenProcessor.GET_TOKEN_TIMEOUT, this.timeoutCallback);
        this.timeoutCallback.setScheduler(this.timeoutScheduler);
        this.timeoutScheduler.startWithDelay();
    }
}
GetSsoTokenProcessor.TimeoutConnectionCallback = class {
    timeoutScheduler;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.timeoutScheduler = null;
    }
    invoke() {
        if (this.timeoutScheduler != null) {
            this.timeoutScheduler.stop();
        }
        if (this._owner_.clientCallback != null && !this._owner_.commandCallback.isDone()) {
            this._owner_.commandCallback.done();
            if (this._owner_.commandCallback.getAttempt() < GetSsoTokenProcessor.MAX_REQUEST_ATTEMPTS) {
                this._owner_.logger.warning("GetSsoTokenProcessor. Attempt " + (this._owner_.commandCallback.getAttempt() + 1).toString() + " caused by timeout");
                this._owner_.sendCommand(this._owner_.commandCallback.getAttempt() + 1);
            }
            else {
                this._owner_.logger.error("Get SSO Token time out occurs");
                this._owner_.unsubscribeOnRequiredMessages();
                EventManager.getLogger().performance(this._owner_.commandCallback.getEvent());
                this._owner_.clientCallback.onError("Get SSO Token time out occurs");
            }
        }
    }
    setScheduler(timeoutScheduler) {
        this.timeoutScheduler = timeoutScheduler;
    }
}
GetSsoTokenProcessor.CommandStatusListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccess(message) {
        return void(0);
    }
    onError(error) {
        if (this._owner_.commandCallback != null && !this._owner_.commandCallback.isDone()) {
            this._owner_.commandCallback.done();
            if (this._owner_.commandCallback.getAttempt() < GetSsoTokenProcessor.MAX_REQUEST_ATTEMPTS) {
                this._owner_.logger.warning("GetSsoTokenProcessor. Next attempt " + (this._owner_.commandCallback.getAttempt() + 1).toString() + " caused by " + error);
                this._owner_.delayedCommandRunner.execute();
            }
            else {
                this._owner_.logger.error("GetSsoTokenProcessor. Get SSO Token error: " + error);
                this._owner_.unsubscribeOnRequiredMessages();
                EventManager.getLogger().performance(this._owner_.commandCallback.getEvent());
                this._owner_.clientCallback.onError(error);
            }
        }
    }
    onCancel() {
        return void(0);
    }
}
GetSsoTokenProcessor.DelayedCommandRunner = class {
    delayedScheduler;
    action;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.delayedScheduler = null;
        this.action = null;
    }
    initDelayStart(delayTime) {
        if (delayTime > 0) {
            this.delayedScheduler = scheduler.create(delayTime, this.action);
            this.action.setScheduler(this.delayedScheduler);
        }
    }
    stop() {
        if (this.delayedScheduler != null) {
            this.delayedScheduler.stop();
        }
    }
    execute() {
        if (this.delayedScheduler != null) {
            this.delayedScheduler.startWithDelay();
        }
        else {
            this.action.invoke();
        }
    }
    setAction(action) {
        this.action = action;
    }
}
GetSsoTokenProcessor.DelayedCommandRunnerAction = class {
    scheduler;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.scheduler = null;
    }
    invoke() {
        if (this.scheduler != null) {
            this.scheduler.stop();
        }
        this._owner_.sendCommand(this._owner_.commandCallback.getAttempt() + 1);
    }
    setScheduler(scheduler) {
        this.scheduler = scheduler;
    }
}
