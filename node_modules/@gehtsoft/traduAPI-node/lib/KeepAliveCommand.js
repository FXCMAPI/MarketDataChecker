'use strict';
let CommandStatusPublisher = require('./CommandStatusPublisher.js');
let LogManager = require('./LogManager.js');
let KeepAliveTradingSessionTransportMessageFactory = require('./KeepAliveTradingSessionTransportMessageFactory.js');
let MessageType = require('./MessageType.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let CommonErrorType = require('./CommonErrorType.js');
let LogicErrorMessageBuilder = require('./LogicErrorMessageBuilder.js');
//@@DocBrief("The command for sending a 'keep alive' message")
class KeepAliveCommand {
    session;
    login;
    applicationName;
    messageFactory;
    requestNumberGenerator;
    requestNumber;
    publisher;
    messageExecutor;
    periodInMilliseconds;
    pollingScheduler;
    messageExecutorCallback;
    messageRouter;
    receiveNewMessageListener;
    attempts;
    canceled;
    connectionParameters;
    attemptScheduler;
    keepAliveTransportMessageFactory;
    messageType;
    priceTerminal;
    logger;
    checkRequest;
    constructor() {
        this.receiveNewMessageListener = new KeepAliveCommand.ReceiveNewMessageListener(this);
        this.publisher = new CommandStatusPublisher();
        this.periodInMilliseconds = 60000;
        this.messageExecutorCallback = new KeepAliveCommand.MessageExecutorCallback(this);
        this.canceled = false;
        this.attempts = 0;
        this.keepAliveTransportMessageFactory = this.createKeepAliveTransportMessageFactory();
        this.messageType = this.createMessageType();
        this.priceTerminal = null;
        this.requestNumber = 0;
        this.logger = LogManager.getLogger();
        this.checkRequest = new KeepAliveCommand.CheckRequest(this);
    }
    getCommandName() {
        return "KeepAliveCommand";
    }
    createKeepAliveTransportMessageFactory() {
        return new KeepAliveTradingSessionTransportMessageFactory();
    }
    createMessageType() {
        return MessageType.KeepAlive;
    }
    execute() {
        this.logger.debug("Execute command '" + this.getCommandName() + "'");
        this.canceled = false;
        this.attempts = 0;
        this.messageRouter.subscribeNewMessageReceive(this.messageType, this.receiveNewMessageListener);
        this.pollingScheduler.startImmediately();
    }
    stop() {
        this.logger.debug("Stop command '" + this.getCommandName() + "'");
        this.messageExecutor.cancel();
        this.canceled = true;
        this.messageRouter.unsubscribeNewMessageReceive(this.messageType, this.receiveNewMessageListener);
        if (this.pollingScheduler != null) {
            this.pollingScheduler.stop();
        }
        if (this.attemptScheduler != null) {
            this.attemptScheduler.stop();
        }
    }
    subscribeStatusChange(callback) {
        this.publisher.subscribe(callback);
    }
    unsubscribeStatusChange(callback) {
        this.publisher.unsubscribe(callback);
    }
    setSession(session) {
        this.session = session;
    }
    createSchedulers() {
        this.pollingScheduler = scheduler.create(this.periodInMilliseconds, new KeepAliveCommand.KeepAliveAction(this));
        this.attemptScheduler = scheduler.create(this.connectionParameters.getResilience().getPeriodInMilliseconds(), new KeepAliveCommand.AttemptAction(this));
    }
}
module.exports = KeepAliveCommand
KeepAliveCommand.CheckRequest = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    isMyRequest(requestId) {
        return true;
    }
}
KeepAliveCommand.KeepAliveAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        let transportMessage;
        if (this._owner_.pollingScheduler != null) {
            this._owner_.pollingScheduler.stop();
            if (!this._owner_.canceled) {
                this._owner_.requestNumber = this._owner_.requestNumberGenerator.getNextRequestNumber();
                transportMessage = this._owner_.keepAliveTransportMessageFactory.create(this._owner_.messageFactory, this._owner_.session, this._owner_.requestNumber, this._owner_.priceTerminal);
                this._owner_.messageExecutor.execute(transportMessage, this._owner_.messageExecutorCallback);
                if (this._owner_.periodInMilliseconds >= 0) {
                    this._owner_.pollingScheduler.startWithDelay();
                }
            }
        }
    }
}
KeepAliveCommand.AttemptAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        if (this._owner_.attemptScheduler != null) {
            this._owner_.attemptScheduler.stop();
            if (!this._owner_.canceled) {
                if (this._owner_.pollingScheduler != null && this._owner_.periodInMilliseconds >= 0) {
                    this._owner_.pollingScheduler.startImmediately();
                }
            }
        }
    }
}
KeepAliveCommand.MessageExecutorCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccessSent() {
        this._owner_.logger.debug("Message '" + this._owner_.getCommandName() + "' successfully sent");
        this._owner_.attempts = 0;
    }
    onError(error) {
        this._owner_.pollingScheduler.stop();
        this._owner_.attempts = this._owner_.attempts + 1;
        if (this._owner_.attempts > this._owner_.connectionParameters.getResilience().getAttempts()) {
            this._owner_.logger.error("Send message '" + this._owner_.getCommandName() + "' failed: " + error);
            this._owner_.attempts = 0;
            this._owner_.messageRouter.unsubscribeNewMessageReceive(this._owner_.messageType, this._owner_.receiveNewMessageListener);
            this._owner_.publisher.notifyError(error);
        }
        else {
            this._owner_.logger.warning("Send message '" + this._owner_.getCommandName() + "' failed: " + error);
            if (this._owner_.attemptScheduler != null) {
                this._owner_.attemptScheduler.startWithDelay();
            }
        }
    }
}
KeepAliveCommand.ReceiveNewMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        let keepAliveMessage, error, messages, logicErrorMessageBuilder;
        this._owner_.logger.debug(this._owner_.getCommandName() + ". Receive message: " + message.getType());
        if (message.getType() == this._owner_.messageType) {
            keepAliveMessage = message;
            if (this._owner_.checkRequest.isMyRequest(keepAliveMessage.getRequestId())) {
                error = keepAliveMessage.getError();
                if (error != null) {
                    this._owner_.pollingScheduler.stop();
                    this._owner_.messageRouter.unsubscribeNewMessageReceive(this._owner_.messageType, this._owner_.receiveNewMessageListener);
                    if (error == CommonErrorType.SessionExpired) {
                        this._owner_.logger.warning(this._owner_.getCommandName() + ". Session expired");
                        this._owner_.publisher.notifyError(error);
                    }
                    else {
                        messages = new Array(1);
                        logicErrorMessageBuilder = new LogicErrorMessageBuilder();
                        logicErrorMessageBuilder.setError(error);
                        messages[0] = logicErrorMessageBuilder.build();
                        this._owner_.logger.error(this._owner_.getCommandName() + ". Error: " + error);
                        this._owner_.messageRouter.publishNewMessage(messages);
                    }
                }
            }
        }
        else {
            this._owner_.messageRouter.unsubscribeNewMessageReceive(this._owner_.messageType, this._owner_.receiveNewMessageListener);
            this._owner_.publisher.notifyError("Unexpected message type: " + message.getType());
        }
    }
}
