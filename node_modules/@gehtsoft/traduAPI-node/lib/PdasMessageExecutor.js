'use strict';
let LogManager = require('./LogManager.js');
let httpCommunicator = require('@gehtsoft/LuaxStdlib-node').httpCommunicator;
let httpResponseCallback = require('@gehtsoft/LuaxStdlib-node').httpResponseCallback;
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
//@@DocBrief("The class for providing functionality of the message executor over PDAS")
class PdasMessageExecutor {
    communicator;
    messageParser;
    messageRouter;
    logger;
    httpPdasCommunicatorFactory;
    constructor() {
        this.communicator = null;
        this.logger = LogManager.getLogger();
    }
    execute(transportMessage, listener) {
        let pdasTransportMessage, pdasCommunicator, responseCallback;
        this.logger.debug("PdasMessageExecutor. Execute " + transportMessage.getType());
        pdasTransportMessage = transportMessage;
        if (this.communicator == null) {
            this.communicator = new httpCommunicator();
        }
        responseCallback = new PdasMessageExecutor.ResponseCallback(this);
        responseCallback.setRequestType(transportMessage.getType());
        responseCallback.setListener(listener);
        pdasCommunicator = this.httpPdasCommunicatorFactory.createHttpPdasCommunicator(this.communicator);
        pdasCommunicator.sendMessage(pdasTransportMessage.getUrl(), pdasTransportMessage.getXmlBody(), responseCallback);
    }
    cancel() {
        this.communicator.cancel();
    }
    setHttpPdasExecutorFactory(httpPdasCommunicatorFactory) {
        this.httpPdasCommunicatorFactory = httpPdasCommunicatorFactory;
    }
    setHttpExecutor(communicator) {
        this.communicator = communicator;
    }
    setMessageParser(messageParser) {
        this.messageParser = messageParser;
    }
    setMessageRouter(messageRouter) {
        this.messageRouter = messageRouter;
    }
}
module.exports = PdasMessageExecutor
PdasMessageExecutor.ResponseCallback = class extends httpResponseCallback {
    requestType;
    listener;
    _owner_;
    constructor(_owner_) {
        super();
        this._owner_ = _owner_;
    }
    onComplete(status, responseText) {
        let messages, messagesLength, ex;
        this._owner_.logger.debug("PdasMessageExecutor. Complete (" + this.requestType + ") status: " + (status).toString());
        if (status == 200) {
            this.listener.onSuccessSent();
            try {
                this._owner_.logger.debug("PdasMessageExecutor. Parse response (" + this.requestType + ")");
                messages = this._owner_.messageParser.parse(this.requestType, responseText);
                messagesLength = 0;
                if (messages != null) {
                    messagesLength = messages.length;
                }
                this._owner_.logger.debug("PdasMessageExecutor. Publish parsed messages (" + this.requestType + ") count: " + (messagesLength).toString());
                this._owner_.messageRouter.publishNewMessage(messages);
            } catch(exTemp1) {
                ex = stdlib.ensureException(exTemp1);
                this._owner_.logger.error("PdasMessageExecutor. Parse response (" + this.requestType + ") error: " + ex.getMessage());
                this.onError(ex.getMessage());
            }
        }
        else {
            this._owner_.logger.error("PdasMessageExecutor. Failed (" + this.requestType + ") error: Unexpected status");
            this.onError("Unexpected status " + (status).toString());
        }
    }
    onError(error) {
        this._owner_.logger.warning("PdasMessageExecutor. Failed (" + this.requestType + ") error: " + error);
        this.listener.onError(error);
    }
    setRequestType(requestType) {
        this.requestType = requestType;
    }
    setListener(listener) {
        this.listener = listener;
    }
}
