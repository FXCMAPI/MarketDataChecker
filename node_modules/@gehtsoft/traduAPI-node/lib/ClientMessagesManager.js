'use strict';
let CommonPublisher = require('./CommonPublisher.js');
let DataManagerStatePublisher = require('./DataManagerStatePublisher.js');
let ClientMessagesStorage = require('./ClientMessagesStorage.js');
let DataManagerState = require('./DataManagerState.js');
let LogManager = require('./LogManager.js');
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let FXConnectLiteErrorCodes = require('./FXConnectLiteErrorCodes.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let SendClientMessageRequestBuilder = require('./SendClientMessageRequestBuilder.js');
let ClientMessagesMapper = require('./ClientMessagesMapper.js');
let MessageType = require('./MessageType.js');
let UpdateCommandType = require('./UpdateCommandType.js');
class ClientMessagesManager {
    messagesPublisher;
    storage;
    logger;
    messageRouter;
    stateChangePublisher;
    state;
    receiveNewMessageListener;
    commandFactory;
    constructor() {
        this.messagesPublisher = new CommonPublisher();
        this.stateChangePublisher = new DataManagerStatePublisher();
        this.storage = new ClientMessagesStorage();
        this.state = new DataManagerState();
        this.setReceiveNewMessageListener();
        this.logger = LogManager.getLogger();
    }
    static create(messageRouter, commandFactory) {
        let result;
        if (messageRouter == null) {
            LogManager.getLogger().error("ClientMessagesManager.create(): messageRouter is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "messageRouter is not set");
        }
        if (commandFactory == null) {
            LogManager.getLogger().error("ClientMessagesManager.create(): commandFactory is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "commandFactory is not set");
        }
        result = new ClientMessagesManager();
        result.messageRouter = messageRouter;
        result.commandFactory = commandFactory;
        result.subscribeOnRequiredMessages();
        return result;
    }
    sendMessage(sendClientMessageRequest) {
        let sendClientMessageCommand;
        if (sendClientMessageRequest == null) {
            LogManager.getLogger().error("ClientMessagesManager.sendMessage(): sendClientMessageRequest is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "sendClientMessageRequest is not set");
        }
        if (sendClientMessageRequest.getTo() == null || stdlib.len(sendClientMessageRequest.getTo()) == 0) {
            LogManager.getLogger().error("ClientMessagesManager.sendMessage(): sendClientMessageRequest 'To' is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "sendClientMessageRequest 'To' is not set");
        }
        sendClientMessageCommand = this.commandFactory.createSendClientMessageCommand(sendClientMessageRequest);
        sendClientMessageCommand.execute();
    }
    createClientMessageRequestBuilder() {
        return new SendClientMessageRequestBuilder();
    }
    subscribeMessageReceive(listener) {
        if (listener == null) {
            this.logger.error("ClientMessagesManager.subscribeMessageReceive(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.messagesPublisher.subscribe(listener);
    }
    unsubscribeMessageReceive(listener) {
        if (listener == null) {
            this.logger.error("ClientMessagesManager.unsubscribeMessageReceive(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.messagesPublisher.unsubscribe(listener);
    }
    subscribeStateChange(listener) {
        if (listener == null) {
            this.logger.error("ClientMessagesManager.subscribeStateChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.stateChangePublisher.subscribe(listener);
    }
    unsubscribeStateChange(listener) {
        if (listener == null) {
            this.logger.error("ClientMessagesManager.unsubscribeStateChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.stateChangePublisher.unsubscribe(listener);
    }
    getState() {
        return this.state;
    }
    getMessages() {
        let messages, result, i;
        this.logger.info("ClientMessagesManager. Get messages snapshot");
        messages = this.storage.getAllMessages();
        result = new Array(messages.length);
        for (i = 0; i <= messages.length - 1; i += 1) {
            result[i] = ClientMessagesMapper.mapInternalToPublic(messages[i]);
        }
        return result;
    }
    processMessage(message) {
        let updateMessage;
        this.logger.debug("ClientMessagesManager. Receive message: " + message.getType());
        if (message.getType() == MessageType.ClientMessage) {
            updateMessage = message;
            this.processUpdateMessage(updateMessage.getUpdateCommand(), updateMessage.getClientMessage());
        } else if (message.getType() == MessageType.Connected) {
            this.notifyStateChange(DataManagerState.LOADED);
        } else if (message.getType() == MessageType.Disconnected) {
            this.storage.clear();
            this.notifyStateChange(DataManagerState.NOT_LOADED);
        }
    }
    processUpdateMessage(updateType, updMessage) {
        if (updateType == UpdateCommandType.INSERT && updMessage != null) {
            this.storage.addMessage(updMessage);
            this.notifyOnReceive(ClientMessagesMapper.mapInternalToPublic(updMessage));
        }
    }
    notifyStateChange(stateStatus) {
        this.logger.debug("ClientMessagesManager. State status changed: " + (stateStatus).toString());
        this.state.setState(stateStatus);
        this.stateChangePublisher.notifyStateChange(this.state);
    }
    notifyOnReceive(message) {
        this.messagesPublisher.notifyAction(ClientMessagesManager.OnReceiveAction.create(message));
    }
    setReceiveNewMessageListener() {
        this.receiveNewMessageListener = ClientMessagesManager.ReceiveNewMessageListener.create(this);
    }
    subscribeOnRequiredMessages() {
        this.messageRouter.subscribeNewMessageReceive(MessageType.Connected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.ClientMessage, this.receiveNewMessageListener);
    }
}
module.exports = ClientMessagesManager
ClientMessagesManager.OnReceiveAction = class {
    listener;
    message;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(message) {
        let result;
        result = new ClientMessagesManager.OnReceiveAction(this);
        result.message = message;
        return result;
    }
    setListener(listener) {
        this.listener = listener;
    }
    execute() {
        this.listener.onReceive(this.message);
    }
}
ClientMessagesManager.ReceiveNewMessageListener = class {
    owner;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(owner) {
        let instance;
        instance = new ClientMessagesManager.ReceiveNewMessageListener(this);
        instance.owner = owner;
        return instance;
    }
    onNewMessageReceive(message) {
        this.owner.processMessage(message);
    }
}
