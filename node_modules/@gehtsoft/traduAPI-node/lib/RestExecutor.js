'use strict';
let LogManager = require('./LogManager.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let httpCommunicator = require('@gehtsoft/LuaxStdlib-node').httpCommunicator;
let httpResponseCallback = require('@gehtsoft/LuaxStdlib-node').httpResponseCallback;
class RestExecutor {
    communicator;
    logger;
    responseCallback;
    timeoutScheduler;
    timeoutInterval;
    constructor() {
        this.communicator = null;
        this.responseCallback = null;
        this.timeoutScheduler = null;
        this.timeoutInterval = 10000;
        this.logger = LogManager.getLogger();
    }
    setTimeoutInterval(timeoutInterval) {
        this.timeoutInterval = timeoutInterval;
    }
    setHttpCommunicator(communicator) {
        this.communicator = communicator;
    }
    createSchedulers() {
        if (this.timeoutScheduler == null) {
            this.timeoutScheduler = scheduler.create(this.timeoutInterval, new RestExecutor.TimeoutAction(this));
        }
    }
    execute(url, listener) {
        this.logger.debug("RestExecutor. Execute " + url);
        this.createSchedulers();
        if (this.communicator == null) {
            this.communicator = new httpCommunicator();
        }
        this.responseCallback = new RestExecutor.ResponseCallback(this);
        this.responseCallback.setListener(listener);
        this.timeoutScheduler.startWithDelay();
        this.communicator.get(url, this.responseCallback);
    }
    stop() {
        if (this.timeoutScheduler != null) {
            this.timeoutScheduler.stop();
        }
        this.timeoutScheduler = null;
    }
}
module.exports = RestExecutor
RestExecutor.TimeoutAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        this._owner_.stop();
        this._owner_.responseCallback.onError("Command execution timeout");
    }
}
RestExecutor.ResponseCallback = class extends httpResponseCallback {
    listener;
    _owner_;
    constructor(_owner_) {
        super();
        this._owner_ = _owner_;
    }
    onComplete(status, responseText) {
        this._owner_.logger.debug("RestExecutor. Complete status: " + (status).toString());
        if (status == 200) {
            this._owner_.stop();
            this.listener.onSuccessSent(responseText);
        }
        else {
            this._owner_.logger.error("RestExecutor. Failed error: Unexpected status");
            this._owner_.stop();
            this.onError("Unexpected status " + (status).toString());
        }
    }
    onError(error) {
        this._owner_.logger.warning("RestExecutor. Failed error: " + error);
        this._owner_.stop();
        this.listener.onError(error);
    }
    setListener(listener) {
        this.listener = listener;
    }
}
