'use strict';
let DxFeedHeartbeatDataReader = require('./DxFeedHeartbeatDataReader.js');
let LogManager = require('./LogManager.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
class DxFeedHeartbeatCommand {
    clientId;
    heartbeatInterval;
    socketCommunicator;
    dXFeedMessageFactory;
    socketReceiveMessageListener;
    callback;
    heartbeatScheduler;
    canceled;
    reader;
    logger;
    constructor() {
        this.socketCommunicator = null;
        this.callback = null;
        this.clientId = "";
        this.heartbeatInterval = 5000;
        this.canceled = false;
        this.socketReceiveMessageListener = new DxFeedHeartbeatCommand.SocketReceiveMessageListener(this);
        this.reader = new DxFeedHeartbeatDataReader();
        this.logger = LogManager.getLogger();
    }
    static create(socketCommunicator, dXFeedMessageFactory, callback, clientId, heartbeatInterval) {
        let result;
        result = new DxFeedHeartbeatCommand();
        result.socketCommunicator = socketCommunicator;
        result.dXFeedMessageFactory = dXFeedMessageFactory;
        result.callback = callback;
        result.clientId = clientId;
        if (heartbeatInterval > 0) {
            result.heartbeatInterval = heartbeatInterval;
        }
        result.createSchedulers();
        return result;
    }
    execute() {
        this.logger.debug("Start command 'DxFeedHeartbeatCommand'");
        this.socketCommunicator.subscribeJsonReceive(this.socketReceiveMessageListener);
        this.heartbeatScheduler.startImmediately();
    }
    stop() {
        this.logger.debug("Stop command 'DxFeedHeartbeatCommand'");
        this.canceled = true;
        this.socketCommunicator.unsubscribeJsonReceive(this.socketReceiveMessageListener);
        if (this.heartbeatScheduler != null) {
            this.heartbeatScheduler.stop();
        }
    }
    processMessage(json) {
        let data, ex;
        try {
            data = this.reader.read(json);
            if (data != null) {
                if (!data.getSuccessful()) {
                    this.heartbeatScheduler.stop();
                    this.socketCommunicator.unsubscribeJsonReceive(this.socketReceiveMessageListener);
                    this.callback.onError(data.getError());
                }
                else {
                    this.socketCommunicator.send(this.dXFeedMessageFactory.createHeartbeatMessage(this.clientId));
                }
            }
        } catch(exTemp1) {
            ex = stdlib.ensureException(exTemp1);
            this.logger.error("can not process DxFeedHeartbeat response: " + ex.getMessage());
        }
    }
    createSchedulers() {
        this.heartbeatScheduler = scheduler.create(this.heartbeatInterval, new DxFeedHeartbeatCommand.HeartbeatAction(this));
    }
}
module.exports = DxFeedHeartbeatCommand
DxFeedHeartbeatCommand.HeartbeatAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        if (this._owner_.heartbeatScheduler != null) {
            if (!this._owner_.canceled) {
                this._owner_.socketCommunicator.send(this._owner_.dXFeedMessageFactory.createHeartbeatMessage(this._owner_.clientId));
            }
        }
    }
}
DxFeedHeartbeatCommand.SocketReceiveMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onReceive(json) {
        this._owner_.processMessage(json);
    }
}
