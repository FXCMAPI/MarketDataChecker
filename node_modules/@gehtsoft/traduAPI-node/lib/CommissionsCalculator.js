'use strict';
let Instrument = require('./Instrument.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
class CommissionsCalculator {
    storage;
    internalOffersProvider;
    unitCostCalculator;
    instrumentsProvider;
    instrument;
    toAccountCCYConverter;
    systemSettingsProvider;
    static create(storage, internalOffersProvider, unitCostCalculator, instrumentsProvider, toAccountCCYConverter, systemSettingsProvider) {
        let commissionsCalculator;
        commissionsCalculator = new CommissionsCalculator();
        commissionsCalculator.storage = storage;
        commissionsCalculator.internalOffersProvider = internalOffersProvider;
        commissionsCalculator.unitCostCalculator = unitCostCalculator;
        commissionsCalculator.instrumentsProvider = instrumentsProvider;
        commissionsCalculator.toAccountCCYConverter = toAccountCCYConverter;
        commissionsCalculator.systemSettingsProvider = systemSettingsProvider;
        return commissionsCalculator;
    }
    getOpenCommission(offer, account, amount, isBuy, rate) {
        return this.getCommonCommission(offer, account, amount, isBuy, rate, "O");
    }
    getCloseCommission(offer, account, amount, isBuy, rate) {
        return this.getCommonCommission(offer, account, amount, isBuy, rate, "C");
    }
    getCommonCommission(offer, account, amount, isBuy, rate, what) {
        let commList, offerId, calculator, instrumentType;
        if (offer == null || account == null) {
            return 0.0;
        }
        offerId = offer.getOfferId();
        this.instrument = this.instrumentsProvider.getInstrumentByOfferId(offerId);
        if (this.instrument == null) {
            return 0.0;
        }
        instrumentType = this.instrument.getInstrumentType();
        if (instrumentType == Instrument.TYPE_FOREX) {
            calculator = new CommissionsCalculator.ForexCalculator(this);
        } else if (instrumentType == Instrument.TYPE_COMMODITY || instrumentType == Instrument.TYPE_INDICES || instrumentType == Instrument.TYPE_BULLION || instrumentType == Instrument.TYPE_SHARES || instrumentType == Instrument.TYPE_TREASURY || instrumentType == Instrument.TYPE_FXINDEX || instrumentType == Instrument.TYPE_CRYPTOCURRENCY) {
            calculator = new CommissionsCalculator.CfdCalculator(this);
        } else if (instrumentType == Instrument.TYPE_CFD_SHARES) {
            calculator = new CommissionsCalculator.CfdSharesCalculator(this);
        }         else {
            return 0.0;
        }
        commList = this.storage.findAccountCommissions(account.getAccountId(), offerId);
        return calculator.calculateAggregatedCommissionForTrade(commList, what, amount, isBuy, offer, rate, account);
    }
    getConversationRate(offer, account) {
        let bidAsk, averageRate, instrument;
        instrument = this.instrumentsProvider.getInstrumentByOfferId(offer.getOfferId());
        bidAsk = this.internalOffersProvider.calculateBidAsk(offer);
        averageRate = stdlib.roundInl((bidAsk.getAsk() + bidAsk.getBid()) / 2, instrument.getDigits());
        return this.unitCostCalculator.calculate(account.getAccountId(), account.getLeverageProfileId(), offer.getOfferId(), averageRate);
    }
}
module.exports = CommissionsCalculator
CommissionsCalculator.BaseCalculator = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    calculateAggregatedCommissionForTrade(commList, calculateStage, amount, isBuy, offer, rate, account) {
        let dAggregatedCommission, i, accountCommission, commissionStage, unitType, lType, commissionPerOrder, commissionPerOrderConv, iPrecisionDigits;
        dAggregatedCommission = 0.0;
        iPrecisionDigits = account.getBaseCurrencyPrecision();
        if (commList != null) {
            for (i = 0; i <= commList.length - 1; i += 1) {
                accountCommission = commList[i];
                commissionStage = accountCommission.getComStageString();
                unitType = accountCommission.getComTypeString();
                lType = accountCommission.getLType();
                commissionPerOrder = this.isCommissionPerOrder(unitType, lType);
                commissionPerOrderConv = this.isCommissionPerOrderConv(unitType, lType);
                if (!this.checkCalculateStage(commissionPerOrder, commissionPerOrderConv, calculateStage, commissionStage)) {
                    continue;
                }
                dAggregatedCommission = dAggregatedCommission + this.calcCommission(accountCommission, calculateStage, isBuy, amount, offer, rate, account);
                dAggregatedCommission = stdlib.roundInl(dAggregatedCommission, iPrecisionDigits);
            }
        }
        return dAggregatedCommission;
    }
    checkCalculateStage(commissionPerOrder, commissionPerOrderConv, calculateStage, commissionStage) {
        if (!commissionPerOrder && !commissionPerOrderConv) {
            if (calculateStage == "O") {
                if (commissionStage != "O" && commissionStage != "D") {
                    return false;
                }
            } else if (calculateStage == "C") {
                if (commissionStage != "C" && commissionStage != "D") {
                    return false;
                }
            }
        }
        return true;
    }
    isCommissionPerOrder(unitType, lType) {
        return unitType == "T" && lType == 9;
    }
    isCommissionPerOrderConv(unitType, lType) {
        return unitType == "C" && lType != 8;
    }
    getPerOrderPerTrade(comType, lType) {
        let commissionPerOrder, commissionPerTrade;
        commissionPerOrder = false;
        commissionPerTrade = false;
        if (comType == "T") {
            if (lType == 9) {
                commissionPerOrder = true;
            }
            else {
                commissionPerTrade = true;
            }
        }
        return [commissionPerOrder, commissionPerTrade];
    }
    validateCommissionStage(calculateStage, commissionStage, commissionPerOrder, commissionPerOrderConv) {
        if (commissionStage != "D" && !commissionPerOrder && !commissionPerOrderConv) {
            if (calculateStage == "O" && commissionStage != "O") {
                return false;
            }
            if (calculateStage == "C" && commissionStage != "C") {
                return false;
            }
        }
        return true;
    }
    calcCommission(commission, calculateStage, isBuy, amount, offer, rate, account) {
        let commissionStage, comType, dPositionSize, commissionPerOrder, commissionPerOrderConv, commissionPerTrade, dCommValue, dMinCommCharge, dConversionRate, iPrecisionDigits, needMinCommission, lType, tres;
        commissionStage = commission.getComStageString();
        comType = commission.getComTypeString();
        lType = commission.getLType();
        tres = this.getPerOrderPerTrade(comType, lType);
        commissionPerOrder = tres[0];
        commissionPerTrade = tres[1];
        commissionPerOrderConv = comType == "C" && lType != 8;
        dPositionSize = amount;
        if (!this.validateCommissionStage(calculateStage, commissionStage, commissionPerOrder, commissionPerOrderConv)) {
            return 0.0;
        }
        dCommValue = this._owner_.toAccountCCYConverter.convert(this._owner_.systemSettingsProvider.getBaseCurrency(), commission.getRebateAmount(), account, "CommissionsCalculator.calcCommission()");
        dMinCommCharge = this._owner_.toAccountCCYConverter.convert(this._owner_.systemSettingsProvider.getBaseCurrency(), commission.getMinCharge(), account, "CommissionsCalculator.calcCommission()");
        dConversionRate = this._owner_.getConversationRate(offer, account);
        iPrecisionDigits = account.getBaseCurrencyPrecision();
        needMinCommission = false;
        if (comType == "L") {
            dCommValue = dCommValue * dPositionSize;
        } else if (!(commissionPerTrade || commissionPerOrder)) {
            if (commissionPerOrderConv) {
                needMinCommission = true;
                dCommValue = dCommValue * dConversionRate;
                dMinCommCharge = dMinCommCharge * dConversionRate;
            }
            else {
                return 0.0;
            }
        }
        if (commissionStage == "D" && !commissionPerOrder && !commissionPerOrderConv) {
            dCommValue = dCommValue / 2;
            dMinCommCharge = dMinCommCharge / 2;
        }
        if (needMinCommission && dCommValue < dMinCommCharge) {
            dCommValue = dMinCommCharge;
        }
        return stdlib.roundInl(dCommValue, iPrecisionDigits);
    }
}
CommissionsCalculator.ForexCalculator = class extends CommissionsCalculator.BaseCalculator {
    _owner_;
    constructor(_owner_) {
        super();
        this._owner_ = _owner_;
    }
}
CommissionsCalculator.CfdCalculator = class extends CommissionsCalculator.BaseCalculator {
    _owner_;
    constructor(_owner_) {
        super();
        this._owner_ = _owner_;
    }
}
CommissionsCalculator.CfdSharesCalculator = class extends CommissionsCalculator.BaseCalculator {
    _owner_;
    constructor(_owner_) {
        super();
        this._owner_ = _owner_;
    }
    getPerConv(comType, lType) {
        let commissionPerOrderConv, commissionPerLotConv;
        commissionPerOrderConv = false;
        commissionPerLotConv = false;
        if (comType == "C") {
            if (lType != 8) {
                commissionPerOrderConv = true;
            }
            else {
                commissionPerLotConv = true;
            }
        }
        return [commissionPerOrderConv, commissionPerLotConv];
    }
    calcCommission(commission, calculateStage, isBuy, amount, offer, rate, account) {
        let commissionStage, comType, dPositionSize, commissionPerOrder, commissionPerOrderConv, commissionPerTrade, commissionPerLotConv, dCommValue, dTableCommValue, dMinCommCharge, dConversionRate, iPrecisionDigits, needMinCommission, lType, tres, rres;
        commissionStage = commission.getComStageString();
        comType = commission.getComTypeString();
        lType = commission.getLType();
        tres = this.getPerOrderPerTrade(comType, lType);
        commissionPerOrder = tres[0];
        commissionPerTrade = tres[1];
        tres = this.getPerConv(comType, lType);
        commissionPerOrderConv = tres[0];
        commissionPerLotConv = tres[1];
        if (!this.validateCommissionStage(calculateStage, commissionStage, commissionPerOrder, commissionPerOrderConv)) {
            return 0.0;
        }
        dTableCommValue = this._owner_.toAccountCCYConverter.convert(this._owner_.systemSettingsProvider.getBaseCurrency(), commission.getRebateAmount(), account, "CommissionsCalculator.calcCommission2()");
        if (dTableCommValue == 0.0) {
            return 0.0;
        }
        dMinCommCharge = this._owner_.toAccountCCYConverter.convert(this._owner_.systemSettingsProvider.getBaseCurrency(), commission.getMinCharge(), account, "CommissionsCalculator.calcCommission2()");
        dConversionRate = this._owner_.getConversationRate(offer, account);
        dPositionSize = amount;
        if ((calculateStage == "O" || calculateStage != "C") && commissionStage == "D" && !commissionPerOrder && !commissionPerOrderConv) {
            dTableCommValue = dTableCommValue / 2;
            dMinCommCharge = dMinCommCharge / 2;
        }
        dCommValue = 0.0;
        needMinCommission = false;
        if (comType == "L") {
            dCommValue = dTableCommValue * dPositionSize;
        } else if (commissionPerLotConv) {
            needMinCommission = true;
            dCommValue = dTableCommValue * dPositionSize;
            rres = this.processConv(offer, dCommValue, dConversionRate, dMinCommCharge);
            dCommValue = rres[0];
            dMinCommCharge = rres[1];
        } else if (commissionPerTrade) {
            dCommValue = dTableCommValue;
        } else if (commissionPerOrder) {
            dCommValue = dTableCommValue;
        } else if (commissionPerOrderConv) {
            needMinCommission = true;
            dCommValue = dTableCommValue;
            rres = this.processConv(offer, dCommValue, dConversionRate, dMinCommCharge);
            dCommValue = rres[0];
            dMinCommCharge = rres[1];
        } else if (comType == "B") {
            needMinCommission = true;
            rres = this.processComTypeB(rate, calculateStage, offer, [dTableCommValue, dPositionSize, dMinCommCharge, dConversionRate], isBuy);
            dCommValue = rres[0];
            dMinCommCharge = rres[1];
        }         else {
            return 0.0;
        }
        iPrecisionDigits = account.getBaseCurrencyPrecision();
        dCommValue = stdlib.roundInl(dCommValue, iPrecisionDigits);
        if (needMinCommission && dCommValue < dMinCommCharge) {
            dCommValue = dMinCommCharge;
        }
        return stdlib.roundInl(dCommValue, iPrecisionDigits);
    }
    processConv(offer, dCommValue, dConversionRate, dMinCommCharge) {
        let ddCommValue, ddMinCommCharge;
        ddCommValue = dCommValue * dConversionRate;
        ddMinCommCharge = dMinCommCharge * dConversionRate;
        return [ddCommValue, ddMinCommCharge];
    }
    processComTypeB(rate, calculateStage, offer, params, isBuy) {
        let dContractMultiplier, dRate, dCommValue, dTableCommValue, dPositionSize, dMinCommCharge, dConversionRate;
        dContractMultiplier = this._owner_.instrument.getContractMultiplier();
        dRate = rate;
        dTableCommValue = params[0];
        dPositionSize = params[1];
        dMinCommCharge = params[2];
        dConversionRate = params[3];
        if (dRate == 0.0) {
            if (calculateStage == "O") {
                if (isBuy) {
                    dRate = offer.getAsk();
                }
                else {
                    dRate = offer.getBid();
                }
            } else if (calculateStage == "C") {
                if (isBuy) {
                    dRate = offer.getBid();
                }
                else {
                    dRate = offer.getAsk();
                }
            }
        }
        dCommValue = dTableCommValue * dPositionSize * dContractMultiplier * dRate;
        dCommValue = dCommValue * dConversionRate;
        dMinCommCharge = dMinCommCharge * dConversionRate;
        return [dCommValue, dMinCommCharge];
    }
}
