'use strict';
let string_map = require('@gehtsoft/LuaxStdlib-node').string_map;
let list = require('@gehtsoft/LuaxStdlib-node').list;
let LogManager = require('./LogManager.js');
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let FXConnectLiteErrorCodes = require('./FXConnectLiteErrorCodes.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
class PriceTerminalsManager {
    static get NO_PRICE_STREAM_ID_KEY() { return "noPriceStreamIdKey"; }
    static get NO_MDT_ID_KEY() { return "noMdtIdKey"; }
    mapByStreamId;
    mapByMdtId;
    listeners;
    constructor() {
        this.mapByStreamId = new string_map();
        this.mapByMdtId = new string_map();
        this.listeners = new list();
    }
    subscribeConnectionStatusChange(listener) {
        if (listener == null) {
            LogManager.getLogger().error("PriceTerminalsManager.subscribeConnectionStatusChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.listeners.add(listener);
    }
    unsubscribeConnectionStatusChange(listener) {
        let i, current;
        if (listener == null) {
            LogManager.getLogger().error("PriceTerminalsManager.subscribeConnectionStatusChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        for (i = 0; i <= this.listeners.length() - 1; i += 1) {
            current = this.listeners.get(i);
            if (listener == current) {
                this.listeners.remove(i);
                break;
            }
        }
    }
    getAllMdtSessions() {
        let result, i, keys;
        keys = this.mapByMdtId.keys();
        result = new Array(keys.length);
        for (i = 0; i <= keys.length - 1; i += 1) {
            result[i] = this.mapByMdtId.get(keys[i]);
        }
        return result;
    }
    getMdtSessionById(id) {
        let key;
        key = id;
        if (id == null || stdlib.len(id) == 0) {
            key = PriceTerminalsManager.NO_MDT_ID_KEY;
        }
        if (this.mapByMdtId.contains(key)) {
            return this.mapByMdtId.get(key);
        }
        return null;
    }
    getPriceTerminalInitializer(streamId) {
        let key;
        key = streamId;
        if (streamId == null || stdlib.len(streamId) == 0) {
            key = PriceTerminalsManager.NO_PRICE_STREAM_ID_KEY;
        }
        if (this.mapByStreamId.contains(key)) {
            return this.mapByStreamId.get(key);
        }
        return null;
    }
    addPriceTerminalInitializer(streams, priceTerminalInitializer, addToMdtMap) {
        let i, connectionStatusChangeListener;
        connectionStatusChangeListener = new PriceTerminalsManager.ConnectionStatusChangeListener(this);
        connectionStatusChangeListener.setMdtId(priceTerminalInitializer.getMdtId());
        if (addToMdtMap) {
            this.mapByMdtId.set(priceTerminalInitializer.getMdtId(), priceTerminalInitializer);
        }
        priceTerminalInitializer.subscribeConnectionStatusChange(connectionStatusChangeListener);
        if (streams == null || streams.length == 0) {
            this.mapByStreamId.set(PriceTerminalsManager.NO_PRICE_STREAM_ID_KEY, priceTerminalInitializer);
        }
        else {
            for (i = 0; i <= streams.length - 1; i += 1) {
                this.mapByStreamId.set(streams[i], priceTerminalInitializer);
            }
        }
    }
}
module.exports = PriceTerminalsManager
PriceTerminalsManager.ConnectionStatusChangeListener = class {
    mdtId;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onConnectionStatusChange(status) {
        let i;
        for (i = 0; i <= this._owner_.listeners.length() - 1; i += 1) {
            this._owner_.listeners.get(i).onConnectionStatusChange(this.mdtId, status);
        }
    }
    setMdtId(mdtId) {
        this.mdtId = mdtId;
    }
}
