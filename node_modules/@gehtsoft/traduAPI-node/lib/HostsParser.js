'use strict';
let xmlParser = require('@gehtsoft/LuaxStdlib-node').xmlParser;
let TerminalFactory = require('./TerminalFactory.js');
let TerminalUrlFactory = require('./TerminalUrlFactory.js');
let TradingTerminalFactory = require('./TradingTerminalFactory.js');
let XmlReaderUtil = require('./XmlReaderUtil.js');
let HostsParserResponseBuilder = require('./HostsParserResponseBuilder.js');
let TerminalType = require('./TerminalType.js');
let TerminalStatus = require('./TerminalStatus.js');
let list = require('@gehtsoft/LuaxStdlib-node').list;
//@@DocBrief("The parser for Hosts.jsp")
class HostsParser {
    parse(xml, connection) {
        let parser, root, i, terminalsList, node, chartTerminal, priceTerminal, terminalFactory, terminalUrlFactory, tradingTerminalFactory, errorText, connectionFound, responseBuilder, terminals;
        terminalsList = new HostsParser.tradingTerminalsList(this);
        parser = new xmlParser();
        root = parser.parse(xml);
        terminalFactory = new TerminalFactory();
        terminalUrlFactory = new TerminalUrlFactory();
        tradingTerminalFactory = new TradingTerminalFactory();
        chartTerminal = null;
        priceTerminal = null;
        connectionFound = false;
        errorText = null;
        for (i = 0; i <= root.getChildrenCount() - 1; i += 1) {
            node = root.getChild(i);
            if (XmlReaderUtil.isAttrEqualTo(node, "type", "trading")) {
                priceTerminal = this.buildTerminalByAttr(node, "price_terminal", root, terminalFactory, terminalUrlFactory);
                chartTerminal = this.buildTerminalByAttr(node, "chart_terminal", root, terminalFactory, terminalUrlFactory);
                terminalsList.add(HostsParser.tradingTerminalsListItem.create(this.createTradingTerminal(node, tradingTerminalFactory, terminalUrlFactory, priceTerminal, chartTerminal)));
            } else if (XmlReaderUtil.isAttrEqualTo(node, "type", "global") && XmlReaderUtil.isAttrEqualTo(node, "name", connection)) {
                connectionFound = true;
                if (!XmlReaderUtil.isAttrEqualTo(node, "status", "active")) {
                    errorText = XmlReaderUtil.getAttrValue(node, "inactive_text");
                }
            }
        }
        if (!connectionFound) {
            if (terminalsList.length() > 0) {
                errorText = "INCORRECT_CONNECTION";
            }
            else {
                errorText = "INCORRECT_CREDENTIALS";
            }
        }
        responseBuilder = new HostsParserResponseBuilder();
        terminals = terminalsList.toArray();
        responseBuilder.setTerminals(terminals);
        responseBuilder.setError(errorText);
        return responseBuilder.build();
    }
    buildTerminalByAttr(node, attrName, root, terminalFactory, terminalUrlFactory) {
        let dependentNode, attr;
        attr = node.getAttributeByName(attrName);
        if (attr != null) {
            dependentNode = this.findNodeByName(attr.getValue(), root);
            if (dependentNode != null) {
                return this.createTerminal(dependentNode, terminalFactory, terminalUrlFactory);
            }
        }
        return null;
    }
    createTerminal(node, terminalFactory, terminalUrlFactory) {
        let attr, type, name, status, inactiveText, urls;
        type = "";
        name = "";
        status = "";
        inactiveText = "";
        attr = node.getAttributeByName("type");
        if (attr != null) {
            type = attr.getValue();
            if (type == "trading") {
                type = TerminalType.TRADING;
            } else if (type == "price") {
                type = TerminalType.PRICE;
            } else if (type == "chart") {
                type = TerminalType.CHART;
            } else if (type == "global") {
                type = TerminalType.GLOBAL;
            }
        }
        attr = node.getAttributeByName("name");
        if (attr != null) {
            name = attr.getValue();
        }
        attr = node.getAttributeByName("status");
        if (attr != null) {
            status = attr.getValue();
            if (status == "active") {
                status = TerminalStatus.ACTIVE;
            }
            else {
                status = TerminalStatus.INACTIVE;
            }
        }
        attr = node.getAttributeByName("inactive_text");
        if (attr != null) {
            inactiveText = attr.getValue();
        }
        urls = this.getUrls(node, terminalUrlFactory);
        return terminalFactory.createTerminal(type, name, status, inactiveText, urls);
    }
    createTradingTerminal(node, tradingTerminalFactory, terminalUrlFactory, priceTerminal, chartTerminal) {
        let attr, type, name, status, inactiveText, urls, id, subid, description, salt;
        name = "";
        status = "";
        inactiveText = "";
        id = "";
        subid = "";
        description = "";
        salt = "";
        type = TerminalType.TRADING;
        attr = node.getAttributeByName("name");
        if (attr != null) {
            name = attr.getValue();
        }
        attr = node.getAttributeByName("status");
        if (attr != null) {
            status = attr.getValue();
            if (status == "active") {
                status = TerminalStatus.ACTIVE;
            }
            else {
                status = TerminalStatus.INACTIVE;
            }
        }
        attr = node.getAttributeByName("inactive_text");
        if (attr != null) {
            inactiveText = attr.getValue();
        }
        attr = node.getAttributeByName("id");
        if (attr != null) {
            id = attr.getValue();
        }
        attr = node.getAttributeByName("subid");
        if (attr != null) {
            subid = attr.getValue();
        }
        attr = node.getAttributeByName("description");
        if (attr != null) {
            description = attr.getValue();
        }
        attr = node.getAttributeByName("S");
        if (attr != null) {
            salt = attr.getValue();
        }
        urls = this.getUrls(node, terminalUrlFactory);
        return tradingTerminalFactory.createTradingTerminal(type, name, status, inactiveText, urls, id, subid, description, salt, priceTerminal, chartTerminal);
    }
    getUrls(root, terminalUrlFactory) {
        let urls, urlsTmp, i, j, k, node;
        for (i = 0; i <= root.getChildrenCount() - 1; i += 1) {
            node = root.getChild(i);
            if (node.getName() == "urls") {
                urlsTmp = new Array(node.getChildrenCount());
                k = this.getUrlsInner(node, urlsTmp, terminalUrlFactory);
                urls = new Array(k);
                for (j = 0; j <= k - 1; j += 1) {
                    urls[j] = urlsTmp[j];
                }
                return urls;
            }
        }
        urls = new Array(0);
        return urls;
    }
    getUrlsInner(node, urlsTmp, terminalUrlFactory) {
        let j, k, nodeInner, name, url, protocol, secure, params;
        k = 0;
        for (j = 0; j <= node.getChildrenCount() - 1; j += 1) {
            nodeInner = node.getChild(j);
            if (nodeInner.getName() == "url") {
                secure = false;
                params = "";
                name = this.getAttrStringValue(nodeInner, "name");
                url = this.getAttrStringValue(nodeInner, "urlString");
                protocol = this.getAttrStringValue(nodeInner, "protocol");
                if (this.getAttrStringValue(nodeInner, "secure") == "true") {
                    secure = true;
                }
                params = this.getAttrStringValue(nodeInner, "params");
                urlsTmp[k] = terminalUrlFactory.createTerminalUrl(name, url, protocol, secure, params);
                k = k + 1;
            }
        }
        return k;
    }
    getAttrStringValue(nodeInner, attrName) {
        let attr;
        attr = nodeInner.getAttributeByName(attrName);
        if (attr != null) {
            return attr.getValue();
        }
        return "";
    }
    findNodeByName(name, root) {
        let node, attr, i;
        for (i = 0; i <= root.getChildrenCount() - 1; i += 1) {
            node = root.getChild(i);
            attr = node.getAttributeByName("name");
            if (attr != null) {
                if (attr.getValue() == name) {
                    return node;
                }
            }
        }
        return null;
    }
}
module.exports = HostsParser
HostsParser.tradingTerminalsListItem = class {
    tradingTerminal;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(tradingTerminal) {
        let l;
        l = new HostsParser.tradingTerminalsListItem(this);
        l.tradingTerminal = tradingTerminal;
        return l;
    }
}
HostsParser.tradingTerminalsList = class extends list {
    _owner_;
    constructor(_owner_) {
        super();
        this._owner_ = _owner_;
    }
    get(index) {
        return super.get(index);
    }
    set(index, value) {
        super.set(index, value);
    }
    add(value) {
        super.add(value);
    }
    toArray() {
        let i, result;
        result = new Array(super.length());
        for (i = 0; i <= super.length() - 1; i += 1) {
            result[i] = super.get(i).tradingTerminal;
        }
        return result;
    }
}
