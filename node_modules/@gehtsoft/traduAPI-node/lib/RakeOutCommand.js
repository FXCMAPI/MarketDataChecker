'use strict';
let CommandStatusPublisher = require('./CommandStatusPublisher.js');
let LogManager = require('./LogManager.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
//@@DocBrief("The command for sending 'keep alive' message")
class RakeOutCommand {
    session;
    login;
    applicationName;
    messageFactory;
    requestNumberGenerator;
    publisher;
    messageExecutor;
    periodInMilliseconds;
    pollingScheduler;
    messageExecutorCallback;
    messageRouter;
    attempts;
    canceled;
    connectionParameters;
    attemptScheduler;
    stikingTime;
    logger;
    timeoutInterval;
    timeoutScheduler;
    constructor() {
        this.publisher = new CommandStatusPublisher();
        this.periodInMilliseconds = 60000;
        this.stikingTime = 3000;
        this.messageExecutorCallback = new RakeOutCommand.MessageExecutorCallback(this);
        this.canceled = false;
        this.attempts = 0;
        this.timeoutInterval = 10000;
        this.logger = LogManager.getLogger();
    }
    getCommandName() {
        return "RakeOutCommand";
    }
    getTransportMessage() {
        return this.messageFactory.createRakeOutRequestMessage(this.session, this.stikingTime, this.requestNumberGenerator);
    }
    execute() {
        this.logger.debug("Execute command '" + this.getCommandName() + "'");
        this.canceled = false;
        this.attempts = 0;
        this.pollingScheduler.startImmediately();
    }
    stop() {
        this.logger.debug("Stop command '" + this.getCommandName() + "'");
        this.messageExecutor.cancel();
        this.canceled = true;
        if (this.pollingScheduler != null) {
            this.pollingScheduler.stop();
        }
        if (this.attemptScheduler != null) {
            this.attemptScheduler.stop();
        }
        if (this.timeoutScheduler != null) {
            this.timeoutScheduler.stop();
        }
    }
    subscribeStatusChange(callback) {
        this.publisher.subscribe(callback);
    }
    unsubscribeStatusChange(callback) {
        this.publisher.unsubscribe(callback);
    }
    setSession(session) {
        this.session = session;
    }
    createSchedulers() {
        this.pollingScheduler = scheduler.create(this.periodInMilliseconds, new RakeOutCommand.RakeOutAction(this));
        this.attemptScheduler = scheduler.create(this.connectionParameters.getResilience().getPeriodInMilliseconds(), new RakeOutCommand.AttemptAction(this));
        this.timeoutScheduler = scheduler.create(this.timeoutInterval, new RakeOutCommand.TimeoutAction(this));
    }
    processError(error) {
        this.attempts = this.attempts + 1;
        if (this.attempts > this.connectionParameters.getResilience().getAttempts()) {
            this.logger.error("Send message '" + this.getCommandName() + "' failed: " + error);
            this.attempts = 0;
            this.publisher.notifyError(this.getCommandName() + " error: " + error);
        }
        else {
            this.logger.warning("Send message '" + this.getCommandName() + "' failed: " + error);
            if (this.attemptScheduler != null) {
                this.logger.debug(this.getCommandName() + ". Schedule new attempt " + (this.attempts).toString() + "/" + (this.connectionParameters.getResilience().getAttempts()).toString());
                this.attemptScheduler.startWithDelay();
            }
        }
    }
}
module.exports = RakeOutCommand
RakeOutCommand.TimeoutAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        if (this._owner_.timeoutScheduler != null) {
            this._owner_.timeoutScheduler.stop();
            this._owner_.processError("Command execution timeout");
        }
    }
}
RakeOutCommand.RakeOutAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        let transportMessage;
        if (this._owner_.pollingScheduler != null) {
            this._owner_.pollingScheduler.stop();
            if (!this._owner_.canceled) {
                transportMessage = this._owner_.getTransportMessage();
                this._owner_.timeoutScheduler.startWithDelay();
                this._owner_.messageExecutor.execute(transportMessage, this._owner_.messageExecutorCallback);
            }
        }
    }
}
RakeOutCommand.AttemptAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        if (this._owner_.attemptScheduler != null) {
            this._owner_.attemptScheduler.stop();
            if (!this._owner_.canceled && this._owner_.pollingScheduler != null && this._owner_.periodInMilliseconds >= 0) {
                this._owner_.pollingScheduler.startImmediately();
            }
        }
    }
}
RakeOutCommand.MessageExecutorCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccessSent() {
        this._owner_.logger.debug("Message '" + this._owner_.getCommandName() + "' successfully sent");
        this._owner_.attempts = 0;
        if (this._owner_.timeoutScheduler != null) {
            this._owner_.timeoutScheduler.stop();
        }
        if (!this._owner_.canceled && this._owner_.pollingScheduler != null && this._owner_.periodInMilliseconds >= 0) {
            this._owner_.logger.debug(this._owner_.getCommandName() + ". Schedule new start");
            this._owner_.pollingScheduler.startWithDelay();
        }
    }
    onError(error) {
        if (this._owner_.timeoutScheduler != null) {
            this._owner_.timeoutScheduler.stop();
        }
        this._owner_.processError(error);
    }
}
