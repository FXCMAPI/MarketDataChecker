'use strict';
let LogManager = require('./LogManager.js');
let list = require('@gehtsoft/LuaxStdlib-node').list;
let MessageType = require('./MessageType.js');
class SsoTokenController {
    sessionProvider;
    messageRouter;
    logger;
    connectionParameters;
    commandFactory;
    messageFactory;
    messageExecutor;
    requestNumberGenerator;
    ssoTokenDecoder;
    receiveNewMessageListener;
    isTradingSessionReceived;
    processors;
    constructor() {
        this.logger = LogManager.getLogger();
        this.isTradingSessionReceived = false;
        this.processors = new list();
    }
    static create(commandFactory, connectionParameters, sessionProvider, messageFactory, messageExecutor, messageRouter, requestNumberGenerator, ssoTokenDecoder) {
        let controller;
        controller = new SsoTokenController();
        controller.sessionProvider = sessionProvider;
        controller.messageRouter = messageRouter;
        controller.connectionParameters = connectionParameters;
        controller.commandFactory = commandFactory;
        controller.messageFactory = messageFactory;
        controller.messageExecutor = messageExecutor;
        controller.requestNumberGenerator = requestNumberGenerator;
        controller.ssoTokenDecoder = ssoTokenDecoder;
        controller.subscribeOnRequiredMessages();
        return controller;
    }
    subscribeOnRequiredMessages() {
        this.receiveNewMessageListener = new SsoTokenController.ReceiveNewMessageListener(this);
        this.messageRouter.subscribeNewMessageReceive(MessageType.GetSsoToken, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.TradingSessionReceived, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Reconnecting, this.receiveNewMessageListener);
    }
    getSsoToken(callback) {
        this.logger.info("SsoTokenProvider. getSsoToken");
        this.getToken("", callback);
    }
    getProviderToken(provider, callback) {
        this.logger.info("SsoTokenProvider. getProviderToken");
        this.getToken(provider, callback);
    }
    getToken(provider, callback) {
        let getTokenProcessorCallback, getSsoTokenProcessor;
        if (!this.isTradingSessionReceived) {
            this.logger.warning("GetToken got error, connection state should be connected");
            callback.onError("Connection state should be connected");
            return;
        }
        getTokenProcessorCallback = new SsoTokenController.GetTokenProcessorCallback(this);
        getTokenProcessorCallback.setCallback(callback);
        getSsoTokenProcessor = this.commandFactory.createGetSsoTokenProcessor(this.ssoTokenDecoder, provider, getTokenProcessorCallback);
        getTokenProcessorCallback.setSsoTokenProcessor(getSsoTokenProcessor);
        this.processors.add(getSsoTokenProcessor);
        getSsoTokenProcessor.execute();
    }
    stop() {
        this.stopActiveProcessors();
    }
    stopActiveProcessors() {
        let i;
        for (i = 0; i <= this.processors.length() - 1; i += 1) {
            this.processors.get(i).stop();
        }
    }
    processMessage(message) {
        if (message.getType() == MessageType.TradingSessionReceived) {
            this.isTradingSessionReceived = true;
        } else if (message.getType() == MessageType.Disconnected || message.getType() == MessageType.Reconnecting) {
            this.stopActiveProcessors();
            this.isTradingSessionReceived = false;
        }
    }
}
module.exports = SsoTokenController
SsoTokenController.ReceiveNewMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        this._owner_.processMessage(message);
    }
}
SsoTokenController.GetTokenProcessorCallback = class {
    callback;
    getSsoTokenProcessor;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.callback = null;
        this.getSsoTokenProcessor = null;
    }
    setCallback(callback) {
        this.callback = callback;
    }
    setSsoTokenProcessor(getSsoTokenProcessor) {
        this.getSsoTokenProcessor = getSsoTokenProcessor;
    }
    onError(error) {
        this.removeCurrentProcessor();
        this.callback.onError("Get SSO Token error: " + error);
    }
    onSuccess(token) {
        this.removeCurrentProcessor();
        this.callback.onSuccess(token);
    }
    removeCurrentProcessor() {
        let i;
        for (i = 0; i <= this._owner_.processors.length() - 1; i += 1) {
            if (this.getSsoTokenProcessor == this._owner_.processors.get(i)) {
                this._owner_.processors.remove(i);
                return;
            }
        }
    }
}
