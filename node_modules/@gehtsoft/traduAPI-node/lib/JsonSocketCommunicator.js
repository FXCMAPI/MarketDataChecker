'use strict';
let CommonPublisher = require('./CommonPublisher.js');
let LogManager = require('./LogManager.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let jsonParser = require('@gehtsoft/LuaxStdlib-node').jsonParser;
let jsonNode = require('@gehtsoft/LuaxStdlib-node').jsonNode;
class JsonSocketCommunicator {
    socketReceiveMessageListener;
    publisher;
    logger;
    socketCommunicator;
    constructor() {
        this.socketReceiveMessageListener = null;
        this.publisher = new CommonPublisher();
        this.logger = LogManager.getLogger();
    }
    static create(socketCommunicator) {
        let instance;
        instance = new JsonSocketCommunicator();
        instance.socketCommunicator = socketCommunicator;
        return instance;
    }
    connect(url) {
        this.socketCommunicator.connect(url);
    }
    close() {
        this.socketCommunicator.close();
    }
    send(message) {
        this.socketCommunicator.send(message);
    }
    getState() {
        return this.socketCommunicator.getState();
    }
    subscribeStateChange(listener) {
        this.socketCommunicator.subscribeStateChange(listener);
    }
    unsubscribeStateChange(listener) {
        this.socketCommunicator.unsubscribeStateChange(listener);
    }
    subscribeJsonReceive(listener) {
        if (this.socketReceiveMessageListener == null) {
            this.socketReceiveMessageListener = new JsonSocketCommunicator.SocketReceiveMessageListener(this);
            this.socketCommunicator.subscribeMessageReceive(this.socketReceiveMessageListener);
        }
        this.publisher.subscribe(listener);
    }
    unsubscribeJsonReceive(listener) {
        this.publisher.unsubscribe(listener);
        if (this.publisher.length() == 0) {
            this.socketCommunicator.unsubscribeMessageReceive(this.socketReceiveMessageListener);
            this.socketReceiveMessageListener = null;
        }
    }
}
module.exports = JsonSocketCommunicator
JsonSocketCommunicator.SocketReceiveMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onReceive(message) {
        this._owner_.publisher.notifyAction(JsonSocketCommunicator.ReceiveAction.create(message, this._owner_.logger));
    }
}
JsonSocketCommunicator.ReceiveAction = class {
    listener;
    node;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(jsonString, logger) {
        let result, root, parser, ex;
        try {
            if (jsonString != null && stdlib.len(jsonString) > 0) {
                parser = new jsonParser();
                root = parser.parse(jsonString);
            }
            else {
                root = null;
            }
        } catch(exTemp1) {
            ex = stdlib.ensureException(exTemp1);
            logger.error("On JSON parse failed: " + ex.getMessage());
            root = null;
        }
        result = new JsonSocketCommunicator.ReceiveAction(this);
        result.node = root;
        return result;
    }
    setListener(listener) {
        this.listener = listener;
    }
    execute() {
        let n, i;
        if (this.node != null) {
            if (this.node.getType() == jsonNode.OBJECT) {
                this.listener.onReceive(this.node);
            } else if (this.node.getType() == jsonNode.ARRAY) {
                n = this.node.getChildrenCount();
                for (i = 0; i <= n - 1; i += 1) {
                    this.listener.onReceive(this.node.getChildByIndex(i));
                }
            }
        }
    }
}
