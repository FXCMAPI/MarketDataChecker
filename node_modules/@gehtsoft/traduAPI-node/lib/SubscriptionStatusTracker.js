'use strict';
let list = require('@gehtsoft/LuaxStdlib-node').list;
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let StringValueObject = require('./StringValueObject.js');
let LogManager = require('./LogManager.js');
let StringUtil = require('./StringUtil.js');
let MessageType = require('./MessageType.js');
let CollectionUtils = require('./CollectionUtils.js');
class SubscriptionStatusTracker {
    messageRouter;
    receiveNewMessageListener;
    subscribedMessages;
    items;
    timeOutScheduler;
    timeoutInSeconds;
    logger;
    setTimeoutInSeconds(timeoutInSeconds) {
        this.timeoutInSeconds = timeoutInSeconds;
    }
    getTracksNumber() {
        return this.items.length();
    }
    stop() {
        this.items = new list();
        if (this.timeOutScheduler != null) {
            this.timeOutScheduler.stop();
            this.timeOutScheduler = null;
        }
    }
    track(request, callback) {
        let now, i, timeoutJulian;
        now = stdlib.nowutc();
        timeoutJulian = stdlib.toJdn(now);
        timeoutJulian = timeoutJulian + this.timeoutInSeconds / 86400;
        for (i = 0; i <= request.length() - 1; i += 1) {
            this.subscribeToNewMessageIfNeed(request.getRequest(i).getMessageType());
        }
        this.items.add(SubscriptionStatusTracker.TrackItem.create(request, callback, timeoutJulian));
        if (this.timeOutScheduler == null) {
            this.timeOutScheduler = scheduler.create(1000, new SubscriptionStatusTracker.CheckTimeoutAction(this));
            if (this.timeoutInSeconds <= 0) {
                this.timeOutScheduler.startImmediately();
            }
            else {
                this.timeOutScheduler.startWithDelay();
            }
        }
        return this.items.length() - 1;
    }
    cancel(trackNumber) {
        let trackItem;
        if (trackNumber < this.items.length()) {
            trackItem = this.items.get(trackNumber);
            this.clearTrackItem(trackItem);
            this.items.remove(trackNumber);
        }
    }
    subscribeToNewMessageIfNeed(messageType) {
        let isMessageSub;
        isMessageSub = this.isMessageSubscribed(messageType);
        if (!isMessageSub) {
            this.messageRouter.subscribeNewMessageReceive(messageType, this.receiveNewMessageListener);
            this.subscribedMessages.add(StringValueObject.create(messageType));
        }
    }
    isMessageSubscribed(messageType) {
        let found, i, mt;
        found = false;
        for (i = 0; i <= this.subscribedMessages.length() - 1; i += 1) {
            mt = this.subscribedMessages.get(i).get();
            if (mt == messageType) {
                found = true;
                break;
            }
        }
        return found;
    }
    static create(messageRouter) {
        let result;
        result = new SubscriptionStatusTracker();
        result.messageRouter = messageRouter;
        result.subscribedMessages = new list();
        result.items = new list();
        result.timeOutScheduler = null;
        result.timeoutInSeconds = 30;
        result.setReceiveNewMessageListener();
        result.logger = LogManager.getLogger();
        return result;
    }
    setReceiveNewMessageListener() {
        this.receiveNewMessageListener = new SubscriptionStatusTracker.ReceiveNewMessageListener(this);
    }
    processResponse(requestNumber, offerId, error) {
        let i, j, found, trackItem, compositeRequest, instrumentRequest;
        found = false;
        for (i = 0; i <= this.items.length() - 1; i += 1) {
            trackItem = this.items.get(i);
            compositeRequest = trackItem.getRequest();
            for (j = 0; j <= compositeRequest.length() - 1; j += 1) {
                instrumentRequest = compositeRequest.getRequest(j);
                if (instrumentRequest.getRequestNumber() == requestNumber) {
                    found = true;
                    break;
                }
            }
            if (found) {
                break;
            }
        }
        if (found) {
            this.checkAndRemove(offerId, instrumentRequest, compositeRequest, trackItem, error, i);
        }
    }
    checkAndRemove(offerId, instrumentRequest, compositeRequest, trackItem, error, i) {
        let toRemove;
        if (error != null && stdlib.len(error) > 0) {
            trackItem.addUnsucceededSymbol(offerId);
            trackItem.addError(offerId + ": " + error);
            this.logger.warning("SubscriptionStatusTracker. Process response: " + offerId + ": " + error);
        }
        toRemove = false;
        instrumentRequest.setProcessed(offerId);
        if (compositeRequest.isCompleted()) {
            toRemove = true;
            if (stdlib.len(trackItem.getError()) > 0) {
                trackItem.getCallback().onError(trackItem.getError(), trackItem.getUnsucceededSymbols());
            }
            else {
                trackItem.getCallback().onSuccess();
            }
        }
        if (toRemove) {
            this.items.remove(i);
        }
    }
    checkResponse(requestNumber) {
        let i, j, trackItem, compositeRequest, instrumentRequest;
        for (i = 0; i <= this.items.length() - 1; i += 1) {
            trackItem = this.items.get(i);
            compositeRequest = trackItem.getRequest();
            for (j = 0; j <= compositeRequest.length() - 1; j += 1) {
                instrumentRequest = compositeRequest.getRequest(j);
                if (instrumentRequest.getRequestNumber() == requestNumber) {
                    return instrumentRequest;
                }
            }
        }
        return null;
    }
    processInstrumentSubscribingResponse(message) {
        let requestNumber;
        requestNumber = StringUtil.getRequestNumber(message.getRequestId());
        this.processResponse(requestNumber, message.getOfferId(), message.getError());
    }
    processPriceFeedResponse(getPriceFeedMessage) {
        let offerIds, i, instrumentRequest, requestId, error;
        requestId = StringUtil.getRequestNumber(getPriceFeedMessage.getRequestId());
        error = getPriceFeedMessage.getError();
        if (error != null && stdlib.len(error) > 0 && getPriceFeedMessage.getOfferId() == "*") {
            instrumentRequest = this.checkResponse(requestId);
            if (instrumentRequest != null) {
                offerIds = instrumentRequest.getOfferIdsWaiting();
                for (i = 0; i <= offerIds.length - 1; i += 1) {
                    this.processResponse(requestId, offerIds[i], error);
                }
            }
        }
        else {
            this.processResponse(requestId, getPriceFeedMessage.getOfferId(), error);
        }
    }
    processGetInstrumentsResponse(message) {
        let requestNumber, i, instruments;
        instruments = message.getInstruments();
        requestNumber = StringUtil.getRequestNumber(message.getRequestId());
        for (i = 0; i <= instruments.length - 1; i += 1) {
            this.processResponse(requestNumber, instruments[i].getInstrument().getOfferId(), "");
        }
    }
    processGetOffersResponse(message) {
        let requestNumber, i, offers;
        offers = message.getOffers();
        requestNumber = StringUtil.getRequestNumber(message.getRequestId());
        if (offers.length == 0) {
            this.processResponse(requestNumber, "", "");
        }
        else {
            for (i = 0; i <= offers.length - 1; i += 1) {
                this.processResponse(requestNumber, offers[i].getOffer().getOfferId(), "");
            }
        }
    }
    processMessage(message) {
        let getPriceFeedMessage, instrumentSubscribingStatusMessage, getInstrumentsMessage, getOffersMessage;
        this.logger.debug("SubscriptionStatusTracker. Receive message: " + message.getType());
        if (message.getType() == MessageType.InstrumentSubscribingStatus) {
            instrumentSubscribingStatusMessage = message;
            this.processInstrumentSubscribingResponse(instrumentSubscribingStatusMessage);
        } else if (message.getType() == MessageType.PriceFeed) {
            getPriceFeedMessage = message;
            this.processPriceFeedResponse(getPriceFeedMessage);
        } else if (message.getType() == MessageType.GetInstruments) {
            getInstrumentsMessage = message;
            this.processGetInstrumentsResponse(getInstrumentsMessage);
        } else if (message.getType() == MessageType.GetOffers) {
            getOffersMessage = message;
            this.processGetOffersResponse(getOffersMessage);
        }
    }
    clearTrackItem(trackItem) {
        let j;
        for (j = 0; j <= trackItem.getRequest().length() - 1; j += 1) {
            trackItem.getRequest().getRequest(j).clearWaiting();
        }
    }
    getNotFinishedIds(trackItem) {
        let j, k, ids, idsList;
        idsList = new list();
        for (j = 0; j <= trackItem.getRequest().length() - 1; j += 1) {
            ids = trackItem.getRequest().getRequest(j).getOfferIdsWaiting();
            for (k = 0; k <= ids.length - 1; k += 1) {
                idsList.add(StringValueObject.create(ids[k]));
            }
        }
        return CollectionUtils.stringListToArray(idsList);
    }
}
module.exports = SubscriptionStatusTracker
SubscriptionStatusTracker.ReceiveNewMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        this._owner_.processMessage(message);
    }
}
SubscriptionStatusTracker.TrackItem = class {
    request;
    callback;
    timeoutJulian;
    unsucceededSymbols;
    error;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    addError(err) {
        if (stdlib.len(this.error) > 0) {
            this.error = this.error + "; ";
        }
        this.error = this.error + err;
    }
    getError() {
        return this.error;
    }
    addUnsucceededSymbol(unsucceededSymbol) {
        this.unsucceededSymbols.add(StringValueObject.create(unsucceededSymbol));
    }
    getUnsucceededSymbols() {
        return CollectionUtils.stringListToArray(this.unsucceededSymbols);
    }
    getRequest() {
        return this.request;
    }
    getCallback() {
        return this.callback;
    }
    getTimeoutJulian() {
        return this.timeoutJulian;
    }
    static create(request, callback, timeoutJulian) {
        let result;
        result = new SubscriptionStatusTracker.TrackItem(this);
        result.request = request;
        result.callback = callback;
        result.timeoutJulian = timeoutJulian;
        result.unsucceededSymbols = new list();
        result.error = "";
        return result;
    }
}
SubscriptionStatusTracker.CheckTimeoutAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        let now, i, trackItem, nowJulian, offerIds;
        now = stdlib.nowutc();
        nowJulian = stdlib.toJdn(now);
        i = 0;
        while(i < this._owner_.items.length()) {
            trackItem = this._owner_.items.get(i);
            if (nowJulian >= trackItem.getTimeoutJulian()) {
                offerIds = this._owner_.getNotFinishedIds(trackItem);
                this._owner_.clearTrackItem(trackItem);
                this._owner_.items.remove(i);
                trackItem.getCallback().onError("Timeout error", offerIds);
            }
            else {
                i = i + 1;
            }
        }
        if (this._owner_.items.length() == 0) {
            this._owner_.stop();
        }
    }
}
