'use strict';
let SubscriptionStatusTracker = require('./SubscriptionStatusTracker.js');
let CompositeSubscriptionRequest = require('./CompositeSubscriptionRequest.js');
let SubscriptionInstrumentRequest = require('./SubscriptionInstrumentRequest.js');
let MessageType = require('./MessageType.js');
let GetProfilesQuery = require('./GetProfilesQuery.js');
let emptyAction = require('./emptyAction.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
class InstrumentLoader {
    subscriptionStatusTracker;
    requestNumberGenerator;
    messageExecutor;
    commandFactory;
    sessionStorage;
    messageFactory;
    leverageProfilesUpdater;
    stopped;
    static create(commandFactory, messageRouter, messageExecutor, sessionStorage, messageFactory, requestNumberGenerator) {
        let result;
        result = new InstrumentLoader();
        result.subscriptionStatusTracker = SubscriptionStatusTracker.create(messageRouter);
        result.requestNumberGenerator = requestNumberGenerator;
        result.commandFactory = commandFactory;
        result.messageExecutor = messageExecutor;
        result.sessionStorage = sessionStorage;
        result.messageFactory = messageFactory;
        result.stopped = true;
        return result;
    }
    setLeverageProfilesUpdater(leverageProfilesUpdater) {
        this.leverageProfilesUpdater = leverageProfilesUpdater;
    }
    stop() {
        this.stopped = true;
        this.subscriptionStatusTracker.stop();
    }
    loadInstrument(offerIds, callback) {
        let compositeSubscriptionRequest, requestNumber, trackNumber, command, ex, queueItem, actionStopRefresh, finishProcessor;
        this.stopped = false;
        requestNumber = this.requestNumberGenerator.getNextRequestNumber();
        compositeSubscriptionRequest = CompositeSubscriptionRequest.create();
        compositeSubscriptionRequest.addRequest(SubscriptionInstrumentRequest.create(requestNumber, MessageType.GetInstruments, offerIds));
        finishProcessor = new InstrumentLoader.FinishProcessor(this);
        finishProcessor.setCallback(callback);
        trackNumber = this.subscriptionStatusTracker.track(compositeSubscriptionRequest, InstrumentLoader.ResultAction.create(finishProcessor, callback));
        actionStopRefresh = InstrumentLoader.ActionStopRefresh.create(finishProcessor, callback);
        queueItem = GetProfilesQuery.create(offerIds, new emptyAction(), actionStopRefresh);
        try {
            command = this.commandFactory.createGetAllInstrumentsCommand(offerIds, this.messageExecutor, this.sessionStorage.getTradingSession(), this.messageFactory, requestNumber);
            command.execute();
            this.leverageProfilesUpdater.updateLeverageProfiles(queueItem);
        } catch(exTemp1) {
            ex = stdlib.ensureException(exTemp1);
            this.subscriptionStatusTracker.cancel(trackNumber);
            callback.onError(ex.getMessage());
        }
    }
}
module.exports = InstrumentLoader
InstrumentLoader.FinishProcessor = class {
    isLeverageProfilesLoaded;
    isInstrumentsLoaded;
    callback;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.isLeverageProfilesLoaded = false;
        this.isInstrumentsLoaded = false;
    }
    setCallback(callback) {
        this.callback = callback;
    }
    check() {
        if (this.isLeverageProfilesLoaded && this.isInstrumentsLoaded && !this._owner_.stopped) {
            this.callback.onSuccess();
        }
    }
    setLeverageProfilesLoaded() {
        this.isLeverageProfilesLoaded = true;
        this.check();
    }
    setInstrumentsLoaded() {
        this.isInstrumentsLoaded = true;
        this.check();
    }
}
InstrumentLoader.ActionStopRefresh = class {
    finishProcessor;
    callback;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(finishProcessor, callback) {
        let instance;
        instance = new InstrumentLoader.ActionStopRefresh(this);
        instance.finishProcessor = finishProcessor;
        instance.callback = callback;
        return instance;
    }
    invoke() {
        this.finishProcessor.setLeverageProfilesLoaded();
    }
    invokeWithError(error) {
        this.callback.onError(error);
    }
}
InstrumentLoader.ResultAction = class {
    finishProcessor;
    callback;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(finishProcessor, callback) {
        let instance;
        instance = new InstrumentLoader.ResultAction(this);
        instance.finishProcessor = finishProcessor;
        instance.callback = callback;
        return instance;
    }
    onSuccess() {
        this.finishProcessor.setInstrumentsLoaded();
    }
    onError(error, unsucceededSymbols) {
        this.callback.onError(error);
    }
}
