'use strict';
let CommandStatusPublisher = require('./CommandStatusPublisher.js');
let LogManager = require('./LogManager.js');
let MessageType = require('./MessageType.js');
let UniqueStringBuilder = require('./UniqueStringBuilder.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
//@@DocBrief("The command for getting temporary price session")
class GetTemporaryPriceSessionBySsoTokenCommand {
    ssoToken;
    login;
    applicationName;
    agent;
    messageFactory;
    terminal;
    priceTerminal;
    requestNumberGenerator;
    publisher;
    messageRouter;
    receiveNewMessageListener;
    messageExecutor;
    tradingSession;
    logger;
    constructor() {
        this.publisher = new CommandStatusPublisher();
        this.receiveNewMessageListener = new GetTemporaryPriceSessionBySsoTokenCommand.ReceiveNewMessageListener(this);
        this.logger = LogManager.getLogger();
    }
    execute() {
        let transportMessage, messageExecutorCallback;
        this.logger.debug("Execute command 'GetTemporaryPriceSessionBySsoTokenCommand'");
        messageExecutorCallback = new GetTemporaryPriceSessionBySsoTokenCommand.MessageExecutorCallback(this);
        this.messageRouter.subscribeNewMessageReceive(MessageType.GetTemporaryPriceSession, this.receiveNewMessageListener);
        transportMessage = this.messageFactory.createGetTemporaryPriceSessionBySsoTokenRequestMessage(this.ssoToken, this.login, this.applicationName, this.agent, this.terminal, this.priceTerminal, this.tradingSession, this.requestNumberGenerator, UniqueStringBuilder.getString());
        this.messageExecutor.execute(transportMessage, messageExecutorCallback);
    }
    subscribeStatusChange(callback) {
        this.publisher.subscribe(callback);
    }
    unsubscribeStatusChange(callback) {
        this.publisher.unsubscribe(callback);
    }
    stop() {
        this.logger.debug("Stop command 'GetTemporaryPriceSessionBySsoTokenCommand'");
        this.messageExecutor.cancel();
    }
}
module.exports = GetTemporaryPriceSessionBySsoTokenCommand
GetTemporaryPriceSessionBySsoTokenCommand.ReceiveNewMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        let getTemporaryPriceSessionMessage, error;
        this._owner_.logger.debug("GetTemporaryPriceSessionBySsoTokenCommand. Receive message: " + message.getType());
        if (message.getType() != MessageType.GetTemporaryPriceSession) {
            this._owner_.publisher.notifyError("Unexpected message type: " + message.getType());
        }
        else {
            getTemporaryPriceSessionMessage = message;
            if (this.isMyRequestId(getTemporaryPriceSessionMessage.getRequestId())) {
                this._owner_.messageRouter.unsubscribeNewMessageReceive(MessageType.GetTemporaryPriceSession, this._owner_.receiveNewMessageListener);
                error = getTemporaryPriceSessionMessage.getError();
                if (error != null) {
                    this._owner_.publisher.notifyError(error);
                }
                else {
                    this._owner_.publisher.notifySuccess(message);
                }
            }
        }
    }
    isMyRequestId(requestId) {
        return stdlib.indexOf(requestId, "NewSession-" + this._owner_.priceTerminal.getName() + "-", false) == 0;
    }
}
GetTemporaryPriceSessionBySsoTokenCommand.MessageExecutorCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccessSent() {
        this._owner_.logger.debug("Message 'GetTemporaryPriceSessionBySsoTokenCommand' successfully sent");
    }
    onError(error) {
        this._owner_.logger.error("Send message 'GetTemporaryPriceSessionBySsoTokenCommand' failed: " + error);
        this._owner_.messageRouter.unsubscribeNewMessageReceive(MessageType.GetTemporaryPriceSession, this._owner_.receiveNewMessageListener);
        this._owner_.publisher.notifyError(error);
    }
}
