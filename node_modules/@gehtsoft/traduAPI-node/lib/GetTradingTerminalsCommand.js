'use strict';
let CommandStatusPublisher = require('./CommandStatusPublisher.js');
let HostsParserV6 = require('./HostsParserV6.js');
let HostsParser = require('./HostsParser.js');
let HostsReceiverCallback = require('./HostsReceiverCallback.js');
let LogManager = require('./LogManager.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let GetTradingTerminalsMessageBuilder = require('./GetTradingTerminalsMessageBuilder.js');
//@@DocBrief("The command for getting trading terminals")
class GetTradingTerminalsCommand {
    login;
    url;
    connection;
    hostsParser;
    hostsV6Parser;
    hostsReceiver;
    publisher;
    hostsReceiverCallback;
    logger;
    ssoToken;
    ssoTokenProvider;
    constructor() {
        this.publisher = new CommandStatusPublisher();
        this.hostsV6Parser = new HostsParserV6();
        this.hostsParser = new HostsParser();
        this.hostsReceiverCallback = HostsReceiverCallback.create(this);
        this.logger = LogManager.getLogger();
    }
    getLogin() {
        return this.login;
    }
    getUrl() {
        return this.url;
    }
    getConnection() {
        return this.connection;
    }
    execute() {
        this.logger.debug("Execute command 'GetTradingTerminalsCommand'");
        this.hostsReceiver.receiveHosts(this.login, this.url, this.connection, this.hostsReceiverCallback, this.ssoToken, this.ssoTokenProvider);
    }
    subscribeStatusChange(callback) {
        this.publisher.subscribe(callback);
    }
    unsubscribeStatusChange(callback) {
        this.publisher.unsubscribe(callback);
    }
    notifyOnHostsReceived(hosts) {
        let parserResponse, ex, terminals;
        this.logger.debug("Command 'GetTradingTerminalsCommand' completed");
        if (hosts != null && stdlib.len(hosts) > 0) {
            try {
                if (this.is6version(hosts)) {
                    parserResponse = this.hostsV6Parser.parse(hosts, this.connection);
                }
                else {
                    parserResponse = this.hostsParser.parse(hosts, this.connection);
                }
                if (parserResponse.getError() != null) {
                    this.notifyOnErrorWhenHostsReceived(parserResponse.getError());
                }
                else {
                    terminals = parserResponse.getTerminals();
                    this.notifyOnTradingTerminalsReceived(terminals);
                }
            } catch(exTemp1) {
                ex = stdlib.ensureException(exTemp1);
                this.logger.warning("GetTradingTerminalsCommand. The " + this.connection + " is corrupted. Error: " + ex.getMessage());
                this.publisher.notifyError("The " + this.connection + " is corrupted. Error: " + ex.getMessage());
            }
        }
        else {
            this.logger.warning("GetTradingTerminalsCommand. The " + this.connection + " is empty.");
            this.publisher.notifyError("The " + this.connection + " is empty.");
        }
    }
    notifyOnErrorWhenHostsReceived(error) {
        this.logger.error("Command 'GetTradingTerminalsCommand' failed: " + error);
        this.publisher.notifyError(error);
    }
    stop() {
        this.hostsReceiver.cancel();
        this.publisher.notifyCancel();
    }
    notifyOnTradingTerminalsReceived(terminals) {
        let message, getTradingTerminalsMessageBuilder;
        getTradingTerminalsMessageBuilder = new GetTradingTerminalsMessageBuilder();
        getTradingTerminalsMessageBuilder.setTradingTerminals(terminals);
        message = getTradingTerminalsMessageBuilder.build();
        this.publisher.notifySuccess(message);
    }
    is6version(hosts) {
        return stdlib.indexOf(hosts, "version=\"6.0\"", false) >= 0;
    }
}
module.exports = GetTradingTerminalsCommand
