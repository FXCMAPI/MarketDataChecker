'use strict';
let LogManager = require('./LogManager.js');
let LoginParametersChecker = require('./LoginParametersChecker.js');
let TradingSessionProvider = require('./TradingSessionProvider.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let JWTParser = require('./JWTParser.js');
let ConnectionStatus = require('./ConnectionStatus.js');
let ExecutorJWTRequiredCommands = require('./ExecutorJWTRequiredCommands.js');
let MessageType = require('./MessageType.js');
let DisconnectedMessageBuilder = require('./DisconnectedMessageBuilder.js');
let Session = require('./Session.js');
let TradingSessionReceivedMessageBuilder = require('./TradingSessionReceivedMessageBuilder.js');
let LoginError = require('./LoginError.js');
let ConnectedMessageBuilder = require('./ConnectedMessageBuilder.js');
class LoginByJWTCommand {
    static get CONNECTION_TIMEOUT_ERROR() { return "Connection timeout"; }
    jwtStr;
    tradingSystemUrl;
    connection;
    logger;
    timeoutScheduler;
    timeoutCallback;
    connectionStatusManager;
    commandFactory;
    communicator;
    currentCommand;
    loginParametersChecker;
    sessionProvider;
    commandEnvironment;
    ssoTokenController;
    aliveControllerFactory;
    rakeOutControllerFactory;
    instrumentsProvider;
    dxfeedConnectionFactory;
    systemSettingsProvider;
    messageRouter;
    messageExecutor;
    requestNumberGenerator;
    messageFactory;
    tradingTerminal;
    connectionParameters;
    sessionStorage;
    testRequestControllerFactory;
    constructor() {
        this.logger = LogManager.getLogger();
        this.timeoutCallback = new LoginByJWTCommand.TimeoutConnectionCallback(this);
        this.loginParametersChecker = new LoginParametersChecker();
        this.currentCommand = null;
    }
    static create(commandEnvironment, commandFactory, communicator, connectionStatusManager, sessionStorage, ssoTokenController, aliveControllerFactory, rakeOutControllerFactory, instrumentsProvider, dxfeedConnectionFactory, systemSettingsProvider, jwtStr, tradingSystemUrl, connection, testRequestControllerFactory) {
        let result;
        result = new LoginByJWTCommand();
        result.communicator = communicator;
        result.commandFactory = commandFactory;
        result.commandEnvironment = commandEnvironment;
        result.messageRouter = commandEnvironment.getMessageRouter();
        result.messageExecutor = commandEnvironment.getMessageExecutor();
        result.requestNumberGenerator = commandEnvironment.getRequestNumberGenerator();
        result.messageFactory = commandEnvironment.getMessageFactory();
        result.tradingTerminal = commandEnvironment.getTradingTerminal();
        result.connectionParameters = commandEnvironment.getConnectionParameters();
        result.sessionProvider = TradingSessionProvider.create(sessionStorage);
        result.connectionStatusManager = connectionStatusManager;
        result.sessionStorage = sessionStorage;
        result.ssoTokenController = ssoTokenController;
        result.aliveControllerFactory = aliveControllerFactory;
        result.rakeOutControllerFactory = rakeOutControllerFactory;
        result.testRequestControllerFactory = testRequestControllerFactory;
        result.instrumentsProvider = instrumentsProvider;
        result.dxfeedConnectionFactory = dxfeedConnectionFactory;
        result.systemSettingsProvider = systemSettingsProvider;
        result.jwtStr = jwtStr;
        result.tradingSystemUrl = tradingSystemUrl;
        result.connection = connection;
        result.init();
        return result;
    }
    init() {
        this.timeoutScheduler = scheduler.create(this.connectionParameters.getLoginTimeoutInSeconds() * 1000, this.timeoutCallback);
    }
    stop() {
        if (this.currentCommand != null) {
            this.currentCommand.stop();
        }
    }
    execute() {
        let checkResult, parser, jwt;
        this.logger.info("LoginByJWTCommand. start login process by jwt");
        this.logger.debug("LoginByJWTCommand. jwt: '" + this.jwtStr + "'");
        parser = new JWTParser();
        jwt = parser.parse(this.jwtStr);
        checkResult = this.loginParametersChecker.checkAttachWithJWT(jwt, this.tradingSystemUrl, this.connection);
        if (checkResult.isCheckPassed()) {
            this.timeoutScheduler.startWithDelay();
            this.getTerminals(jwt, this.tradingSystemUrl, this.connection);
        }
        else {
            this.logger.warning("LoginByJWTCommand. credentials not valid. code: " + (checkResult.getCode()).toString() + " error: " + checkResult.getError());
            this.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.DISCONNECTED, checkResult.getError());
        }
    }
    getTerminals(jwt, tradingSystemUrl, connection) {
        let getTerminalCallback;
        getTerminalCallback = new LoginByJWTCommand.GetTerminalsBySpecifiedCWCallback(this);
        getTerminalCallback.setJwt(jwt);
        this.currentCommand = this.commandFactory.createGetTerminalsBySpecifiedCW(jwt.getLogin(), tradingSystemUrl, connection, jwt.getTradingSessionSubId(), getTerminalCallback);
        this.currentCommand.execute();
    }
    loadSessionDetails(tradingTerminal, session, login) {
        let tradingSessionCommandListener, commandEnvironmentBuilder;
        commandEnvironmentBuilder = this.commandEnvironment;
        commandEnvironmentBuilder.setTradingTerminal(tradingTerminal);
        this.currentCommand = this.commandFactory.createGetTradingSessionCommand(commandEnvironmentBuilder.build(), login, session, 300, 120);
        tradingSessionCommandListener = new LoginByJWTCommand.TradingSessionCommandListener(this);
        tradingSessionCommandListener.setTerminal(tradingTerminal);
        tradingSessionCommandListener.setLogin(login);
        this.currentCommand.subscribeStatusChange(tradingSessionCommandListener);
        this.currentCommand.execute();
    }
    loadRequiredData(login) {
        let executorJWTRequiredCommands, command, executorJWTRequiredCommandsCallback;
        executorJWTRequiredCommands = ExecutorJWTRequiredCommands.create(this.messageRouter);
        command = this.commandFactory.createGetSystemPropertiesCommand(this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator);
        executorJWTRequiredCommands.addCommand(MessageType.SystemProperties, command);
        command = this.commandFactory.createGetAccountsCommand(this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator);
        executorJWTRequiredCommands.addCommand(MessageType.GetAccount, command);
        command = this.commandFactory.createGetInstrumentDescriptorsCommand(this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator);
        executorJWTRequiredCommands.addCommand(MessageType.GetInstrumentDescriptors, command);
        executorJWTRequiredCommandsCallback = new LoginByJWTCommand.ExecutorJWTRequiredCommandsCallback(this);
        executorJWTRequiredCommandsCallback.setLogin(login);
        executorJWTRequiredCommands.setCallback(executorJWTRequiredCommandsCallback);
        this.currentCommand = executorJWTRequiredCommands;
        executorJWTRequiredCommands.execute();
    }
    loginInPriceTerminals(login) {
        this.currentCommand = this.commandFactory.createLoginInMultiPriceTerminalsCommand(this.commandFactory, this.commandEnvironment, this.sessionStorage, this.ssoTokenController, this.connectionStatusManager, login, null, this.aliveControllerFactory, this.rakeOutControllerFactory, this.instrumentsProvider, this.dxfeedConnectionFactory, new LoginByJWTCommand.LoginInMultiPriceTerminalsCallback(this), this.systemSettingsProvider, this.sessionStorage.getTradingSession().getTradingTerminal(), this.testRequestControllerFactory);
        this.currentCommand.execute();
    }
    sendDisconnectedMessage() {
        let disconnectedMessageBuilder;
        disconnectedMessageBuilder = new DisconnectedMessageBuilder();
        this.messageRouter.publishNewMessage([disconnectedMessageBuilder.build()]);
    }
    subscribeStatusChange(callback) {
        return void(0);
    }
    unsubscribeStatusChange(callback) {
        return void(0);
    }
}
module.exports = LoginByJWTCommand
LoginByJWTCommand.GetTerminalsBySpecifiedCWCallback = class {
    jwt;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setJwt(jwt) {
        this.jwt = jwt;
    }
    onSuccess(terminal) {
        this._owner_.logger.debug("LoginByJWTCommand. terminals loaded");
        this._owner_.loadSessionDetails(terminal, this.jwt.getTradingSessionId(), this.jwt.getLogin());
    }
    onError(error) {
        this._owner_.timeoutScheduler.stop();
        this._owner_.sendDisconnectedMessage();
        this._owner_.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.DISCONNECTED, error);
    }
}
LoginByJWTCommand.TradingSessionCommandListener = class {
    tradingTerminal;
    login;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setTerminal(tradingTerminal) {
        this.tradingTerminal = tradingTerminal;
    }
    setLogin(login) {
        this.login = login;
    }
    onSuccess(message) {
        let getTradingSessionMessage, tradingSession, tradingSessionReceivedMessageBuilder;
        if (message != null && message.getType() == MessageType.GetTradingSession) {
            getTradingSessionMessage = message;
            tradingSession = getTradingSessionMessage.getPersistentSession();
            if (tradingSession != null) {
                this._owner_.logger.debug("LoginByJWTCommand. status for trading session received.");
                this._owner_.sessionStorage.setTradingSession(Session.create(tradingSession, getTradingSessionMessage.getUserId(), this.tradingTerminal, getTradingSessionMessage.getOptions()));
                tradingSessionReceivedMessageBuilder = new TradingSessionReceivedMessageBuilder();
                this._owner_.messageRouter.publishNewMessage([tradingSessionReceivedMessageBuilder.build()]);
                this._owner_.loadRequiredData(this.login);
            }
            else {
                this._owner_.logger.warning("LoginByJWTCommand. request status for trading session failed. code: " + (LoginError.CODE_SERVER_ERROR).toString() + " error: " + getTradingSessionMessage.getError());
                this._owner_.timeoutScheduler.stop();
                this._owner_.sendDisconnectedMessage();
                this._owner_.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.DISCONNECTED, getTradingSessionMessage.getError());
            }
        }
    }
    onError(error) {
        this._owner_.logger.warning("LoginByJWTCommand. request trading session failed: " + error);
        this._owner_.timeoutScheduler.stop();
        this._owner_.sendDisconnectedMessage();
        this._owner_.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.DISCONNECTED, error);
    }
    onCancel() {
        return void(0);
    }
}
LoginByJWTCommand.ExecutorJWTRequiredCommandsCallback = class {
    login;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setLogin(login) {
        this.login = login;
    }
    onAllResponsesReceived() {
        this._owner_.logger.debug("LoginByJWTCommand. required data loaded");
        this._owner_.loginInPriceTerminals(this.login);
    }
}
LoginByJWTCommand.LoginInMultiPriceTerminalsCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onError(error) {
        this._owner_.logger.warning("LoginByJWTCommand. price terminal auth failed: " + error);
        this._owner_.timeoutScheduler.stop();
        this._owner_.sendDisconnectedMessage();
        this._owner_.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.DISCONNECTED, error);
    }
    onSuccess() {
        let connectedMessageBuilder;
        this._owner_.logger.debug("LoginByJWTCommand. login in price terminals complete");
        this._owner_.timeoutScheduler.stop();
        connectedMessageBuilder = new ConnectedMessageBuilder();
        this._owner_.messageRouter.publishNewMessage([connectedMessageBuilder.build()]);
        this._owner_.connectionStatusManager.changeConnectionStatus(ConnectionStatus.CONNECTED);
    }
}
LoginByJWTCommand.TimeoutConnectionCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        this._owner_.logger.error("LoginByJWTCommand. login failed. code: " + (LoginError.CODE_TIMEOUT).toString() + " error: " + LoginByJWTCommand.CONNECTION_TIMEOUT_ERROR);
        this._owner_.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.DISCONNECTED, LoginByJWTCommand.CONNECTION_TIMEOUT_ERROR);
        if (this._owner_.currentCommand != null) {
            this._owner_.currentCommand.stop();
        }
        this._owner_.timeoutScheduler.stop();
    }
}
