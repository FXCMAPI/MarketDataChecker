'use strict';
let OpenPositionsStorage = require('./OpenPositionsStorage.js');
let DataManagerState = require('./DataManagerState.js');
let DataManagerStatePublisher = require('./DataManagerStatePublisher.js');
let CommonPublisher = require('./CommonPublisher.js');
let LogManager = require('./LogManager.js');
let DxFeedOffersEnsurer = require('./DxFeedOffersEnsurer.js');
let OpenPositionsMapper = require('./OpenPositionsMapper.js');
let ExecutionTimeEvenUtil = require('./ExecutionTimeEvenUtil.js');
let ExecutionTimeEventName = require('./ExecutionTimeEventName.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let StateStatusUtils = require('./StateStatusUtils.js');
let MessageType = require('./MessageType.js');
let list = require('@gehtsoft/LuaxStdlib-node').list;
let CollectionUtils = require('./CollectionUtils.js');
let OpenPositionInfoBuilder = require('./OpenPositionInfoBuilder.js');
let OpenPositionsUpdater = require('./OpenPositionsUpdater.js');
let UpdateCommandType = require('./UpdateCommandType.js');
let OpenPositionManagerOnChangedAction = require('./OpenPositionManagerOnChangedAction.js');
let OpenPositionManagerOnInsertAction = require('./OpenPositionManagerOnInsertAction.js');
let OpenPositionManagerOnDeleteAction = require('./OpenPositionManagerOnDeleteAction.js');
let OpenPositionManagerOnRefreshAction = require('./OpenPositionManagerOnRefreshAction.js');
//@@DocBrief("The class for getting access to open positions data")
class OpenPositionsManager {
    static get TIMEOUT_INTERVAL() { return 30000; }
    storage;
    state;
    stateChangePublisher;
    openPositionChangePublisher;
    messageRouter;
    commandFactory;
    sessionProvider;
    messageFactory;
    requestNumberGenerator;
    messageExecutor;
    receiveNewMessageListener;
    connectionStatusManager;
    accountsManager;
    requestsNumber;
    leverageProfilesManager;
    leverageProfilesManagerIsLoaded;
    instrumentsManagerIsLoaded;
    meLoaded;
    openPositionCalculator;
    logger;
    instrumentsProvider;
    getInstrumentsCallback;
    completeRefreshAction;
    instrumentsSubscriptionProvider;
    dxFeedOffersEnsurer;
    eventRefresh;
    timeoutInterval;
    timeOutScheduler;
    constructor() {
        this.requestsNumber = 0;
        this.leverageProfilesManagerIsLoaded = false;
        this.instrumentsManagerIsLoaded = false;
        this.meLoaded = false;
        this.storage = new OpenPositionsStorage();
        this.state = new DataManagerState();
        this.stateChangePublisher = new DataManagerStatePublisher();
        this.openPositionChangePublisher = new CommonPublisher();
        this.completeRefreshAction = new OpenPositionsManager.CompleteRefreshAction(this);
        this.setReceiveNewMessageListener();
        this.logger = LogManager.getLogger();
        this.timeoutInterval = OpenPositionsManager.TIMEOUT_INTERVAL;
        this.timeOutScheduler = null;
    }
    static create(commandFactory, messageRouter, messageExecutor, sessionProvider, messageFactory, requestNumberGenerator, connectionStatusManager, accountsManager, leverageProfilesManager, openPositionCalculator, instrumentsProvider, instrumentsSubscriptionProvider, internalOffersLoader, instrumentDescriptorsSeparator) {
        let result;
        result = new OpenPositionsManager();
        result.commandFactory = commandFactory;
        result.messageRouter = messageRouter;
        result.messageExecutor = messageExecutor;
        result.sessionProvider = sessionProvider;
        result.messageFactory = messageFactory;
        result.requestNumberGenerator = requestNumberGenerator;
        result.connectionStatusManager = connectionStatusManager;
        result.accountsManager = accountsManager;
        result.leverageProfilesManager = leverageProfilesManager;
        result.openPositionCalculator = openPositionCalculator;
        result.instrumentsProvider = instrumentsProvider;
        result.instrumentsSubscriptionProvider = instrumentsSubscriptionProvider;
        result.subscribeOnRequiredMessages();
        result.subscribeOnDependencies();
        result.dxFeedOffersEnsurer = DxFeedOffersEnsurer.create(instrumentsProvider, instrumentDescriptorsSeparator, internalOffersLoader);
        return result;
    }
    subscribeOpenPositionChange(listener) {
        this.openPositionChangePublisher.subscribe(listener);
    }
    unsubscribeOpenPositionChange(listener) {
        this.openPositionChangePublisher.unsubscribe(listener);
    }
    subscribeStateChange(listener) {
        this.stateChangePublisher.subscribe(listener);
    }
    unsubscribeStateChange(listener) {
        this.stateChangePublisher.unsubscribe(listener);
    }
    getState() {
        return this.state;
    }
    getOpenPosition(openPositionId) {
        let openPosition, openPositionCalculatedFields, calculatedMarginFields;
        this.logger.info("OpenPositionsManager. Get open position by id: " + openPositionId);
        calculatedMarginFields = null;
        openPositionCalculatedFields = null;
        openPosition = this.storage.getOpenPositionByTradeId(openPositionId);
        if (openPosition == null) {
            return null;
        }
        if (this.openPositionCalculator != null) {
            openPositionCalculatedFields = this.openPositionCalculator.calculatePublicFields(openPosition);
            calculatedMarginFields = this.openPositionCalculator.calculateMarginFields(openPosition);
        }
        return OpenPositionsMapper.combineToOpenPosition(openPosition, openPositionCalculatedFields, calculatedMarginFields);
    }
    getOpenPositionsSnapshot() {
        let openPositions;
        this.logger.info("OpenPositionsManager. Get open positions snapshot");
        openPositions = this.storage.getAllOpenPositions();
        return this.calculatePositions(openPositions);
    }
    calculatePositions(openPositions) {
        let result, openPositionCalculatedFields, calculatedMarginFields, calculatedMarginField, i;
        result = new Array(openPositions.length);
        calculatedMarginFields = null;
        if (this.openPositionCalculator != null) {
            calculatedMarginFields = this.openPositionCalculator.calculateMarginFieldsForAll(openPositions);
        }
        for (i = 0; i <= openPositions.length - 1; i += 1) {
            openPositionCalculatedFields = null;
            calculatedMarginField = null;
            if (this.openPositionCalculator != null) {
                openPositionCalculatedFields = this.openPositionCalculator.calculatePublicFields(openPositions[i]);
                calculatedMarginField = calculatedMarginFields[i];
            }
            result[i] = OpenPositionsMapper.combineToOpenPosition(openPositions[i], openPositionCalculatedFields, calculatedMarginField);
        }
        return result;
    }
    getCount() {
        return this.storage.getCount();
    }
    getOpenPositionIds() {
        return this.storage.getOpenPositionIds();
    }
    refresh() {
        let getAllOpenPositionsCommand, acctId, accounts, i, timeoutAction;
        this.logger.info("OpenPositionsManager. Load all open positions from server");
        if (this.getState().isLoading()) {
            this.logger.warning("OpenPositionsManager. Manager not loaded yet");
            return;
        }
        if (!this.connectionStatusManager.getConnectionStatus().isConnected()) {
            this.logger.warning("OpenPositionsManager. Session not connected");
            return;
        }
        this.storage.clear();
        this.eventRefresh = ExecutionTimeEvenUtil.eventStart(ExecutionTimeEventName.OpenPositionsManagerRefreshTime);
        this.notifyStateChange(DataManagerState.LOADING);
        accounts = this.accountsManager.getAccountsInfo();
        this.requestsNumber = 0;
        this.meLoaded = false;
        for (i = 0; i <= accounts.length - 1; i += 1) {
            if (i == 0) {
                timeoutAction = new OpenPositionsManager.TimeoutAction(this);
                this.timeOutScheduler = scheduler.create(this.timeoutInterval, timeoutAction);
                this.timeOutScheduler.startWithDelay();
            }
            acctId = accounts[i].getId();
            this.requestsNumber = this.requestsNumber + 1;
            getAllOpenPositionsCommand = this.commandFactory.createGetOpenPositionsByAcctCommand(acctId, this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator);
            getAllOpenPositionsCommand.subscribeStatusChange(new OpenPositionsManager.GetCommandStatusListener(this));
            getAllOpenPositionsCommand.execute();
        }
        if (this.requestsNumber == 0 && this.getState().isLoading()) {
            this.meLoaded = true;
            ExecutionTimeEvenUtil.eventStop(this.eventRefresh);
            this.notifyStateChange(DataManagerState.LOADED);
            this.notifyOnRefresh();
        }
    }
    getRawOpenPosition(openPositionId) {
        let openPosition;
        this.logger.info("OpenPositionsManager. Get raw open position by id: " + openPositionId);
        openPosition = this.storage.getOpenPositionByTradeId(openPositionId);
        if (openPosition == null) {
            return null;
        }
        return OpenPositionsMapper.copyRawOpenPosition(openPosition);
    }
    getRawOpenPositionsSnapshot() {
        let openPositions, result, i;
        this.logger.info("OpenPositionsManager. Get raw open positions snapshot");
        openPositions = this.storage.getAllOpenPositions();
        result = new Array(openPositions.length);
        for (i = 0; i <= openPositions.length - 1; i += 1) {
            result[i] = OpenPositionsMapper.copyRawOpenPosition(openPositions[i]);
        }
        return result;
    }
    getInternalCalculatedOpenPositionByAccountId(accountId) {
        let openPositions;
        this.logger.info("OpenPositionsManager. Get open positions by accout id: " + accountId);
        openPositions = this.storage.getOpenPositionByAccountId(accountId);
        return this.calculatePositions(openPositions);
    }
    getInternalRawOpenPositionByAccountId(accountId) {
        let openPositions, result, i;
        this.logger.info("OpenPositionsManager. Get raw open positions by accout id: " + accountId);
        openPositions = this.storage.getOpenPositionByAccountId(accountId);
        result = new Array(openPositions.length);
        for (i = 0; i <= openPositions.length - 1; i += 1) {
            result[i] = OpenPositionsMapper.copyRawOpenPosition(openPositions[i]);
        }
        return result;
    }
    getInternalOpenPositionsSnapshot() {
        let openPositions, result, i;
        openPositions = this.storage.getAllOpenPositions();
        result = new Array(openPositions.length);
        for (i = 0; i <= openPositions.length - 1; i += 1) {
            result[i] = OpenPositionsMapper.copyOpenPosition(openPositions[i]);
        }
        return result;
    }
    getInternalOpenPositionByAccountId(accountId) {
        return this.storage.getOpenPositionByAccountId(accountId);
    }
    getInternalOpenPosition(id) {
        return this.storage.getOpenPositionByTradeId(id);
    }
    getInternalOpenPositionByAccountIdAndOffer(accountId, offerId) {
        return this.storage.getInternalOpenPositionByAccountIdAndOffer(accountId, offerId);
    }
    subscribeOnDependencies() {
        this.leverageProfilesManager.subscribeStateChange(new OpenPositionsManager.LeverageProfilesManagerStateChangeListener(this));
        this.instrumentsSubscriptionProvider.subscribeManagerStateChange(new OpenPositionsManager.InstrumentsManagerStateChangeListener(this));
    }
    notifyStateChange(stateStatus) {
        this.logger.debug("OpenPositionsManager. State status changed: " + (stateStatus).toString());
        this.state.setState(stateStatus);
        this.stateChangePublisher.notifyStateChange(this.state);
    }
    notifyStateChangeWithError(stateStatus, error) {
        StateStatusUtils.notifyStateChangeWithError(this.state, this.stateChangePublisher, stateStatus, error, this.logger, "OpenPositionsManager");
    }
    setReceiveNewMessageListener() {
        this.receiveNewMessageListener = new OpenPositionsManager.ReceiveNewMessageListener(this);
    }
    subscribeOnRequiredMessages() {
        this.messageRouter.subscribeNewMessageReceive(MessageType.GetOpenPositions, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.OpenPositionUpdateMessage, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
    }
    processMessage(message) {
        let getOpenPositionsMessage, openPositions, updateOpenPositionMessage, i;
        this.logger.debug("OpenPositionsManager. Receive message: " + message.getType());
        if (message.getType() == MessageType.GetOpenPositions) {
            getOpenPositionsMessage = message;
            openPositions = getOpenPositionsMessage.getOpenPositions();
            this.requestsNumber = this.requestsNumber - 1;
            for (i = 0; i <= openPositions.length - 1; i += 1) {
                this.storage.addOpenPosition(openPositions[i].getOpenPosition());
            }
            if (!this.getState().isLoaded()) {
                if (this.requestsNumber == 0) {
                    this.meLoaded = true;
                    this.checkLoaded();
                }
            }
        }
        if (message.getType() == MessageType.OpenPositionUpdateMessage) {
            if (!this.getState().isLoaded()) {
                return;
            }
            updateOpenPositionMessage = message;
            this.updateOpenPosition(updateOpenPositionMessage.getUpdateCommand(), updateOpenPositionMessage.getPosition());
        }
        if (message.getType() == MessageType.Disconnected) {
            this.stopTimeout();
            this.storage.clear();
            this.notifyStateChange(DataManagerState.NOT_LOADED);
            this.leverageProfilesManagerIsLoaded = false;
            this.instrumentsManagerIsLoaded = false;
            this.meLoaded = false;
        }
    }
    stopTimeout() {
        if (this.timeOutScheduler != null) {
            this.timeOutScheduler.stop();
            this.timeOutScheduler = null;
        }
    }
    getAllSymbols() {
        let symbolsList, found, i, instrumentDescriptor, openPositions;
        openPositions = this.storage.getAllOpenPositions();
        symbolsList = new list();
        for (i = 0; i <= openPositions.length - 1; i += 1) {
            instrumentDescriptor = this.instrumentsProvider.getInstrumentDescriptorByOfferId(openPositions[i].getOfferId());
            if (instrumentDescriptor != null) {
                found = CollectionUtils.containsStringInList(symbolsList, instrumentDescriptor.getSymbol());
                if (!found) {
                    CollectionUtils.addStringToList(symbolsList, instrumentDescriptor.getSymbol());
                }
            }
        }
        return CollectionUtils.stringListToArray(symbolsList);
    }
    updateOpenPosition(updateType, updOpenPosition) {
        let oldOpenPosition, oldOpenPositionBuilder, openPositionInfo, openPositionInfoBuilder, id;
        id = updOpenPosition.getOpenPosition().getTradeID();
        openPositionInfoBuilder = new OpenPositionInfoBuilder();
        openPositionInfoBuilder.setId(id);
        openPositionInfoBuilder.setAccountId(updOpenPosition.getOpenPosition().getAccountId());
        openPositionInfoBuilder.setOfferId(updOpenPosition.getOpenPosition().getOfferId());
        openPositionInfo = openPositionInfoBuilder.build();
        if (updateType == UpdateCommandType.UPDATE) {
            oldOpenPosition = this.storage.getOpenPositionByTradeId(id);
            if (oldOpenPosition != null) {
                oldOpenPositionBuilder = oldOpenPosition;
                OpenPositionsUpdater.makeUpdate(oldOpenPositionBuilder, updOpenPosition);
                this.notifyOnChanged(openPositionInfo);
            }
            else {
                this.logger.info("OpenPositionsManager. Update open position with id: " + id + " - position doesn't exist");
            }
        }
        if (updateType == UpdateCommandType.INSERT) {
            this.processInsertCommand(openPositionInfo, updOpenPosition.getOpenPosition());
        }
        if (updateType == UpdateCommandType.DELETE) {
            this.storage.removeOpenPosition(id);
            this.notifyOnDelete(openPositionInfo);
        }
    }
    processInsertCommand(openPositionInfo, openPosition) {
        let callback, instrumentDescriptor, symbol;
        instrumentDescriptor = this.instrumentsProvider.getInstrumentDescriptorByOfferId(openPositionInfo.getOfferId());
        if (instrumentDescriptor != null) {
            callback = new OpenPositionsManager.SubscribeInstrumentsCallback(this);
            callback.setOpenPositionInfo(openPositionInfo);
            callback.setOpenPosition(openPosition);
            symbol = instrumentDescriptor.getSymbol();
            callback.setSymbol(symbol);
            if (instrumentDescriptor.getSubscriptionStatus() != "T") {
                this.instrumentsSubscriptionProvider.subscribeInstruments([symbol], callback);
            }
            else {
                this.instrumentsSubscriptionProvider.checkAndLoadCrossCources([symbol], callback);
            }
        }
    }
    notifyOnChanged(openPositionInfo) {
        this.openPositionChangePublisher.notifyAction(OpenPositionManagerOnChangedAction.create(openPositionInfo));
    }
    notifyOnInsert(openPositionInfo) {
        this.openPositionChangePublisher.notifyAction(OpenPositionManagerOnInsertAction.create(openPositionInfo));
    }
    notifyOnDelete(openPositionInfo) {
        this.openPositionChangePublisher.notifyAction(OpenPositionManagerOnDeleteAction.create(openPositionInfo));
    }
    notifyOnRefresh() {
        this.openPositionChangePublisher.notifyAction(OpenPositionManagerOnRefreshAction.create());
    }
    checkLoaded() {
        if (this.leverageProfilesManagerIsLoaded && this.instrumentsManagerIsLoaded && this.meLoaded && !this.getState().isLoaded()) {
            this.loadInstrumentsAndOffersIfRequired();
        }
    }
    splitToSubscriptionType() {
        let instrumentDescriptor, i, symbolsToInstruments, symbolsToCrossCourses, found, splitedBySubscriptionType, symbols;
        splitedBySubscriptionType = new OpenPositionsManager.SplitedBySubscriptionType(this);
        symbolsToInstruments = new list();
        symbolsToCrossCourses = new list();
        symbols = this.getAllSymbols();
        for (i = 0; i <= symbols.length - 1; i += 1) {
            instrumentDescriptor = this.instrumentsProvider.getInstrumentDescriptorBySymbol(symbols[i]);
            if (instrumentDescriptor != null) {
                if (instrumentDescriptor.getSubscriptionStatus() != "T") {
                    found = CollectionUtils.containsStringInList(symbolsToInstruments, symbols[i]);
                    if (!found) {
                        CollectionUtils.addStringToList(symbolsToInstruments, symbols[i]);
                    }
                }
                else {
                    found = CollectionUtils.containsStringInList(symbolsToCrossCourses, symbols[i]);
                    if (!found) {
                        CollectionUtils.addStringToList(symbolsToCrossCourses, symbols[i]);
                    }
                }
            }
        }
        splitedBySubscriptionType.InstrumentsForOrdinarySubscription = CollectionUtils.stringListToArray(symbolsToInstruments);
        splitedBySubscriptionType.InstrumentsForCrossSubscription = CollectionUtils.stringListToArray(symbolsToCrossCourses);
        return splitedBySubscriptionType;
    }
    loadInstrumentsAndOffersIfRequired() {
        let offerIds, splitedBySubscriptionType;
        splitedBySubscriptionType = this.splitToSubscriptionType();
        if (splitedBySubscriptionType.InstrumentsForOrdinarySubscription.length > 0) {
            this.instrumentsSubscriptionProvider.subscribeInstruments(splitedBySubscriptionType.InstrumentsForOrdinarySubscription, new OpenPositionsManager.DummySubscribeInstrumentsCallback(this));
        }
        if (splitedBySubscriptionType.InstrumentsForCrossSubscription.length > 0) {
            this.instrumentsSubscriptionProvider.checkAndLoadCrossCources(splitedBySubscriptionType.InstrumentsForCrossSubscription, new OpenPositionsManager.DummySubscribeInstrumentsCallback(this));
        }
        offerIds = this.getOfferIds();
        this.dxFeedOffersEnsurer.check(offerIds, this.completeRefreshAction);
    }
    getOfferIds() {
        let offerIds, positions, i;
        positions = this.storage.getAllOpenPositions();
        offerIds = new list();
        for (i = 0; i <= positions.length - 1; i += 1) {
            CollectionUtils.addStringToList(offerIds, positions[i].getOfferId());
        }
        return CollectionUtils.stringListToArray(offerIds);
    }
    completeRefresh() {
        ExecutionTimeEvenUtil.eventStop(this.eventRefresh);
        this.stopTimeout();
        this.notifyStateChange(DataManagerState.LOADED);
        this.notifyOnRefresh();
    }
}
module.exports = OpenPositionsManager
OpenPositionsManager.SplitedBySubscriptionType = class {
    InstrumentsForOrdinarySubscription;
    InstrumentsForCrossSubscription;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
}
OpenPositionsManager.DummySubscribeInstrumentsCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccess() {
        return void(0);
    }
    onError(error, unsucceededSymbols) {
        return void(0);
    }
}
OpenPositionsManager.SubscribeInstrumentsCallback = class {
    openPositionInfo;
    openPosition;
    symbol;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.openPositionInfo = null;
        this.symbol = null;
    }
    finish() {
        this._owner_.storage.addOpenPosition(this.openPosition);
        this._owner_.notifyOnInsert(this.openPositionInfo);
    }
    instrumentSubscribed() {
        this._owner_.dxFeedOffersEnsurer.check([this.openPositionInfo.getOfferId()], new OpenPositionsManager.SubscribeInstrumentsCallback.FinishCallback(this));
    }
    onSuccess() {
        this.instrumentSubscribed();
    }
    onError(errorStr, unsucceededSymbols) {
        let message;
        message = "OpenPositionsManager. Silence subscribe on '" + this.symbol + ".' error: " + errorStr;
        this._owner_.logger.error(message);
        this.instrumentSubscribed();
    }
    setOpenPosition(openPosition) {
        this.openPosition = openPosition;
    }
    setOpenPositionInfo(openPositionInfo) {
        this.openPositionInfo = openPositionInfo;
    }
    setSymbol(symbol) {
        this.symbol = symbol;
    }
}
OpenPositionsManager.SubscribeInstrumentsCallback.FinishCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        this._owner_.finish();
    }
}
OpenPositionsManager.GetCommandStatusListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccess(message) {
        return void(0);
    }
    onError(error) {
        this._owner_.notifyStateChange(DataManagerState.NOT_LOADED);
        this.clear();
    }
    onCancel() {
        this._owner_.notifyStateChange(DataManagerState.NOT_LOADED);
        this.clear();
    }
    clear() {
        this._owner_.stopTimeout();
        this._owner_.requestsNumber = 0;
        this._owner_.leverageProfilesManagerIsLoaded = false;
        this._owner_.instrumentsManagerIsLoaded = false;
        this._owner_.meLoaded = false;
        this._owner_.storage.clear();
    }
}
OpenPositionsManager.LeverageProfilesManagerStateChangeListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onStateChange(state) {
        this._owner_.leverageProfilesManagerIsLoaded = state.isLoaded();
        if (this._owner_.leverageProfilesManagerIsLoaded) {
            this._owner_.checkLoaded();
        }
    }
}
OpenPositionsManager.InstrumentsManagerStateChangeListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onStateChange(state) {
        this._owner_.instrumentsManagerIsLoaded = state.isLoaded();
        if (this._owner_.instrumentsManagerIsLoaded) {
            this._owner_.checkLoaded();
        }
    }
}
OpenPositionsManager.ReceiveNewMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        this._owner_.processMessage(message);
    }
}
OpenPositionsManager.CompleteRefreshAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        this._owner_.completeRefresh();
    }
}
OpenPositionsManager.TimeoutAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        let error;
        this._owner_.stopTimeout();
        error = "OpenPositionsManager Timeout error : Dependent managers are not all loaded:";
        if (!this._owner_.leverageProfilesManagerIsLoaded) {
            error = error + " Leverages manager";
        }
        if (!this._owner_.instrumentsManagerIsLoaded) {
            error = error + " Instruments manager";
        }
        if (!this._owner_.meLoaded) {
            error = error + " Open positions not loaded";
        }
        this._owner_.meLoaded = false;
        this._owner_.notifyStateChangeWithError(DataManagerState.NOT_LOADED, error);
    }
}
