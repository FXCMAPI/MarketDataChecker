'use strict';
let LogManager = require('./LogManager.js');
let InstrumentDescriptorSplitterByPriceStream = require('./InstrumentDescriptorSplitterByPriceStream.js');
let string_map = require('@gehtsoft/LuaxStdlib-node').string_map;
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let PriceFeedCommandDescriptorBuilder = require('./PriceFeedCommandDescriptorBuilder.js');
let PriceTerminalTypes = require('./PriceTerminalTypes.js');
let SubscriptionInstrumentRequest = require('./SubscriptionInstrumentRequest.js');
let MessageType = require('./MessageType.js');
let list = require('@gehtsoft/LuaxStdlib-node').list;
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let IPriceFeedCommandCallback = require('./IPriceFeedCommandCallback.js');
class OfferSubscriber {
    requestNumberGenerator;
    commandFactory;
    instrumentsProvider;
    sessionStorage;
    logger;
    static create(commandFactory, instrumentsProvider, requestNumberGenerator, sessionStorage) {
        let result;
        result = new OfferSubscriber();
        result.requestNumberGenerator = requestNumberGenerator;
        result.commandFactory = commandFactory;
        result.instrumentsProvider = instrumentsProvider;
        result.sessionStorage = sessionStorage;
        result.logger = LogManager.getLogger();
        return result;
    }
    setLogger(logger) {
        this.logger = logger;
    }
    subscribe(instrumentDescriptors, offerSubscriberCallback, forceReset) {
        let command, splitter, groupedResult, priceStreams, offerIds, i, j, ex, priceFeedCommandCallback, priceTerminalInitializer, mdtMap, pdasPriceTerminalLazyInitializer, mdtId, instrDescriptors, priceStream, priceFeedCommandDescriptorBuilder, keys, priceFeedCommandDescriptorsContainer;
        splitter = new InstrumentDescriptorSplitterByPriceStream();
        groupedResult = splitter.split(this.collectDescriptorsForRequest(instrumentDescriptors));
        priceStreams = groupedResult.getPriceStreams();
        priceFeedCommandCallback = OfferSubscriber.PriceFeedCommandCallback.create(this.logger);
        mdtMap = new string_map();
        try {
            for (i = 0; i <= priceStreams.length - 1; i += 1) {
                priceTerminalInitializer = this.sessionStorage.getPriceTerminalInitializerByPriceStreamId(priceStreams[i]);
                if (priceTerminalInitializer == null) {
                    continue;
                }
                offerIds = groupedResult.getOffersIds(priceStreams[i]);
                if (priceTerminalInitializer.getPriceTerminalType() == PriceTerminalTypes.PDAS) {
                    pdasPriceTerminalLazyInitializer = priceTerminalInitializer;
                    mdtId = pdasPriceTerminalLazyInitializer.getMdtId();
                    instrDescriptors = this.createInstrumentDescriptors(offerIds);
                    if (instrDescriptors.length > 0) {
                        priceStream = instrDescriptors[0].getPriceStreamId();
                    }
                    if (mdtMap.contains(mdtId)) {
                        priceFeedCommandDescriptorsContainer = mdtMap.get(mdtId);
                    }
                    else {
                        priceFeedCommandDescriptorsContainer = new OfferSubscriber.PriceFeedCommandDescriptorsContainer(this);
                        mdtMap.set(mdtId, priceFeedCommandDescriptorsContainer);
                    }
                    priceFeedCommandDescriptorBuilder = this.preparePriceFeedCommandDescriptor(PriceFeedCommandDescriptorBuilder.SUBSCRIBE, priceStream);
                    for (j = 0; j <= instrDescriptors.length - 1; j += 1) {
                        priceFeedCommandDescriptorBuilder.addInstrumentDescriptor(instrDescriptors[j]);
                    }
                    priceFeedCommandDescriptorsContainer.addDescriptor(priceFeedCommandDescriptorBuilder);
                    continue;
                }
                command = this.createPriceFeedCommand(SubscriptionInstrumentRequest.createPriceFeed(this.requestNumberGenerator.getNextRequestNumber(), MessageType.PriceFeed, offerIds, priceFeedCommandCallback), PriceFeedCommandDescriptorBuilder.SUBSCRIBE);
                command.subscribeStatusChange(OfferSubscriber.CommandStatusListener.create(this.logger));
                command.execute();
            }
            if (mdtMap.length() > 0) {
                keys = mdtMap.keys();
                for (i = 0; i <= keys.length - 1; i += 1) {
                    priceFeedCommandDescriptorsContainer = mdtMap.get(keys[i]);
                    command = this.commandFactory.createPriceFeedBatchCommand(priceFeedCommandDescriptorsContainer.getDescriptors(), this.requestNumberGenerator, priceFeedCommandCallback, forceReset);
                    command.subscribeStatusChange(OfferSubscriber.CommandStatusListener.create(this.logger));
                    command.execute();
                }
            }
            offerSubscriberCallback.onSuccess();
        } catch(exTemp1) {
            ex = stdlib.ensureException(exTemp1);
            this.cancel(ex.getMessage(), offerSubscriberCallback);
        }
    }
    cancel(error, offerSubscriberCallback) {
        offerSubscriberCallback.onError(error);
    }
    collectDescriptorsForRequest(data) {
        let result, resultArray, i;
        result = new list();
        for (i = 0; i <= data.length - 1; i += 1) {
            if (data[i].getSubscriptionStatus() == "T" || data[i].getSubscriptionStatus() == "V") {
                result.add(data[i]);
            }
        }
        resultArray = new Array(result.length());
        for (i = 0; i <= result.length() - 1; i += 1) {
            resultArray[i] = result.get(i);
        }
        return resultArray;
    }
    createPriceFeedCommand(subscriptionInstrumentRequest, commandType) {
        let instrumentDescriptors, priceStream;
        instrumentDescriptors = this.createInstrumentDescriptors(subscriptionInstrumentRequest.getOfferIds());
        if (instrumentDescriptors.length > 0) {
            priceStream = instrumentDescriptors[0].getPriceStreamId();
        }
        return this.commandFactory.createPriceFeedCommand(instrumentDescriptors, this.preparePriceFeedCommandDescriptor(commandType, priceStream).build(), subscriptionInstrumentRequest.getRequestNumber(), subscriptionInstrumentRequest.getPriceFeedCommandCallback());
    }
    createInstrumentDescriptors(offerIds) {
        let instrumentDescriptors, instrumentDescriptor, i;
        instrumentDescriptors = new Array(offerIds.length);
        for (i = 0; i <= offerIds.length - 1; i += 1) {
            instrumentDescriptor = this.instrumentsProvider.getInstrumentDescriptorByOfferId(offerIds[i]);
            if (instrumentDescriptor != null) {
                instrumentDescriptors[i] = instrumentDescriptor;
            }
            else {
                throw exception.create(0, "Instrument descriptor for offerId = " + offerIds[i] + " not found.");
            }
        }
        return instrumentDescriptors;
    }
    preparePriceFeedCommandDescriptor(subscriptionType, priceStreamId) {
        let builder;
        builder = new PriceFeedCommandDescriptorBuilder();
        builder.setSubscriptionRequestType(subscriptionType);
        builder.setMarketDepth(1);
        builder.setMdUpdateType(0);
        builder.setFxcmTimingInterval("0");
        builder.setFxcmDasMessagePriceStream(priceStreamId);
        builder.setIncludeWeekends(true);
        return builder;
    }
}
module.exports = OfferSubscriber
OfferSubscriber.PriceFeedCommandDescriptorsContainer = class {
    descriptors;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.descriptors = new list();
    }
    addDescriptor(priceFeedCommandDescriptor) {
        this.descriptors.add(priceFeedCommandDescriptor);
    }
    getDescriptors() {
        let i, result;
        result = new Array(this.descriptors.length());
        for (i = 0; i <= this.descriptors.length() - 1; i += 1) {
            result[i] = this.descriptors.get(i);
        }
        return result;
    }
}
OfferSubscriber.PriceFeedCommandCallback = class extends IPriceFeedCommandCallback {
    logger;
    _owner_;
    constructor(_owner_) {
        super();
        this._owner_ = _owner_;
    }
    static create(logger) {
        let instance;
        instance = new OfferSubscriber.PriceFeedCommandCallback(this);
        instance.logger = logger;
        return instance;
    }
    onError(error) {
        this.logger.error("OfferSubscriber.PriceFeedCommandCallback.onError(): " + error);
    }
}
OfferSubscriber.CommandStatusListener = class {
    logger;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(logger) {
        let instance;
        instance = new OfferSubscriber.CommandStatusListener(this);
        instance.logger = logger;
        return instance;
    }
    onSuccess(message) {
        return void(0);
    }
    onError(error) {
        this.logger.error("OfferSubscriber.CommandStatusListener.onError(): " + error);
    }
    onCancel() {
        return void(0);
    }
}
