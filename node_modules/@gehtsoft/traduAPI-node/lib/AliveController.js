'use strict';
let LogManager = require('./LogManager.js');
let MessageType = require('./MessageType.js');
let ConnectionStatus = require('./ConnectionStatus.js');
let DisconnectedMessageBuilder = require('./DisconnectedMessageBuilder.js');
//@@DocBrief("The class to keep the trading session alive")
class AliveController {
    sessionProvider;
    keepAliveCommand;
    keepAliveCommandListener;
    connectionStatusManager;
    receiveNewMessageListener;
    messageRouter;
    logger;
    isStartedFlag;
    controllersBreaker;
    constructor() {
        this.logger = LogManager.getLogger();
        this.isStartedFlag = false;
        this.controllersBreaker = null;
    }
    static create(sessionProvider, messageRouter, connectionStatusManager, keepAliveCommand, controllersBreaker) {
        let aliveController;
        aliveController = new AliveController();
        aliveController.sessionProvider = sessionProvider;
        aliveController.connectionStatusManager = connectionStatusManager;
        aliveController.messageRouter = messageRouter;
        aliveController.keepAliveCommand = keepAliveCommand;
        aliveController.controllersBreaker = controllersBreaker;
        aliveController.initialize();
        return aliveController;
    }
    initialize() {
        this.createKeepAliveCommandListener();
        this.keepAliveCommand.subscribeStatusChange(this.keepAliveCommandListener);
        this.createReceiveNewMessageListener();
        this.messageRouter.subscribeNewMessageReceive(MessageType.Connected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.LogicError, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Reconnecting, this.receiveNewMessageListener);
    }
    createReceiveNewMessageListener() {
        this.receiveNewMessageListener = new AliveController.ReceiveNewMessageListener(this);
    }
    createKeepAliveCommandListener() {
        this.keepAliveCommandListener = new AliveController.KeepAliveCommandListener(this);
    }
    start() {
        this.isStartedFlag = true;
        this.logger.debug("KeepAlive for " + this.sessionProvider.getSession().getSessionId() + " was started");
        this.keepAliveCommand.setSession(this.sessionProvider.getSession());
        this.keepAliveCommand.execute();
    }
    stop() {
        if (this.isStartedFlag) {
            this.isStartedFlag = false;
            this.logger.debug("KeepAlive was stopped");
            this.keepAliveCommand.stop();
        }
    }
    shutdown() {
        this.stop();
        this.keepAliveCommand.unsubscribeStatusChange(this.keepAliveCommandListener);
        this.messageRouter.unsubscribeNewMessageReceive(MessageType.Connected, this.receiveNewMessageListener);
        this.messageRouter.unsubscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
        this.messageRouter.unsubscribeNewMessageReceive(MessageType.LogicError, this.receiveNewMessageListener);
        this.messageRouter.unsubscribeNewMessageReceive(MessageType.Reconnecting, this.receiveNewMessageListener);
    }
}
module.exports = AliveController
AliveController.ReceiveNewMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        let logicErrorMessage;
        this._owner_.logger.debug("AliveController. Receive message: " + message.getType());
        if (message.getType() == MessageType.Connected && !this._owner_.isStartedFlag) {
            this._owner_.logger.debug("KeepAlive for " + this._owner_.sessionProvider.getSession().getSessionId() + " was executed");
            this._owner_.isStartedFlag = true;
            this._owner_.keepAliveCommand.setSession(this._owner_.sessionProvider.getSession());
            this._owner_.keepAliveCommand.execute();
        } else if (message.getType() == MessageType.Reconnecting) {
            this._owner_.stop();
        } else if (message.getType() == MessageType.Disconnected) {
            this._owner_.stop();
        } else if (message.getType() == MessageType.LogicError) {
            this._owner_.stop();
            logicErrorMessage = message;
            this._owner_.logger.error("KeepAlive was stopped due to the error: " + logicErrorMessage.getError());
            this._owner_.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.DISCONNECTED, logicErrorMessage.getError());
        }
    }
}
AliveController.KeepAliveCommandListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccess(message) {
        return void(0);
    }
    onError(error) {
        this._owner_.keepAliveCommand.stop();
        this._owner_.logger.warning("KeepAlive got error: " + error);
        if (this._owner_.controllersBreaker != null) {
            this._owner_.controllersBreaker.stopAll();
        }
        this._owner_.messageRouter.publishNewMessage([new DisconnectedMessageBuilder().build()]);
        this._owner_.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.DISCONNECTED, error);
    }
    onCancel() {
        this._owner_.logger.debug("KeepAlive was stopped because CommandStatusListener raises onCancel event");
        this._owner_.keepAliveCommand.stop();
    }
}
