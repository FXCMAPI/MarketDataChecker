'use strict';
let LogManager = require('./LogManager.js');
let LoginParametersChecker = require('./LoginParametersChecker.js');
let JWTParser = require('./JWTParser.js');
let ConnectionStatus = require('./ConnectionStatus.js');
class LoginByJWTUsingSSOCommand {
    jwt;
    jwtStr;
    tradingSystemUrl;
    connection;
    logger;
    loginParametersChecker;
    loginController;
    loginCallback;
    connectionStatusManager;
    constructor() {
        this.logger = LogManager.getLogger();
        this.loginParametersChecker = new LoginParametersChecker();
        this.loginCallback = new LoginByJWTUsingSSOCommand.LoginCallback(this);
        this.jwt = null;
    }
    static create(loginController, connectionStatusManager, jwtStr, tradingSystemUrl, connection) {
        let result;
        result = new LoginByJWTUsingSSOCommand();
        result.loginController = loginController;
        result.jwtStr = jwtStr;
        result.tradingSystemUrl = tradingSystemUrl;
        result.connection = connection;
        result.connectionStatusManager = connectionStatusManager;
        return result;
    }
    stop() {
        this.loginController.stop();
    }
    execute() {
        let checkResult, parser;
        this.logger.info("LoginByJWTUsingSSOCommand. start login process by jwt");
        this.logger.debug("LoginByJWTUsingSSOCommand. jwt: '" + this.jwtStr + "'");
        parser = new JWTParser();
        this.jwt = parser.parse(this.jwtStr);
        checkResult = this.loginParametersChecker.checkAttachWithJWT(this.jwt, this.tradingSystemUrl, this.connection);
        if (checkResult.isCheckPassed()) {
            this.loginController.loginBySsoToken(this.jwt.getLogin(), this.jwt.getSsoToken(), this.tradingSystemUrl, this.connection, this.loginCallback);
        }
        else {
            this.logger.warning("LoginByJWTUsingSSOCommand. credentials not valid. code: " + (checkResult.getCode()).toString() + " error: " + checkResult.getError());
            this.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.DISCONNECTED, checkResult.getError());
        }
    }
    subscribeStatusChange(callback) {
        return void(0);
    }
    unsubscribeStatusChange(callback) {
        return void(0);
    }
}
module.exports = LoginByJWTUsingSSOCommand
LoginByJWTUsingSSOCommand.LoginCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onLoginError(error) {
        this._owner_.logger.warning("LoginByJWTUsingSSOCommand. OnLoginError: " + error.getMessage());
        this._owner_.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.DISCONNECTED, error.getMessage());
    }
    onTradingTerminalRequest(tradingTerminalSelector, tradingTerminals) {
        let i, tradingTerminal;
        this._owner_.logger.info("LoginByJWTUsingSSOCommand. onTradingTerminalRequest: ");
        if (this._owner_.jwt != null) {
            tradingTerminal = null;
            for (i = 0; i <= tradingTerminals.length - 1; i += 1) {
                tradingTerminal = tradingTerminals[i];
                if (tradingTerminal.getSubId() == this._owner_.jwt.getTradingSessionSubId()) {
                    this._owner_.logger.info("LoginByJWTUsingSSOCommand. onTradingTerminalRequest: selected " + tradingTerminal.getSubId());
                    tradingTerminalSelector.selectTerminal(tradingTerminal);
                    break;
                }
            }
        }
        else {
            this._owner_.logger.warning("LoginByJWTUsingSSOCommand. onTradingTerminalRequest: jwt == nil ");
        }
    }
    onPinCodeRequest(pinCodeSetter) {
        this._owner_.logger.warning("LoginByJWTUsingSSOCommand. onPinCodeRequest: not implemented yet");
        this._owner_.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.DISCONNECTED, "onPinCodeRequest: not implemented yet");
    }
}
