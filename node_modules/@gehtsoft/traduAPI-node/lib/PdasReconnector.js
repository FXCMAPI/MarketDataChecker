'use strict';
let LogManager = require('./LogManager.js');
let MessageType = require('./MessageType.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
class PdasReconnector {
    static get MAX_RECONNECTION_ATTEMPTS() { return 3; }
    static get ATTEMPT_DELAY_IN_MSC() { return 300; }
    priceTerminalLazyInitializer;
    messageRouter;
    logger;
    receiveNewMessageListener;
    tradingSessionConnectionState;
    reconnectAttemptsCounter;
    pdasPriceTerminalStatusManager;
    attemptScheduler;
    attemptDelay;
    constructor() {
        this.logger = LogManager.getLogger();
        this.receiveNewMessageListener = new PdasReconnector.ReceiveNewMessageListener(this);
        this.reconnectAttemptsCounter = 0;
        this.attemptScheduler = null;
        this.attemptDelay = PdasReconnector.ATTEMPT_DELAY_IN_MSC;
    }
    static create(messageRouter, pdasPriceTerminalStatusManager, priceTerminalLazyInitializer) {
        let result;
        result = new PdasReconnector();
        result.priceTerminalLazyInitializer = priceTerminalLazyInitializer;
        result.messageRouter = messageRouter;
        result.pdasPriceTerminalStatusManager = pdasPriceTerminalStatusManager;
        result.tradingSessionConnectionState = MessageType.Connected;
        return result;
    }
    start() {
        this.messageRouter.subscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Connected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Reconnecting, this.receiveNewMessageListener);
        this.pdasPriceTerminalStatusManager.subscribeConnectionStatusChange(this);
    }
    stop() {
        this.messageRouter.unsubscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
        this.messageRouter.unsubscribeNewMessageReceive(MessageType.Connected, this.receiveNewMessageListener);
        this.messageRouter.unsubscribeNewMessageReceive(MessageType.Reconnecting, this.receiveNewMessageListener);
        this.pdasPriceTerminalStatusManager.unsubscribeConnectionStatusChange(this);
        if (this.attemptScheduler != null) {
            this.attemptScheduler.stop();
        }
    }
    setReconnectorAttemptDelay(attemptDelay) {
        this.attemptDelay = attemptDelay;
    }
    reconnect(error) {
        let callback;
        this.reconnectAttemptsCounter = this.reconnectAttemptsCounter + 1;
        if (this.reconnectAttemptsCounter <= PdasReconnector.MAX_RECONNECTION_ATTEMPTS) {
            this.logger.warning("Pdas attempt to reconnect:" + (this.reconnectAttemptsCounter).toString());
            this.priceTerminalLazyInitializer.reset();
            callback = new PdasReconnector.GetInitializedPriceTerminalCallback(this);
            this.priceTerminalLazyInitializer.getInitializedPriceTerminal(callback);
        }
        else {
            this.logger.warning("Pdas failed to reconnect. Change state RECONNECTING");
            this.reconnectAttemptsCounter = 0;
            this.pdasPriceTerminalStatusManager.onReconnectError(error);
        }
    }
    onConnectionStatusChange(status) {
        let error;
        if (this.tradingSessionConnectionState == MessageType.Connected && status.isReconnecting()) {
            error = "Pdas connection broken.";
            if (status.hasError()) {
                error = error + " " + status.getError().getMessage();
                this.logger.warning("Pdas connection broken with error: '" + error + "'. Start reconnecting");
            }
            else {
                this.logger.warning("Pdas connection broken. Start reconnecting");
            }
            this.reconnect(error);
        }
    }
}
module.exports = PdasReconnector
PdasReconnector.ReceiveNewMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        this._owner_.tradingSessionConnectionState = message.getType();
    }
}
PdasReconnector.AttemptAction = class {
    error;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.error = "";
    }
    invoke() {
        if (this._owner_.attemptScheduler != null) {
            this._owner_.attemptScheduler.stop();
            this._owner_.reconnect(this.error);
        }
    }
    setError(error) {
        this.error = error;
    }
}
PdasReconnector.GetInitializedPriceTerminalCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onError(error) {
        let attemptAction;
        attemptAction = new PdasReconnector.AttemptAction(this._owner_);
        attemptAction.setError(error);
        this._owner_.attemptScheduler = scheduler.create(this._owner_.attemptDelay, attemptAction);
        this._owner_.attemptScheduler.startWithDelay();
    }
    onSuccess(result) {
        this._owner_.logger.info("Pdas connection is restored.");
        this._owner_.reconnectAttemptsCounter = 0;
        this._owner_.pdasPriceTerminalStatusManager.onReconnectSuccess();
    }
}
