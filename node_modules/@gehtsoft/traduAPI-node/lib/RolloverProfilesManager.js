'use strict';
let DataManagerState = require('./DataManagerState.js');
let DataManagerStatePublisher = require('./DataManagerStatePublisher.js');
let LogManager = require('./LogManager.js');
let queue = require('@gehtsoft/LuaxStdlib-node').queue;
let MessageType = require('./MessageType.js');
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let FXConnectLiteErrorCodes = require('./FXConnectLiteErrorCodes.js');
let StateStatusUtils = require('./StateStatusUtils.js');
let list = require('@gehtsoft/LuaxStdlib-node').list;
let StringValueObject = require('./StringValueObject.js');
let GetProfilesQuery = require('./GetProfilesQuery.js');
let CollectionUtils = require('./CollectionUtils.js');
let string_map = require('@gehtsoft/LuaxStdlib-node').string_map;
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let ExecutionTimeEvenUtil = require('./ExecutionTimeEvenUtil.js');
let ExecutionTimeEventName = require('./ExecutionTimeEventName.js');
let StringUtil = require('./StringUtil.js');
class RolloverProfilesManager {
    static get TIMEOUT_INTERVAL() { return 30000; }
    state;
    stateChangePublisher;
    storage;
    messageRouter;
    commandFactory;
    sessionProvider;
    messageFactory;
    requestNumberGenerator;
    messageExecutor;
    receiveNewMessageListener;
    connected;
    logger;
    accountsManager;
    requestsNumber;
    rolloversCalculator;
    instrumentsProvider;
    eventRefresh;
    timeOutScheduler;
    requestAccounts;
    timeoutInterval;
    sendsQueue;
    constructor() {
        this.requestsNumber = 0;
        this.state = new DataManagerState();
        this.stateChangePublisher = new DataManagerStatePublisher();
        this.setReceiveNewMessageListener();
        this.logger = LogManager.getLogger();
        this.timeOutScheduler = null;
        this.requestAccounts = null;
        this.timeoutInterval = RolloverProfilesManager.TIMEOUT_INTERVAL;
        this.sendsQueue = new queue();
    }
    static create(rolloversCalculator, storage, accountsManager, instrumentsProvider, commandFactory, messageRouter, messageExecutor, sessionProvider, messageFactory, requestNumberGenerator) {
        let result;
        result = new RolloverProfilesManager();
        result.commandFactory = commandFactory;
        result.messageRouter = messageRouter;
        result.messageExecutor = messageExecutor;
        result.sessionProvider = sessionProvider;
        result.messageFactory = messageFactory;
        result.requestNumberGenerator = requestNumberGenerator;
        result.accountsManager = accountsManager;
        result.storage = storage;
        result.rolloversCalculator = rolloversCalculator;
        result.instrumentsProvider = instrumentsProvider;
        result.subscribeOnRequiredMessages();
        return result;
    }
    subscribeOnRequiredMessages() {
        this.messageRouter.subscribeNewMessageReceive(MessageType.GetRolloverProfiles, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Connected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Reconnecting, this.receiveNewMessageListener);
    }
    setReceiveNewMessageListener() {
        this.receiveNewMessageListener = RolloverProfilesManager.ReceiveNewMessageListener.create(this);
    }
    getRolloverBuy(instrument, account) {
        if (instrument == null) {
            this.logger.error("RolloverProfilesManager.getRolloverBuy(): instrument is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "instrument is not set");
        }
        if (account == null) {
            this.logger.error("RolloverProfilesManager.getRolloverBuy(): account is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "account is not set");
        }
        return this.rolloversCalculator.getRollover(instrument, account, true);
    }
    getRolloverSell(instrument, account) {
        if (instrument == null) {
            this.logger.error("RolloverProfilesManager.getRolloverSell(): instrument is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "instrument is not set");
        }
        if (account == null) {
            this.logger.error("RolloverProfilesManager.getRolloverSell(): account is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "account is not set");
        }
        return this.rolloversCalculator.getRollover(instrument, account, false);
    }
    notifyStateChangeWithError(stateStatus, error) {
        StateStatusUtils.notifyStateChangeWithError(this.state, this.stateChangePublisher, stateStatus, error, this.logger, "RolloverManager");
    }
    notifyStateChange(stateStatus) {
        this.logger.debug("RolloverManager. State status changed: " + (stateStatus).toString());
        this.state.setState(stateStatus);
        this.stateChangePublisher.notifyStateChange(this.state);
    }
    subscribeStateChange(listener) {
        if (listener == null) {
            this.logger.error("RolloverProfilesManager.subscribeStateChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.stateChangePublisher.subscribe(listener);
    }
    unsubscribeStateChange(listener) {
        if (listener == null) {
            this.logger.error("RolloverProfilesManager.unsubscribeStateChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.stateChangePublisher.unsubscribe(listener);
    }
    getState() {
        return this.state;
    }
    refresh() {
        let queueItem, offerIdsList, instrumentDescriptors, instrumentDescriptor, i;
        this.logger.info("RolloverManager. Load all rollover profiles from server");
        if (!this.connected) {
            this.logger.warning("RolloverManager. Session not connected");
            return;
        }
        if (this.getState().isLoading()) {
            this.logger.warning("RolloverManager. Manager is still loading");
            return;
        }
        offerIdsList = new list();
        instrumentDescriptors = this.instrumentsProvider.getAllInstrumentDescriptors();
        for (i = 0; i <= instrumentDescriptors.length - 1; i += 1) {
            instrumentDescriptor = instrumentDescriptors[i];
            if (instrumentDescriptor.getSubscriptionStatus() == "T" || instrumentDescriptor.getSubscriptionStatus() == "V") {
                offerIdsList.add(StringValueObject.create(instrumentDescriptor.getOfferId()));
            }
        }
        queueItem = GetProfilesQuery.create(CollectionUtils.stringListToArray(offerIdsList), new RolloverProfilesManager.ActionStartRefresh(this), new RolloverProfilesManager.ActionStopRefresh(this));
        this.processRolloverProfilesCommandQuery(queueItem);
    }
    processRolloverProfilesCommandQuery(queueItem) {
        this.sendsQueue.enqueue(queueItem);
        if (this.sendsQueue.length() == 1) {
            this.checkQueue();
        }
    }
    checkQueue() {
        let accounts, queueItem, accountIds, getRolloverProfilesCommand, i, timeoutAction;
        if (this.sendsQueue.length() > 0) {
            queueItem = this.sendsQueue.peek();
            accounts = this.accountsManager.getAccountsInfo();
            this.requestsNumber = 0;
            queueItem.getActionStart().invoke();
            this.requestAccounts = new string_map();
            if (queueItem.getOfferIds().length > 0 && accounts.length > 0) {
                timeoutAction = new RolloverProfilesManager.TimeoutAction(this);
                this.timeOutScheduler = scheduler.create(this.timeoutInterval, timeoutAction);
                this.timeOutScheduler.startWithDelay();
                accountIds = new Array(accounts.length);
                this.requestsNumber = accounts.length;
                for (i = 0; i <= accounts.length - 1; i += 1) {
                    accountIds[i] = accounts[i].getId();
                    this.requestAccounts.set(accountIds[i], StringValueObject.create(accountIds[i]));
                }
                getRolloverProfilesCommand = this.commandFactory.createGetAccountRolloverProfilesCommand(accountIds, queueItem.getOfferIds(), this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator);
                getRolloverProfilesCommand.execute();
            }
            else {
                this.logger.warning("RolloverProfilesManager. No instruments descriptors or/and accounts found for checkQueue()");
                this.sendsQueue.dequeue();
                this.checkQueue();
                queueItem.getActionStop().invoke();
            }
        }
    }
    processRolloverProfiles(getRolloverProfilesMessage) {
        let leverageProfiles, accountId, queueItem;
        leverageProfiles = getRolloverProfilesMessage.getRolloverProfiles();
        this.requestsNumber = this.requestsNumber - 1;
        accountId = getRolloverProfilesMessage.getAccountId();
        if (this.requestAccounts.contains(accountId)) {
            this.requestAccounts.remove(accountId);
        }
        this.storage.addRolloverProfiles(leverageProfiles);
        if (this.requestsNumber == 0 && this.sendsQueue.length() > 0) {
            this.stopTimeout();
            queueItem = this.sendsQueue.dequeue();
            this.checkQueue();
            queueItem.getActionStop().invoke();
        }
    }
    processMessage(message) {
        this.logger.debug("RolloverProfilesManager. Receive message: " + message.getType());
        if (message.getType() == MessageType.GetRolloverProfiles) {
            this.processRolloverProfiles(message);
        } else if (message.getType() == MessageType.Connected) {
            this.connected = true;
            this.refresh();
        } else if (message.getType() == MessageType.Disconnected) {
            this.stopTimeout();
            this.connected = false;
            this.storage.clear();
            this.notifyStateChange(DataManagerState.NOT_LOADED);
        } else if (message.getType() == MessageType.Reconnecting) {
            this.connected = false;
        }
    }
    stopTimeout() {
        if (this.timeOutScheduler != null) {
            this.timeOutScheduler.stop();
            this.timeOutScheduler = null;
        }
    }
}
module.exports = RolloverProfilesManager
RolloverProfilesManager.ActionStartRefresh = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        this._owner_.eventRefresh = ExecutionTimeEvenUtil.eventStart(ExecutionTimeEventName.RolloverProfilesManagerRefreshTime);
        this._owner_.notifyStateChange(DataManagerState.LOADING);
    }
}
RolloverProfilesManager.ActionStopRefresh = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        ExecutionTimeEvenUtil.eventStop(this._owner_.eventRefresh);
        this._owner_.notifyStateChange(DataManagerState.LOADED);
    }
    invokeWithError(error) {
        ExecutionTimeEvenUtil.eventStopWithError(this._owner_.eventRefresh, error);
        this._owner_.notifyStateChangeWithError(DataManagerState.NOT_LOADED, error);
    }
}
RolloverProfilesManager.TimeoutAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        let error, queueItem;
        this._owner_.stopTimeout();
        error = "RolloverProfilesManager timed out on loading profiles";
        if (this._owner_.requestAccounts != null && this._owner_.requestAccounts.keys().length > 0) {
            error = error + " for account(s): " + StringUtil.arrayToString(this._owner_.requestAccounts.keys());
        }
        if (this._owner_.sendsQueue.length() > 0) {
            queueItem = this._owner_.sendsQueue.dequeue();
            this._owner_.checkQueue();
            queueItem.getActionStop().invokeWithError(error);
        }
    }
}
RolloverProfilesManager.ReceiveNewMessageListener = class {
    owner;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(owner) {
        let instance;
        instance = new RolloverProfilesManager.ReceiveNewMessageListener(this);
        instance.owner = owner;
        return instance;
    }
    onNewMessageReceive(message) {
        this.owner.processMessage(message);
    }
}
