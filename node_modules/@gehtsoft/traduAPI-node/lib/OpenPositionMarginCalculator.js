'use strict';
let OpenPositionCalculatedMarginFields = require('./OpenPositionCalculatedMarginFields.js');
let OpenPositionMarginCalculatorData = require('./OpenPositionMarginCalculatorData.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let MarginPercentHedgeCalculator = require('./MarginPercentHedgeCalculator.js');
let LogManager = require('./LogManager.js');
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let FXConnectLiteErrorCodes = require('./FXConnectLiteErrorCodes.js');
class OpenPositionMarginCalculator {
    usedMarginProvider;
    rawAccountsProvider;
    openPositionsProvider;
    calculate(openPosition) {
        let openPositionMarginCalculatorData, allOpenPositionCalculatedMarginFields, specificOnePositionCalculatedMarginFields, dependentPositions, i;
        if (openPosition == null) {
            return OpenPositionCalculatedMarginFields.create("", 0, 0);
        }
        dependentPositions = this.openPositionsProvider.getInternalOpenPositionByAccountAndOffer(openPosition.getAccountId(), openPosition.getOfferId());
        openPositionMarginCalculatorData = new OpenPositionMarginCalculatorData();
        allOpenPositionCalculatedMarginFields = this.calculateAllImpl(dependentPositions, openPositionMarginCalculatorData);
        specificOnePositionCalculatedMarginFields = OpenPositionCalculatedMarginFields.create(openPosition.getTradeID(), 0, 0);
        for (i = 0; i <= allOpenPositionCalculatedMarginFields.length - 1; i += 1) {
            if (openPosition.getTradeID() == allOpenPositionCalculatedMarginFields[i].getTradeId()) {
                specificOnePositionCalculatedMarginFields = allOpenPositionCalculatedMarginFields[i];
                break;
            }
        }
        return specificOnePositionCalculatedMarginFields;
    }
    calculateNonProgressive(openPosition, buyLots, sellLots, marginDescriptor, marginPercentForHedgedTrades) {
        if (marginPercentForHedgedTrades == 1) {
            return this.calculateNonProgressive100Hedge(openPosition, buyLots, sellLots, marginDescriptor);
        } else if (marginPercentForHedgedTrades == 0.5) {
            return this.calculateNonProgressive50Hedge(openPosition, buyLots, sellLots, marginDescriptor);
        } else if (marginPercentForHedgedTrades == 0.0) {
            return this.calculateNonProgressive0Hedge(openPosition, buyLots, sellLots, marginDescriptor);
        }
        return OpenPositionCalculatedMarginFields.create(openPosition.getTradeID(), 0.0, 0.0);
    }
    calculateNonProgressive100Hedge(openPosition, buyLots, sellLots, marginDescriptor) {
        let usedMargin, usedMarginAware, openLots;
        openLots = openPosition.getAmount();
        usedMargin = openLots * marginDescriptor.getUsedMargin();
        usedMarginAware = openLots * marginDescriptor.getUsedMarginAware();
        return OpenPositionCalculatedMarginFields.create(openPosition.getTradeID(), usedMargin, usedMarginAware);
    }
    calculateNonProgressive50Hedge(openPosition, buyLots, sellLots, marginDescriptor) {
        let usedMargin, usedMarginAware, openLots, buyLotsWithoutPos, sellLotsWithoutPos, isBuy;
        openLots = openPosition.getAmount();
        isBuy = openPosition.getBuySell() == "B";
        if (isBuy) {
            buyLotsWithoutPos = buyLots - openLots;
            sellLotsWithoutPos = sellLots;
        }
        else {
            buyLotsWithoutPos = buyLots;
            sellLotsWithoutPos = sellLots - openLots;
        }
        if (buyLots - sellLots >= 0 && buyLotsWithoutPos - sellLotsWithoutPos >= 0 || sellLots - buyLots >= 0 && sellLotsWithoutPos - buyLotsWithoutPos >= 0) {
            if (buyLots - sellLots > 0 && isBuy || sellLots - buyLots > 0 && !isBuy) {
                usedMargin = openLots * marginDescriptor.getUsedMargin();
                usedMarginAware = openLots * marginDescriptor.getUsedMarginAware();
            }
            else {
                usedMargin = 0;
                usedMarginAware = 0;
            }
        }
        else {
            usedMargin = stdlib.abs((buyLots - sellLots)) * marginDescriptor.getUsedMargin();
            usedMarginAware = stdlib.abs((buyLots - sellLots)) * marginDescriptor.getUsedMarginAware();
        }
        return OpenPositionCalculatedMarginFields.create(openPosition.getTradeID(), usedMargin, usedMarginAware);
    }
    calculateNonProgressive0Hedge(openPosition, buyLots, sellLots, marginDescriptor) {
        let usedMargin, usedMarginAware, openLots, buyLotsWithoutPos, sellLotsWithoutPos, isBuy;
        usedMargin = 0;
        usedMarginAware = 0;
        openLots = openPosition.getAmount();
        isBuy = openPosition.getBuySell() == "B";
        if (isBuy) {
            buyLotsWithoutPos = buyLots - openLots;
            sellLotsWithoutPos = sellLots;
        }
        else {
            buyLotsWithoutPos = buyLots;
            sellLotsWithoutPos = sellLots - openLots;
        }
        if (buyLots - sellLots >= 0 && buyLotsWithoutPos - sellLotsWithoutPos >= 0 || sellLots - buyLots >= 0 && sellLotsWithoutPos - buyLotsWithoutPos >= 0) {
            if (buyLots - sellLots > 0 && isBuy || sellLots - buyLots > 0 && !isBuy) {
                usedMargin = openLots * marginDescriptor.getUsedMargin();
                usedMarginAware = openLots * marginDescriptor.getUsedMarginAware();
            }
            else {
                usedMargin = openLots * marginDescriptor.getUsedMargin() * -1;
                usedMarginAware = openLots * marginDescriptor.getUsedMarginAware() * -1;
            }
        }
        else {
            usedMargin = stdlib.abs((buyLots - sellLots)) * marginDescriptor.getUsedMargin();
            usedMarginAware = stdlib.abs((buyLots - sellLots)) * marginDescriptor.getUsedMarginAware();
            usedMargin = usedMargin + stdlib.abs((buyLotsWithoutPos - sellLotsWithoutPos)) * marginDescriptor.getUsedMargin() * -1;
            usedMarginAware = usedMarginAware + stdlib.abs((buyLotsWithoutPos - sellLotsWithoutPos)) * marginDescriptor.getUsedMarginAware() * -1;
        }
        return OpenPositionCalculatedMarginFields.create(openPosition.getTradeID(), usedMargin, usedMarginAware);
    }
    calculateAll(openPositions) {
        let openPositionMarginCalculatorData;
        openPositionMarginCalculatorData = new OpenPositionMarginCalculatorData();
        return this.calculateAllImpl(openPositions, openPositionMarginCalculatorData);
    }
    calculateImpl(openPosition, openPositionMarginCalculatorData) {
        let accountId, usedMargin, usedMarginAware, account, marginDescriptor, openPositionsDirectionsData, buyLots, sellLots, marginPercentForHedgedTrades;
        usedMargin = 0.0;
        usedMarginAware = 0.0;
        accountId = openPosition.getAccountId();
        account = this.rawAccountsProvider.getAccountById(accountId);
        if (account != null) {
            marginDescriptor = this.usedMarginProvider.get(accountId, account.getLeverageProfileId(), openPosition.getOfferId());
            if (marginDescriptor != null) {
                openPositionsDirectionsData = openPositionMarginCalculatorData.addOpenPosition(accountId, openPosition);
                buyLots = openPositionsDirectionsData.getAllBuyLots();
                sellLots = openPositionsDirectionsData.getAllSellLots();
                marginPercentForHedgedTrades = MarginPercentHedgeCalculator.calculate(account.getHedgeMarginPCT(), account.getMaintenanceType());
                return this.calculateNonProgressive(openPosition, buyLots, sellLots, marginDescriptor, marginPercentForHedgedTrades / 100);
            }
        }
        return OpenPositionCalculatedMarginFields.create(openPosition.getTradeID(), usedMargin, usedMarginAware);
    }
    calculateAllImpl(openPositions, openPositionMarginCalculatorData) {
        let openPositionCalculatedMarginFields, i;
        openPositionCalculatedMarginFields = new Array(openPositions.length);
        for (i = 0; i <= openPositions.length - 1; i += 1) {
            openPositionCalculatedMarginFields[i] = this.calculateImpl(openPositions[i], openPositionMarginCalculatorData);
        }
        return openPositionCalculatedMarginFields;
    }
    static create(usedMarginProvider, rawAccountsProvider, openPositionsProvider) {
        let openPositionMarginCalculator;
        if (usedMarginProvider == null) {
            LogManager.getLogger().error("OpenPositionMarginCalculator.create(): usedMarginProvider is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "usedMarginProvider is not set");
        }
        if (rawAccountsProvider == null) {
            LogManager.getLogger().error("OpenPositionMarginCalculator.create(): rawAccountsProvider is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "rawAccountsProvider is not set");
        }
        if (openPositionsProvider == null) {
            LogManager.getLogger().error("OpenPositionMarginCalculator.create(): openPositionsProvider is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "openPositionsProvider is not set");
        }
        openPositionMarginCalculator = new OpenPositionMarginCalculator();
        openPositionMarginCalculator.usedMarginProvider = usedMarginProvider;
        openPositionMarginCalculator.rawAccountsProvider = rawAccountsProvider;
        openPositionMarginCalculator.openPositionsProvider = openPositionsProvider;
        return openPositionMarginCalculator;
    }
}
module.exports = OpenPositionMarginCalculator
