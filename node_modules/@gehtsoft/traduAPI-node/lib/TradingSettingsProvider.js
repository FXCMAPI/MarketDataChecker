'use strict';
let MathUtil = require('./MathUtil.js');
let Instrument = require('./Instrument.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let DateTimeParser = require('./DateTimeParser.js');
let csvParser = require('@gehtsoft/LuaxStdlib-node').csvParser;
let variantCast = require('@gehtsoft/LuaxStdlib-node').variantCast;
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let PriceTerminalTypes = require('./PriceTerminalTypes.js');
let CommonPublisher = require('./CommonPublisher.js');
//@@DocBrief("The class provides access to the trading system settings and properties")
class TradingSettingsProvider {
    systemSettingsProvider;
    sessionStorage;
    instrumentsProvider;
    pipCostProvider;
    calculationPathCrossSymbolsProvider;
    systemPropertyChangeListener;
    constructor() {
        this.systemSettingsProvider = null;
    }
    static create(systemSettingsProvider, sessionStorage, instrumentsProvider, pipCostProvider, calculationPathCrossSymbolsProvider) {
        let result;
        result = new TradingSettingsProvider();
        result.systemSettingsProvider = systemSettingsProvider;
        result.sessionStorage = sessionStorage;
        result.instrumentsProvider = instrumentsProvider;
        result.pipCostProvider = pipCostProvider;
        result.calculationPathCrossSymbolsProvider = calculationPathCrossSymbolsProvider;
        result.setSystemPropertyChangeListener();
        return result;
    }
    setSystemPropertyChangeListener() {
        this.systemPropertyChangeListener = new TradingSettingsProvider.SystemPropertyChangeListener(this);
        this.systemSettingsProvider.subscribeSystemPropertyChange(this.systemPropertyChangeListener);
    }
    subscribeMarketOpenChange(listener) {
        this.systemPropertyChangeListener.subscribeMarketOpenChange(listener);
    }
    unsubscribeMarketOpenChange(listener) {
        this.systemPropertyChangeListener.unsubscribeMarketOpenChange(listener);
    }
    getCrossSymbols(symbol, account) {
        return this.calculationPathCrossSymbolsProvider.findCrossSymbolsByAccount(symbol, account, false);
    }
    isMarketOpen() {
        let result;
        result = this.systemSettingsProvider.getPropertyByName("MARKET_OPEN");
        return "Y" == result;
    }
    getBaseUnitSize(instrument, account) {
        let instrBaseUnitSize, instrumentType, accountBaseUnitSize;
        if (instrument == null || account == null) {
            return -1;
        }
        instrBaseUnitSize = instrument.getBaseUnitSize();
        if (instrBaseUnitSize == 0) {
            instrBaseUnitSize = 1;
        }
        instrumentType = instrument.getInstrumentType();
        if (instrumentType == Instrument.TYPE_FOREX) {
            accountBaseUnitSize = account.getBaseUnitSize();
            if (accountBaseUnitSize == 0) {
                accountBaseUnitSize = this.systemSettingsProvider.getBaseUnitSize();
            }
            instrBaseUnitSize = MathUtil.maxInt(accountBaseUnitSize, instrBaseUnitSize);
        }
        return instrBaseUnitSize;
    }
    getMinQuantity(instrument, account) {
        let instrBaseUnitSize, minLots;
        if (instrument == null || account == null) {
            return -1;
        }
        instrBaseUnitSize = this.getBaseUnitSize(instrument, account);
        minLots = instrument.getMinQuantity();
        if (minLots == 0) {
            minLots = instrBaseUnitSize;
        }
        if (minLots % instrBaseUnitSize != 0) {
            minLots = Math.trunc(minLots / instrBaseUnitSize + 0.5) * instrBaseUnitSize;
        }
        return MathUtil.maxInt(instrBaseUnitSize, minLots);
    }
    getMaxQuantity(instrument, account) {
        let maxQuantity;
        if (instrument == null) {
            return -1;
        }
        if (instrument.getInstrumentType() == Instrument.TYPE_FOREX) {
            if (account == null) {
                return -1;
            }
            maxQuantity = account.getOrderAmountLimit();
            if (maxQuantity != 0) {
                return maxQuantity;
            }
        }
        return instrument.getMaxQuantity();
    }
    getPipCost(instrument, account) {
        return this.pipCostProvider.getPipCost(instrument, account);
    }
    getFinancialDate(date, symbol) {
        let dateUTC, jdn, disp;
        dateUTC = stdlib.toutc(date);
        jdn = stdlib.toJdn(dateUTC);
        disp = this.getStartFinancialDayJDN(symbol);
        if (this.isPdas(symbol) && disp > 0.0) {
            jdn = jdn + 1;
            jdn = jdn - disp;
        }
        dateUTC = stdlib.fromJdn(jdn);
        return DateTimeParser.toFormatDateString(dateUTC);
    }
    getStartFinancialDayJDN(symbol) {
        let endTradingDayStr, arr, h, m, parser;
        h = 0;
        m = 0;
        endTradingDayStr = this.getStartFinancialDay(symbol);
        if (endTradingDayStr != null && stdlib.len(endTradingDayStr) > 0) {
            parser = new csvParser();
            parser.valueSeparator = ":";
            arr = parser.splitLine(endTradingDayStr);
            h = variantCast.castToInt(variantCast.fromString(arr[0]));
            if (arr.length > 1) {
                m = variantCast.castToInt(variantCast.fromString(arr[1]));
            }
        }
        return h / 24 + m / 1440;
    }
    isPdas(symbol) {
        let instrumentDescriptor, priceTerminalInitializer;
        instrumentDescriptor = this.instrumentsProvider.getInstrumentDescriptorBySymbol(symbol);
        if (instrumentDescriptor == null) {
            throw exception.create(0, "TradingSettingsProvider: not found instrument '" + symbol + "'");
        }
        priceTerminalInitializer = this.sessionStorage.getPriceTerminalInitializerByPriceStreamId(instrumentDescriptor.getPriceStreamId());
        if (priceTerminalInitializer == null) {
            throw exception.create(0, "TradingSettingsProvider: not found terminal initializer for price stream '" + instrumentDescriptor.getPriceStreamId() + "'");
        }
        return priceTerminalInitializer.getPriceTerminalType() == PriceTerminalTypes.PDAS;
    }
    getStartFinancialDay(symbol) {
        if (!this.isPdas(symbol)) {
            return "00:00:00";
        }
        return this.systemSettingsProvider.getPropertyByName("END_TRADING_DAY");
    }
}
module.exports = TradingSettingsProvider
TradingSettingsProvider.SystemPropertyChangeListener = class {
    marketOpenUpdatedPublisher;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.marketOpenUpdatedPublisher = new CommonPublisher();
    }
    onChange(propertyName) {
        if (propertyName == "MARKET_OPEN") {
            this.marketOpenUpdatedPublisher.notifyAction(TradingSettingsProvider.MarketOpenUpdatedAction.create(this._owner_.isMarketOpen()));
        }
    }
    subscribeMarketOpenChange(listener) {
        this.marketOpenUpdatedPublisher.subscribe(listener);
    }
    unsubscribeMarketOpenChange(listener) {
        this.marketOpenUpdatedPublisher.unsubscribe(listener);
    }
}
TradingSettingsProvider.MarketOpenUpdatedAction = class {
    listener;
    isOpened;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(isOpened) {
        let result;
        result = new TradingSettingsProvider.MarketOpenUpdatedAction(this);
        result.isOpened = isOpened;
        return result;
    }
    setListener(listener) {
        this.listener = listener;
    }
    execute() {
        this.listener.onChange(this.isOpened);
    }
}
