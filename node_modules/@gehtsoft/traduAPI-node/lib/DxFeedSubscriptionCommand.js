'use strict';
let LogManager = require('./LogManager.js');
let DxFeedSubscriptionDataReader = require('./DxFeedSubscriptionDataReader.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
class DxFeedSubscriptionCommand {
    static get SUBSCRIBE_COMMAND() { return 0; }
    static get UNSUBSCRIBE_COMMAND() { return 1; }
    clientId;
    commandType;
    socketCommunicator;
    dXFeedMessageFactory;
    socketReceiveMessageListener;
    socketStateChangeListener;
    callback;
    heartbeatScheduler;
    requestId;
    logger;
    constructor() {
        this.socketCommunicator = null;
        this.callback = null;
        this.clientId = "";
        this.requestId = 0;
        this.logger = LogManager.getLogger();
    }
    initBase(socketCommunicator, dXFeedMessageFactory, callback, clientId, commandType) {
        this.socketCommunicator = socketCommunicator;
        this.dXFeedMessageFactory = dXFeedMessageFactory;
        this.callback = callback;
        this.clientId = clientId;
        this.commandType = commandType;
        this.socketReceiveMessageListener = new DxFeedSubscriptionCommand.SocketReceiveMessageListener(this);
        this.socketReceiveMessageListener.setBaseObject(this);
        this.socketStateChangeListener = new DxFeedSubscriptionCommand.SocketStateChangeListener(this);
        this.socketStateChangeListener.setBaseObject(this);
    }
    createDxFeedSubscribeMessage() {
        return null;
    }
    createDxFeedUnsubscribeMessage() {
        return null;
    }
    execute() {
        let dXFeedMessage;
        this.socketCommunicator.subscribeJsonReceive(this.socketReceiveMessageListener);
        this.socketCommunicator.subscribeStateChange(this.socketStateChangeListener);
        if (this.commandType == DxFeedSubscriptionCommand.SUBSCRIBE_COMMAND) {
            this.logger.debug("Start command 'DxFeedSubscribeCommand'");
            dXFeedMessage = this.createDxFeedSubscribeMessage();
            this.requestId = dXFeedMessage.getId();
            this.socketCommunicator.send(dXFeedMessage.getMessage());
        } else if (this.commandType == DxFeedSubscriptionCommand.UNSUBSCRIBE_COMMAND) {
            this.logger.debug("Start command 'DxFeedUnsubscribeCommand'");
            dXFeedMessage = this.createDxFeedUnsubscribeMessage();
            this.requestId = dXFeedMessage.getId();
            this.socketCommunicator.send(dXFeedMessage.getMessage());
        }         else {
            this.callback.onError("Command type " + (this.commandType).toString() + " is not supported.");
        }
    }
    stop() {
        this.logger.debug("Stop command 'DxFeedSubscriptionCommand'");
        this.socketCommunicator.unsubscribeJsonReceive(this.socketReceiveMessageListener);
        this.socketCommunicator.unsubscribeStateChange(this.socketStateChangeListener);
    }
    processMessage(json) {
        let reader, data;
        reader = new DxFeedSubscriptionDataReader();
        data = reader.read(json);
        if (data != null) {
            if (this.requestId == data.getId()) {
                if (this.callback != null) {
                    if (data.getSuccessful()) {
                        this.callback.onSuccess();
                    }
                    else {
                        this.callback.onError(data.getError());
                    }
                }
                this.socketCommunicator.unsubscribeJsonReceive(this.socketReceiveMessageListener);
                this.socketCommunicator.unsubscribeStateChange(this.socketStateChangeListener);
            }
        }
    }
}
module.exports = DxFeedSubscriptionCommand
DxFeedSubscriptionCommand.SocketReceiveMessageListener = class {
    baseObject;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setBaseObject(baseObject) {
        this.baseObject = baseObject;
    }
    onReceive(json) {
        let ex;
        try {
            this.baseObject.processMessage(json);
        } catch(exTemp1) {
            ex = stdlib.ensureException(exTemp1);
            this._owner_.logger.error("can not process DxFeedSubscription response: " + ex.getMessage());
        }
    }
}
DxFeedSubscriptionCommand.SocketStateChangeListener = class {
    baseObject;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setBaseObject(baseObject) {
        this.baseObject = baseObject;
    }
    onChange(state) {
        let errorMessage;
        if (state.isClosed()) {
            errorMessage = "DXFeed connection is closed.";
            if (state.hasError()) {
                errorMessage = errorMessage + " " + state.getError().getMessage();
            }
            this._owner_.callback.onError(errorMessage);
        }
    }
}
