'use strict';
let ConnectionStatus = require('./ConnectionStatus.js');
let list = require('@gehtsoft/LuaxStdlib-node').list;
let LogManager = require('./LogManager.js');
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let FXConnectLiteErrorCodes = require('./FXConnectLiteErrorCodes.js');
let FXConnectLiteErrorBuilder = require('./FXConnectLiteErrorBuilder.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
class ConnectionStatusManager {
    connectionStatusChangeListeners;
    connectionStatus;
    lastStatusCode;
    logger;
    terminalName;
    notifyDelayInterval;
    constructor() {
        this.lastStatusCode = ConnectionStatus.DISCONNECTED;
        this.terminalName = "TDAS";
        this.connectionStatusChangeListeners = new list();
        this.connectionStatus = new ConnectionStatus();
        this.connectionStatus.setStatus(ConnectionStatus.DISCONNECTED);
        this.logger = LogManager.getLogger();
        this.notifyDelayInterval = 0;
    }
    setNotifyDelayInterval(notifyDelayInterval) {
        this.notifyDelayInterval = notifyDelayInterval;
    }
    setTerminalName(terminalName) {
        this.terminalName = terminalName;
    }
    getTerminalName() {
        return this.terminalName;
    }
    subscribeConnectionStatusChange(listener) {
        if (listener == null) {
            LogManager.getLogger().error("TerminalName: " + this.getTerminalName() + ": ConnectionStatusManager.subscribeConnectionStatusChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.connectionStatusChangeListeners.add(listener);
    }
    unsubscribeConnectionStatusChange(listener) {
        let i, currentListener;
        if (listener == null) {
            LogManager.getLogger().error("TerminalName: " + this.getTerminalName() + ": ConnectionStatusManager.unsubscribeConnectionStatusChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        for (i = 0; i <= this.connectionStatusChangeListeners.length() - 1; i += 1) {
            currentListener = this.connectionStatusChangeListeners.get(i);
            if (listener == currentListener) {
                this.connectionStatusChangeListeners.remove(i);
                break;
            }
        }
    }
    getConnectionStatus() {
        return this.connectionStatus;
    }
    changeConnectionStatus(status) {
        if (status != this.lastStatusCode) {
            this.logger.info("TerminalName: " + this.getTerminalName() + ": Connection status changed: " + (status).toString());
            this.connectionStatus.setStatus(status);
            this.lastStatusCode = status;
            this.notifyListeners();
        }
    }
    changeConnectionStatusWithError(status, error) {
        let errorBuilder;
        if (error == null) {
            LogManager.getLogger().error("TerminalName: " + this.getTerminalName() + ": ConnectionStatusManager.changeConnectionStatusWithError(): error string is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "error string is not set");
        }
        if (status != this.lastStatusCode) {
            this.logger.info("TerminalName: " + this.getTerminalName() + ": Connection status changed: " + (status).toString() + ". Error: " + error);
            errorBuilder = new FXConnectLiteErrorBuilder();
            errorBuilder.setMessage(error);
            this.connectionStatus.setStatusWithError(status, errorBuilder.build());
            this.lastStatusCode = status;
            this.notifyListeners();
        }
    }
    notifyListeners() {
        let i, delayedNotifyAction, sched;
        for (i = 0; i <= this.connectionStatusChangeListeners.length() - 1; i += 1) {
            delayedNotifyAction = new ConnectionStatusManager.DelayedNotifyAction(this);
            delayedNotifyAction.setStatus(this.connectionStatus);
            delayedNotifyAction.setListener(this.connectionStatusChangeListeners.get(i));
            sched = scheduler.create(this.notifyDelayInterval, delayedNotifyAction);
            delayedNotifyAction.setScheduler(sched);
            sched.startWithDelay();
        }
    }
}
module.exports = ConnectionStatusManager
ConnectionStatusManager.DelayedNotifyAction = class {
    sched;
    status;
    listener;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.sched = null;
        this.status = null;
        this.listener = null;
    }
    setScheduler(sched) {
        this.sched = sched;
    }
    setStatus(status) {
        this.status = status;
    }
    setListener(listener) {
        this.listener = listener;
    }
    invoke() {
        let ex;
        this.sched.stop();
        try {
            this.listener.onConnectionStatusChange(this.status);
        } catch(exTemp1) {
            ex = stdlib.ensureException(exTemp1);
            this._owner_.logger.error("TerminalName: " + this._owner_.getTerminalName() + ": ConnectionStatusManager notifyListeners failed: " + ex.getMessage());
        }
    }
}
