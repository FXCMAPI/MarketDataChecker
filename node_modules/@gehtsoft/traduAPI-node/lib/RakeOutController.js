'use strict';
let LogManager = require('./LogManager.js');
let MessageType = require('./MessageType.js');
let ConnectionStatus = require('./ConnectionStatus.js');
let ReconnectingMessageBuilder = require('./ReconnectingMessageBuilder.js');
class RakeOutController {
    sessionProvider;
    rakeOutCommand;
    rakeOutCommandListener;
    connectionStatusManager;
    receiveNewMessageListener;
    messageRouter;
    logger;
    startMessageType;
    isStartedFlag;
    constructor() {
        this.logger = LogManager.getLogger();
        this.isStartedFlag = false;
    }
    static create(sessionProvider, messageRouter, connectionStatusManager, rakeOutCommand, startMessageType) {
        let controller;
        controller = new RakeOutController();
        controller.initialize(sessionProvider, messageRouter, connectionStatusManager, rakeOutCommand, startMessageType);
        return controller;
    }
    start() {
        this.logger.debug("RakeOut for " + this.sessionProvider.getSession().getSessionId() + " was started");
        this.isStartedFlag = true;
        this.rakeOutCommand.setSession(this.sessionProvider.getSession());
        this.rakeOutCommand.execute();
    }
    initialize(sessionProvider, messageRouter, connectionStatusManager, rakeOutCommand, startMessageType) {
        this.sessionProvider = sessionProvider;
        this.connectionStatusManager = connectionStatusManager;
        this.messageRouter = messageRouter;
        this.rakeOutCommand = rakeOutCommand;
        this.createRakeOutCommandListener();
        this.rakeOutCommand.subscribeStatusChange(this.rakeOutCommandListener);
        this.createReceiveNewMessageListener();
        this.startMessageType = startMessageType;
        this.messageRouter.subscribeNewMessageReceive(startMessageType, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Reconnecting, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.LogicError, this.receiveNewMessageListener);
    }
    stop() {
        this.stopImpl();
    }
    stopImpl() {
        if (this.isStartedFlag) {
            this.logger.debug("RakeOut was stopped");
            this.isStartedFlag = false;
            this.rakeOutCommand.stop();
        }
    }
    shutdown() {
        this.stop();
        this.rakeOutCommand.unsubscribeStatusChange(this.rakeOutCommandListener);
        this.messageRouter.unsubscribeNewMessageReceive(this.startMessageType, this.receiveNewMessageListener);
        this.messageRouter.unsubscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
        this.messageRouter.unsubscribeNewMessageReceive(MessageType.Reconnecting, this.receiveNewMessageListener);
        this.messageRouter.unsubscribeNewMessageReceive(MessageType.LogicError, this.receiveNewMessageListener);
    }
    createRakeOutCommandListener() {
        this.rakeOutCommandListener = new RakeOutController.RakeOutCommandListener(this);
    }
    createReceiveNewMessageListener() {
        this.receiveNewMessageListener = new RakeOutController.ReceiveNewMessageListener(this);
    }
}
module.exports = RakeOutController
RakeOutController.RakeOutCommandListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccess(message) {
        return void(0);
    }
    onError(error) {
        let messages, reconnectingMessageBuilder;
        this._owner_.stop();
        this._owner_.logger.warning("RakeOut got error: " + error);
        this._owner_.connectionStatusManager.changeConnectionStatusWithError(ConnectionStatus.RECONNECTING, error);
        messages = new Array(1);
        reconnectingMessageBuilder = new ReconnectingMessageBuilder();
        messages[0] = reconnectingMessageBuilder.build();
        this._owner_.messageRouter.publishNewMessage(messages);
    }
    onCancel() {
        return void(0);
    }
}
RakeOutController.ReceiveNewMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        let logicErrorMessage;
        this._owner_.logger.debug("RakeOutController. Receive message: " + message.getType());
        if (message.getType() == this._owner_.startMessageType && !this._owner_.isStartedFlag) {
            this._owner_.logger.debug("RakeOut for " + this._owner_.sessionProvider.getSession().getSessionId() + " was executed");
            this._owner_.isStartedFlag = true;
            this._owner_.rakeOutCommand.setSession(this._owner_.sessionProvider.getSession());
            this._owner_.rakeOutCommand.execute();
        } else if (message.getType() == MessageType.Reconnecting) {
            this._owner_.stop();
        } else if (message.getType() == MessageType.Disconnected) {
            this._owner_.stop();
        } else if (message.getType() == MessageType.LogicError) {
            logicErrorMessage = message;
            this._owner_.logger.error("RakeOut was stopped due to the error: " + logicErrorMessage.getError());
            this._owner_.stop();
        }
    }
}
