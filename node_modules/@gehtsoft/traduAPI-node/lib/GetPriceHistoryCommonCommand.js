'use strict';
let FXConnectLiteErrorBuilder = require('./FXConnectLiteErrorBuilder.js');
let logger = require('@gehtsoft/LuaxStdlib-node').logger;
let PriceTerminalTypes = require('./PriceTerminalTypes.js');
class GetPriceHistoryCommonCommand {
    request;
    callback;
    commandFactory;
    sessionStorage;
    dxfeedPriceHistoryMediatorFactory;
    priceTerminalInitializer;
    getPriceHistoryCommand;
    dxFeedNamesProvider;
    constructor() {
        this.priceTerminalInitializer = null;
        this.getPriceHistoryCommand = null;
    }
    static create(request, callback, commandFactory, sessionStorage, dxfeedPriceHistoryMediatorFactory, dxFeedNamesProvider) {
        let result;
        result = new GetPriceHistoryCommonCommand();
        result.request = request;
        result.callback = callback;
        result.commandFactory = commandFactory;
        result.sessionStorage = sessionStorage;
        result.dxfeedPriceHistoryMediatorFactory = dxfeedPriceHistoryMediatorFactory;
        result.dxFeedNamesProvider = dxFeedNamesProvider;
        return result;
    }
    stop() {
        if (this.getPriceHistoryCommand != null) {
            this.getPriceHistoryCommand.stop();
        }
    }
    execute() {
        let initializerCallback, error, errorBuilder;
        this.priceTerminalInitializer = this.sessionStorage.getPriceTerminalInitializerByPriceStreamId(this.request.getInstrumentDescriptor().getPriceStreamId());
        if (this.priceTerminalInitializer == null) {
            error = "Not found price terminal for instrument '" + this.request.getInstrumentDescriptor().getSymbol() + "'";
            error = error + " price stream '" + this.request.getInstrumentDescriptor().getPriceStreamId() + "'";
            errorBuilder = new FXConnectLiteErrorBuilder();
            errorBuilder.setMessage(error);
            this.callback.onError(errorBuilder.build());
            return;
        }
        initializerCallback = new GetPriceHistoryCommonCommand.GetInitializedPriceTerminalCallback(this);
        this.priceTerminalInitializer.getInitializedPriceTerminal(initializerCallback);
    }
    getHistoryFromPdas(priceTerminalData) {
        this.getPriceHistoryCommand = this.commandFactory.createGetPriceHistoryFromPdasCommand(priceTerminalData, this.request, this.callback);
        this.getPriceHistoryCommand.execute();
    }
    getHistoryFromDxfeed(dxfeedConnection) {
        let mediator;
        mediator = this.dxfeedPriceHistoryMediatorFactory.createMediator(dxfeedConnection);
        this.getPriceHistoryCommand = this.commandFactory.createGetPriceHistoryFromDxfeedCommand(mediator, this.request, this.callback);
        this.getPriceHistoryCommand.execute();
    }
    subscribeStatusChange(callback) {
        return void(0);
    }
    unsubscribeStatusChange(callback) {
        return void(0);
    }
}
module.exports = GetPriceHistoryCommonCommand
GetPriceHistoryCommonCommand.GetInitializedPriceTerminalCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onError(error) {
        let errorBuilder, errorExt;
        errorExt = "Price terminal initialization error: " + error;
        errorBuilder = new FXConnectLiteErrorBuilder();
        errorBuilder.setMessage(errorExt);
        this._owner_.callback.onError(errorBuilder.build());
        logger.error(error);
    }
    onSuccess(result) {
        let dxfeedConnection, priceTerminalData;
        if (result != null) {
            if (this._owner_.priceTerminalInitializer.getPriceTerminalType() == PriceTerminalTypes.DXFEED) {
                dxfeedConnection = result;
                this._owner_.getHistoryFromDxfeed(dxfeedConnection);
            }
            else {
                priceTerminalData = result;
                this._owner_.getHistoryFromPdas(priceTerminalData);
            }
        }
    }
}
