'use strict';
let list = require('@gehtsoft/LuaxStdlib-node').list;
let CollectionUtils = require('./CollectionUtils.js');
let ReferencedCrossSymbolsSeparator = require('./ReferencedCrossSymbolsSeparator.js');
class ClientCrossSymbolsProvider {
    static get BASE_CCY_INDEX() { return 0; }
    static get QUOTE_CCY_INDEX() { return 1; }
    instrumentsProvider;
    calculationPathCrossSymbolsProvider;
    accountBaseSymbolsProvider;
    static create(instrumentsProvider, calculationPathCrossSymbolsProvider, accountBaseSymbolsProvider) {
        let result;
        result = new ClientCrossSymbolsProvider();
        result.instrumentsProvider = instrumentsProvider;
        result.calculationPathCrossSymbolsProvider = calculationPathCrossSymbolsProvider;
        result.accountBaseSymbolsProvider = accountBaseSymbolsProvider;
        return result;
    }
    findNotLoadedCrossSymbols(symbol) {
        let allCrossSymbolsList, allCrossSymbols, found, j, instrument;
        allCrossSymbolsList = new list();
        allCrossSymbols = this.findCrossSymbolsInner(symbol, true);
        for (j = 0; j <= allCrossSymbols.length - 1; j += 1) {
            instrument = this.instrumentsProvider.getInstrumentBySymbol(allCrossSymbols[j]);
            if (instrument == null || instrument.getSubscriptionStatus() == "D") {
                found = CollectionUtils.containsStringInList(allCrossSymbolsList, allCrossSymbols[j]);
                if (!found) {
                    CollectionUtils.addStringToList(allCrossSymbolsList, allCrossSymbols[j]);
                }
            }
        }
        return CollectionUtils.stringListToArray(allCrossSymbolsList);
    }
    separateReferencedCrossSymbols(symbols) {
        let symbolsToUnsubscribeList, symbolsToChangeStatusList, allCrossSymbols, j, i, symbol, subscribedSymbol, allSubscribedSymbols, baseSymbols, allowUnsubscribe;
        allSubscribedSymbols = this.getSubscribedSymbols(symbols);
        baseSymbols = this.accountBaseSymbolsProvider.getBaseSymbols();
        symbolsToUnsubscribeList = new list();
        symbolsToChangeStatusList = new list();
        for (i = 0; i <= symbols.length - 1; i += 1) {
            symbol = symbols[i];
            allowUnsubscribe = true;
            for (j = 0; j <= allSubscribedSymbols.length - 1; j += 1) {
                subscribedSymbol = allSubscribedSymbols[j];
                allCrossSymbols = this.findCrossSymbolsInner(subscribedSymbol, false);
                if (this.findSymbolInArray(allCrossSymbols, symbol)) {
                    allowUnsubscribe = false;
                    break;
                }
            }
            if (allowUnsubscribe) {
                allowUnsubscribe = !this.isBaseSymbol(baseSymbols, symbol);
            }
            if (allowUnsubscribe) {
                CollectionUtils.addStringToList(symbolsToUnsubscribeList, symbol);
            }
            else {
                CollectionUtils.addStringToList(symbolsToChangeStatusList, symbol);
            }
        }
        return ReferencedCrossSymbolsSeparator.create(symbolsToUnsubscribeList, symbolsToChangeStatusList);
    }
    isBaseSymbol(baseSymbols, symbol) {
        let i;
        for (i = 0; i <= baseSymbols.length - 1; i += 1) {
            if (baseSymbols[i] == symbol) {
                return true;
            }
        }
        return false;
    }
    getSubscribedSymbols(symbols) {
        let subscribed, i, symbol, allSubscribedSymbolsList, allDescriptors, descriptor;
        allDescriptors = this.instrumentsProvider.getAllInstrumentDescriptors();
        allSubscribedSymbolsList = new list();
        for (i = 0; i <= allDescriptors.length - 1; i += 1) {
            descriptor = allDescriptors[i];
            subscribed = descriptor.getSubscriptionStatus() == "T";
            if (subscribed) {
                symbol = descriptor.getSymbol();
                if (!this.findSymbolInArray(symbols, symbol)) {
                    CollectionUtils.addStringToList(allSubscribedSymbolsList, symbol);
                }
            }
        }
        return CollectionUtils.stringListToArray(allSubscribedSymbolsList);
    }
    findSymbolInArray(symbols, symbol) {
        let i;
        for (i = 0; i <= symbols.length - 1; i += 1) {
            if (symbols[i] == symbol) {
                return true;
            }
        }
        return false;
    }
    findCrossSymbolsInner(symbol, strongCrossesCheck) {
        return this.calculationPathCrossSymbolsProvider.findCrossSymbols(symbol, strongCrossesCheck);
    }
}
module.exports = ClientCrossSymbolsProvider
