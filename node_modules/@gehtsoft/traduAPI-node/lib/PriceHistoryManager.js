'use strict';
let LogManager = require('./LogManager.js');
let string_map = require('@gehtsoft/LuaxStdlib-node').string_map;
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let FXConnectLiteErrorCodes = require('./FXConnectLiteErrorCodes.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let PriceTerminalTypes = require('./PriceTerminalTypes.js');
let PriceHistoryValidator = require('./PriceHistoryValidator.js');
let FXConnectLiteErrorBuilder = require('./FXConnectLiteErrorBuilder.js');
let PriceHistoryRequest = require('./PriceHistoryRequest.js');
let MessageType = require('./MessageType.js');
let UpdateCommandType = require('./UpdateCommandType.js');
//@@DocBrief("The class for getting history prices")
class PriceHistoryManager {
    messageRouter;
    commandFactory;
    sessionProvider;
    messageFactory;
    requestNumberGenerator;
    messageExecutor;
    connectionStatusManager;
    receiveNewMessageListener;
    instrumentsProvider;
    logger;
    timeController;
    dxFeedNamesProvider;
    sessionStorage;
    hashedInstruments;
    counter;
    commandDescriptors;
    constructor() {
        this.setReceiveNewMessageListener();
        this.logger = LogManager.getLogger();
        this.instrumentsProvider = null;
        this.hashedInstruments = new string_map();
        this.counter = 0;
        this.commandDescriptors = new string_map();
    }
    static create(commandFactory, messageRouter, messageExecutor, sessionProvider, messageFactory, requestNumberGenerator, connectionStatusManager, timeController, dxFeedNamesProvider, sessionStorage) {
        let result;
        if (commandFactory == null) {
            LogManager.getLogger().error("PriceHistoryManager.create(): commandFactory is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "commandFactory is not set");
        }
        if (messageRouter == null) {
            LogManager.getLogger().error("PriceHistoryManager.create(): messageRouter is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "messageRouter is not set");
        }
        if (messageExecutor == null) {
            LogManager.getLogger().error("PriceHistoryManager.create(): messageExecutor is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "messageExecutor is not set");
        }
        if (sessionProvider == null) {
            LogManager.getLogger().error("PriceHistoryManager.create(): sessionProvider is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "sessionProvider is not set");
        }
        if (messageFactory == null) {
            LogManager.getLogger().error("PriceHistoryManager.create(): messageFactory is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "messageFactory is not set");
        }
        if (requestNumberGenerator == null) {
            LogManager.getLogger().error("PriceHistoryManager.create(): requestNumberGenerator is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "requestNumberGenerator is not set");
        }
        if (connectionStatusManager == null) {
            LogManager.getLogger().error("PriceHistoryManager.create(): connectionStatusManager is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "connectionStatusManager is not set");
        }
        if (timeController == null) {
            LogManager.getLogger().error("PriceHistoryManager.create(): timeController is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "timeController is not set");
        }
        if (dxFeedNamesProvider == null) {
            LogManager.getLogger().error("PriceHistoryManager.create(): dxFeedNamesProvider is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "dxFeedNamesProvider is not set");
        }
        if (sessionStorage == null) {
            LogManager.getLogger().error("PriceHistoryManager.create(): sessionStorage is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "sessionStorage is not set");
        }
        result = new PriceHistoryManager();
        result.commandFactory = commandFactory;
        result.messageRouter = messageRouter;
        result.messageExecutor = messageExecutor;
        result.sessionProvider = sessionProvider;
        result.messageFactory = messageFactory;
        result.requestNumberGenerator = requestNumberGenerator;
        result.connectionStatusManager = connectionStatusManager;
        result.timeController = timeController;
        result.dxFeedNamesProvider = dxFeedNamesProvider;
        result.sessionStorage = sessionStorage;
        result.subscribeOnRequiredMessages();
        return result;
    }
    setInstrumentsProvider(instrumentsProvider) {
        if (instrumentsProvider == null) {
            this.logger.error("PriceHistoryManager.setInstrumentsProvider(): instrumentsProvider is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "instrumentsProvider is not set");
        }
        this.instrumentsProvider = instrumentsProvider;
    }
    hasAskPrice(instrument) {
        let instrumentDescriptor, priceTerminalInitializer;
        this.logger.info("PriceHistoryManager.hasAskPrice('" + instrument + "')");
        if (!this.connectionStatusManager.getConnectionStatus().isConnected()) {
            this.logger.error("PriceHistoryManager.hasAskPrice('" + instrument + "'): Session not connected");
            throw exception.create(FXConnectLiteErrorCodes.CODE_SESSION_NOT_CONNECTED, "Session not connected");
        }
        if (instrument == null || stdlib.len(instrument) == 0) {
            this.logger.error("PriceHistoryManager.hasAskPrice('" + instrument + "'): Instrument is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "Instrument is not set");
        }
        instrumentDescriptor = this.instrumentsProvider.getInstrumentDescriptorBySymbol(instrument);
        if (instrumentDescriptor == null) {
            this.logger.error("PriceHistoryManager.hasAskPrice('" + instrument + "'): Instrument is not found");
            throw exception.create(FXConnectLiteErrorCodes.CODE_INSTRUMENT_IS_NOT_FOUND, "Instrument '" + instrument + "' is not found");
        }
        priceTerminalInitializer = this.sessionStorage.getPriceTerminalInitializerByPriceStreamId(instrumentDescriptor.getPriceStreamId());
        if (priceTerminalInitializer == null) {
            this.logger.error("PriceHistoryManager.hasAskPrice('" + instrument + "'): Not found terminal for price stream '" + instrumentDescriptor.getPriceStreamId() + "'");
            throw exception.create(FXConnectLiteErrorCodes.CODE_NOT_FOUND_TERMINAL_FOR_PRICE_STREAM, "Not found terminal for price stream '" + instrumentDescriptor.getPriceStreamId() + "'");
        }
        return priceTerminalInitializer.getPriceTerminalType() == PriceTerminalTypes.PDAS;
    }
    stopCommand(identity) {
        let commandDescriptor;
        if (this.commandDescriptors.contains(identity)) {
            commandDescriptor = this.commandDescriptors.get(identity);
            commandDescriptor.stop();
            this.commandDescriptors.remove(identity);
        }
    }
    getPrices(instrument, timeframe, from, to, quotesCount, callback) {
        let errorBuilder, request, error, identity, commandDescriptor;
        error = PriceHistoryValidator.validateParameters(instrument, timeframe, from, to, true, callback);
        if (error != null) {
            errorBuilder = new FXConnectLiteErrorBuilder();
            errorBuilder.setMessage(error);
            this.logger.warning("PriceHistoryManager: " + error);
            callback.onError(errorBuilder.build());
            return null;
        }
        this.logger.info("PriceHistoryManager. Get prices");
        if (!this.connectionStatusManager.getConnectionStatus().isConnected()) {
            errorBuilder = new FXConnectLiteErrorBuilder();
            errorBuilder.setMessage("Session is not connected");
            this.logger.warning("PriceHistoryManager. Get prices: Session not connected");
            callback.onError(errorBuilder.build());
            return null;
        }
        if (this.instrumentsProvider.getInstrumentDescriptorBySymbol(instrument) == null) {
            errorBuilder = new FXConnectLiteErrorBuilder();
            errorBuilder.setMessage("Instrument '" + instrument + "' is not found");
            this.logger.warning("PriceHistoryManager. Get prices: Instrument '" + instrument + "' is not found");
            callback.onError(errorBuilder.build());
            return null;
        }
        request = PriceHistoryRequest.create(instrument, timeframe, this.timeController.toServerTime(from), this.timeController.toServerTime(to), quotesCount, this.instrumentsProvider.getInstrumentDescriptorBySymbol(instrument));
        identity = this.getIdentity();
        commandDescriptor = PriceHistoryManager.CommandDescriptor.create(identity, callback);
        this.commandDescriptors.set(identity, commandDescriptor);
        this.loadInstrumentIfRequired(request, callback, commandDescriptor);
        return identity;
    }
    getIdentity() {
        this.counter = this.counter + 1;
        return "GPH-" + (this.counter).toString();
    }
    runRequest(instrument, request, callback, commandDescriptor) {
        let commandCallback, command;
        if (instrument != null) {
            request.setAskAdjustment(instrument.getAskAdjustment());
            request.setBidAdjustment(instrument.getBidAdjustment());
        }
        commandCallback = PriceHistoryManager.GetPriceHistoryCommandCallback.create(this.commandDescriptors, callback, commandDescriptor.getIdentity());
        command = this.commandFactory.createGetPriceHistoryCommonCommand(request, commandCallback);
        commandDescriptor.setGetInstrumentsCallback(null);
        commandDescriptor.setCommand(command);
        command.execute();
    }
    loadInstrumentIfRequired(request, callback, commandDescriptor) {
        let instrumentLoaderCallback, symbol;
        symbol = request.getInstrument();
        if (this.hashedInstruments.contains(symbol)) {
            this.runRequest(this.hashedInstruments.get(symbol), request, callback, commandDescriptor);
        }
        else {
            instrumentLoaderCallback = new PriceHistoryManager.GetInstrumentsCallback(this);
            instrumentLoaderCallback.setRequest(request);
            instrumentLoaderCallback.setCallback(callback);
            instrumentLoaderCallback.setCommandDescriptor(commandDescriptor);
            commandDescriptor.setGetInstrumentsCallback(instrumentLoaderCallback);
            this.instrumentsProvider.getInstrumentsSnapshot([this.instrumentsProvider.getInstrumentDescriptorBySymbol(symbol).getOfferId()], instrumentLoaderCallback);
        }
    }
    processMessage(message) {
        let i, keys;
        this.logger.debug("PriceHistoryManager. Receive message: " + message.getType());
        if (message.getType() == MessageType.Disconnected) {
            keys = this.commandDescriptors.keys();
            for (i = 0; i <= keys.length - 1; i += 1) {
                this.commandDescriptors.get(keys[i]).stop();
            }
            this.hashedInstruments.clear();
            this.commandDescriptors.clear();
        } else if (message.getType() == MessageType.InstrumentUpdateMessage) {
            this.processInstrumentUpdate(message);
        }
    }
    processInstrumentUpdate(instrumentUpdateMessage) {
        let updatedSymbol, oldInstrumentBuilder;
        updatedSymbol = instrumentUpdateMessage.getInstrument().getInstrument().getSymbol();
        if (this.hashedInstruments.contains(updatedSymbol)) {
            if (instrumentUpdateMessage.getUpdateCommand() == UpdateCommandType.UPDATE) {
                oldInstrumentBuilder = this.hashedInstruments.get(updatedSymbol);
                if (this.updateInstrument(instrumentUpdateMessage.getInstrument(), oldInstrumentBuilder)) {
                    this.hashedInstruments.set(updatedSymbol, oldInstrumentBuilder.build());
                }
            }
            else {
                this.hashedInstruments.remove(updatedSymbol);
            }
        }
    }
    updateInstrument(updInstrument, oldInstrumentBuilder) {
        let changed;
        changed = false;
        if (updInstrument.isAskAdjustmentChanged()) {
            oldInstrumentBuilder.setAskAdjustment(updInstrument.getInstrument().getAskAdjustment());
            changed = true;
        }
        if (updInstrument.isBidAdjustmentChanged()) {
            oldInstrumentBuilder.setBidAdjustment(updInstrument.getInstrument().getBidAdjustment());
            changed = true;
        }
        return changed;
    }
    subscribeOnRequiredMessages() {
        this.messageRouter.subscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.InstrumentUpdateMessage, this.receiveNewMessageListener);
    }
    setReceiveNewMessageListener() {
        this.receiveNewMessageListener = PriceHistoryManager.ReceiveNewMessageListener.create(this);
    }
    static createIdentityPrefix(identity) {
        return "(" + identity + "): ";
    }
}
module.exports = PriceHistoryManager
PriceHistoryManager.ReceiveNewMessageListener = class {
    owner;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(owner) {
        let instance;
        instance = new PriceHistoryManager.ReceiveNewMessageListener(this);
        instance.owner = owner;
        return instance;
    }
    onNewMessageReceive(message) {
        this.owner.processMessage(message);
    }
}
PriceHistoryManager.CommandDescriptor = class {
    getInstrumentsCallback;
    command;
    identity;
    callback;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.getInstrumentsCallback = null;
        this.command = null;
    }
    stop() {
        let errorBuilder;
        if (this.getInstrumentsCallback != null) {
            this.getInstrumentsCallback.stop();
        }
        if (this.command != null) {
            this.command.stop();
        }
        errorBuilder = new FXConnectLiteErrorBuilder();
        errorBuilder.setMessage("canceled");
        this.callback.onError(errorBuilder.build());
    }
    setGetInstrumentsCallback(getInstrumentsCallback) {
        this.getInstrumentsCallback = getInstrumentsCallback;
    }
    setCommand(command) {
        this.command = command;
    }
    getIdentity() {
        return this.identity;
    }
    static create(identity, callback) {
        let instance;
        instance = new PriceHistoryManager.CommandDescriptor(this);
        instance.identity = identity;
        instance.callback = callback;
        return instance;
    }
}
PriceHistoryManager.GetInstrumentsCallback = class {
    request;
    callback;
    commandDescriptor;
    stopped;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.stopped = false;
    }
    stop() {
        this.stopped = true;
    }
    setRequest(request) {
        this.request = request;
    }
    setCallback(callback) {
        this.callback = callback;
    }
    setCommandDescriptor(commandDescriptor) {
        this.commandDescriptor = commandDescriptor;
    }
    onSuccess(instruments) {
        if (!this.stopped) {
            if (instruments[0] != null) {
                this._owner_.hashedInstruments.set(instruments[0].getSymbol(), instruments[0]);
            }
            this._owner_.runRequest(instruments[0], this.request, this.callback, this.commandDescriptor);
        }
    }
    onError(error) {
        let builder;
        if (!this.stopped) {
            if (this._owner_.commandDescriptors.contains(this.commandDescriptor.getIdentity())) {
                this._owner_.commandDescriptors.remove(this.commandDescriptor.getIdentity());
            }
            builder = new FXConnectLiteErrorBuilder();
            builder.setMessage(PriceHistoryManager.createIdentityPrefix(this.commandDescriptor.getIdentity()) + error);
            this.callback.onError(builder.build());
        }
    }
}
PriceHistoryManager.GetPriceHistoryCommandCallback = class {
    callback;
    commandDescriptors;
    identity;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(commandDescriptors, callback, identity) {
        let result;
        result = new PriceHistoryManager.GetPriceHistoryCommandCallback(this);
        result.identity = identity;
        result.callback = callback;
        result.commandDescriptors = commandDescriptors;
        return result;
    }
    onSuccess(response) {
        this.removeCommandFromList();
        this.callback.onSuccess(response);
    }
    onError(error) {
        let errorBuilder;
        this.removeCommandFromList();
        errorBuilder = new FXConnectLiteErrorBuilder();
        errorBuilder.setMessage(PriceHistoryManager.createIdentityPrefix(this.identity) + error.getMessage());
        this.callback.onError(errorBuilder.build());
    }
    removeCommandFromList() {
        if (this.commandDescriptors.contains(this.identity)) {
            this.commandDescriptors.remove(this.identity);
        }
    }
}
