'use strict';
let LogManager = require('./LogManager.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let MessageBuilder = require('./MessageBuilder.js');
let DisconnectedMessageBuilder = require('./DisconnectedMessageBuilder.js');
let ConnectionStatus = require('./ConnectionStatus.js');
//@@DocBrief("The class to close the existing connection with the trading system")
class LogoutController {
    sessionProvider;
    connectionStatusManager;
    logoutCommand;
    messageRouter;
    controllersBreaker;
    commandFactory;
    messageExecutor;
    messageFactory;
    requestNumberGenerator;
    logger;
    commandStatusListener;
    timeOutScheduler;
    constructor() {
        this.logger = LogManager.getLogger();
        this.commandStatusListener = null;
    }
    static create(commandFactory, sessionProvider, messageFactory, messageExecutor, requestNumberGenerator, connectionStatusManager, controllersBreaker, messageRouter) {
        let logoutController;
        logoutController = new LogoutController();
        logoutController.commandFactory = commandFactory;
        logoutController.sessionProvider = sessionProvider;
        logoutController.connectionStatusManager = connectionStatusManager;
        logoutController.messageRouter = messageRouter;
        logoutController.messageExecutor = messageExecutor;
        logoutController.requestNumberGenerator = requestNumberGenerator;
        logoutController.messageFactory = messageFactory;
        logoutController.controllersBreaker = controllersBreaker;
        return logoutController;
    }
    logout() {
        this.logger.debug("LogoutController. Logout");
        if (this.connectionStatusManager.getConnectionStatus().isConnected()) {
            this.commandStatusListener = new LogoutController.CommandStatusListener(this);
            this.controllersBreaker.stopAll();
            this.timeOutScheduler = scheduler.create(2000, new LogoutController.TimeoutAction(this));
            this.logoutCommand = this.commandFactory.createLogoutCommand(this.sessionProvider.getSession(), this.messageExecutor, this.messageFactory, this.requestNumberGenerator);
            this.timeOutScheduler.startWithDelay();
            this.logoutCommand.subscribeStatusChange(this.commandStatusListener);
            this.logoutCommand.execute();
        } else if (this.connectionStatusManager.getConnectionStatus().isReconnecting() || this.connectionStatusManager.getConnectionStatus().isConnecting()) {
            this.controllersBreaker.stopAll();
            this.changeStatusToDisconnected();
        }
    }
    stop() {
        if (this.timeOutScheduler != null) {
            this.timeOutScheduler.stop();
            this.timeOutScheduler = null;
        }
    }
    changeStatusToDisconnected() {
        let messages;
        this.stop();
        messages = new Array(1);
        messages[0] = MessageBuilder.createLockedMessage(new DisconnectedMessageBuilder().build());
        this.messageRouter.publishNewMessage(messages);
        this.connectionStatusManager.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
    }
}
module.exports = LogoutController
LogoutController.CommandStatusListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccess(message) {
        this._owner_.changeStatusToDisconnected();
    }
    onError(error) {
        this._owner_.logger.error("LogoutController.logout.onError(): " + error);
        this._owner_.changeStatusToDisconnected();
    }
    onCancel() {
        this._owner_.logger.info("LogoutController.logout.onCancel()");
        this._owner_.changeStatusToDisconnected();
    }
}
LogoutController.TimeoutAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        this._owner_.commandStatusListener.onError("Logout timeout");
    }
}
