'use strict';
let OrdersStorage = require('./OrdersStorage.js');
let DataManagerState = require('./DataManagerState.js');
let DataManagerStatePublisher = require('./DataManagerStatePublisher.js');
let CommonPublisher = require('./CommonPublisher.js');
let OrderRequestBuilderFactory = require('./OrderRequestBuilderFactory.js');
let LogManager = require('./LogManager.js');
let OrdersManagerEvents = require('./OrdersManagerEvents.js');
let OrdersValidator = require('./OrdersValidator.js');
let DxFeedOffersEnsurer = require('./DxFeedOffersEnsurer.js');
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let FXConnectLiteErrorCodes = require('./FXConnectLiteErrorCodes.js');
let ExecutionTimeEvenUtil = require('./ExecutionTimeEvenUtil.js');
let ExecutionTimeEventName = require('./ExecutionTimeEventName.js');
let ExecutionTimeEventBuilder = require('./ExecutionTimeEventBuilder.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let string_map = require('@gehtsoft/LuaxStdlib-node').string_map;
let ClosePositionDescriptor = require('./ClosePositionDescriptor.js');
let OrdersUtil = require('./OrdersUtil.js');
let FXConnectLiteErrorBuilder = require('./FXConnectLiteErrorBuilder.js');
let MessageType = require('./MessageType.js');
let GetInstrumentsCallbackWithOffersLoading = require('./GetInstrumentsCallbackWithOffersLoading.js');
let list = require('@gehtsoft/LuaxStdlib-node').list;
let CollectionUtils = require('./CollectionUtils.js');
let OrdersMapper = require('./OrdersMapper.js');
let OrderBuilder = require('./OrderBuilder.js');
let OrdersUpdater = require('./OrdersUpdater.js');
let UpdateCommandType = require('./UpdateCommandType.js');
let OrderInfoBuilder = require('./OrderInfoBuilder.js');
let EventManager = require('./EventManager.js');
//@@DocBrief("The class for managing orders")
class OrdersManager {
    storage;
    orderChangePublisher;
    state;
    stateChangePublisher;
    messageRouter;
    commandFactory;
    sessionProvider;
    messageFactory;
    requestNumberGenerator;
    messageExecutor;
    receiveNewMessageListener;
    connectionStatusManager;
    requestFactory;
    openPositionsProvider;
    logger;
    offersProvider;
    instrumentsProvider;
    requestsNumber;
    accountsManager;
    ordersCalculator;
    timeController;
    ordersValidator;
    instrumentsSubscriptionProvider;
    internalOffersLoader;
    instrumentDescriptorsSeparator;
    getInstrumentsCallback;
    completeRefreshAction;
    dxFeedOffersEnsurer;
    ordersManagerEvents;
    eventRefresh;
    lastGeneratedErrorText;
    constructor() {
        this.requestsNumber = 0;
        this.accountsManager = null;
        this.storage = new OrdersStorage();
        this.state = new DataManagerState();
        this.stateChangePublisher = new DataManagerStatePublisher();
        this.orderChangePublisher = new CommonPublisher();
        this.requestFactory = new OrderRequestBuilderFactory();
        this.completeRefreshAction = new OrdersManager.CompleteRefreshAction(this);
        this.setReceiveNewMessageListener();
        this.logger = LogManager.getLogger();
        this.ordersManagerEvents = new OrdersManagerEvents();
        this.lastGeneratedErrorText = "";
    }
    static create(commandFactory, messageRouter, messageExecutor, sessionProvider, messageFactory, requestNumberGenerator, connectionStatusManager, openPositionsProvider, offersProvider, accountsManager, instrumentsProvider, ordersCalculator, timeController, instrumentsSubscriptionProvider, internalOffersLoader, instrumentDescriptorsSeparator) {
        let result;
        result = new OrdersManager();
        result.commandFactory = commandFactory;
        result.messageRouter = messageRouter;
        result.messageExecutor = messageExecutor;
        result.sessionProvider = sessionProvider;
        result.messageFactory = messageFactory;
        result.requestNumberGenerator = requestNumberGenerator;
        result.connectionStatusManager = connectionStatusManager;
        result.openPositionsProvider = openPositionsProvider;
        result.offersProvider = offersProvider;
        result.instrumentsProvider = instrumentsProvider;
        result.accountsManager = accountsManager;
        result.ordersCalculator = ordersCalculator;
        result.timeController = timeController;
        result.instrumentsSubscriptionProvider = instrumentsSubscriptionProvider;
        result.internalOffersLoader = internalOffersLoader;
        result.instrumentDescriptorsSeparator = instrumentDescriptorsSeparator;
        result.subscribeOnRequiredMessages();
        result.ordersValidator = OrdersValidator.create(result.storage, openPositionsProvider);
        result.dxFeedOffersEnsurer = DxFeedOffersEnsurer.create(instrumentsProvider, instrumentDescriptorsSeparator, internalOffersLoader);
        return result;
    }
    subscribeOrderChange(listener) {
        if (listener == null) {
            this.logger.error("OrdersManager.subscribeOrderChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.orderChangePublisher.subscribe(listener);
    }
    unsubscribeOrderChange(listener) {
        if (listener == null) {
            this.logger.error("OrdersManager.unsubscribeOrderChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.orderChangePublisher.unsubscribe(listener);
    }
    subscribeStateChange(listener) {
        if (listener == null) {
            this.logger.error("OrdersManager.subscribeStateChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.stateChangePublisher.subscribe(listener);
    }
    unsubscribeStateChange(listener) {
        if (listener == null) {
            this.logger.error("OrdersManager.unsubscribeStateChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.stateChangePublisher.unsubscribe(listener);
    }
    refresh() {
        let getOrdersByAcctCommand, acctId, accounts, i;
        this.logger.info("OrdersManager. Load all orders from server");
        if (this.getState().isLoading()) {
            this.logger.warning("OrdersManager. Manager not loaded yet");
            return;
        }
        if (!this.connectionStatusManager.getConnectionStatus().isConnected()) {
            this.logger.warning("OrdersManager. Session not connected");
            return;
        }
        this.eventRefresh = ExecutionTimeEvenUtil.eventStart(ExecutionTimeEventName.OrdersManagerRefreshTime);
        this.storage.clear();
        this.notifyStateChange(DataManagerState.LOADING);
        accounts = this.accountsManager.getAccountsInfo();
        this.requestsNumber = 0;
        for (i = 0; i <= accounts.length - 1; i += 1) {
            acctId = accounts[i].getId();
            this.requestsNumber = this.requestsNumber + 1;
            getOrdersByAcctCommand = this.commandFactory.createGetOrdersCommand(acctId, this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator);
            getOrdersByAcctCommand.subscribeStatusChange(new OrdersManager.GetOrdersStatusListener(this));
            getOrdersByAcctCommand.execute();
        }
        if (this.requestsNumber == 0 && this.getState().isLoading()) {
            ExecutionTimeEvenUtil.eventStop(this.eventRefresh);
            this.notifyStateChange(DataManagerState.LOADED);
        }
    }
    getState() {
        return this.state;
    }
    getOrderById(orderId) {
        this.logger.info("OrdersManager. Get order by id: " + orderId);
        return this.buildPublicOrderAndStoreCalculatedFields(this.storage.getOrderById(orderId));
    }
    getRequestFactory() {
        return this.requestFactory;
    }
    createOpenMarketOrder(marketOrderRequest) {
        let command, clientRate, pointSize, error, event;
        this.ordersValidator.checkMarketOrderRequestRequiredFields(marketOrderRequest);
        error = this.ordersValidator.checkRateFields(marketOrderRequest.getStopRate(), marketOrderRequest.getStopPips());
        if (error == "") {
            error = this.ordersValidator.checkRateFields(marketOrderRequest.getLimitRate(), marketOrderRequest.getLimitPips());
        }
        if (error == "") {
            this.logger.info("OrdersManager. Create open market order");
            clientRate = this.getMarketRate(marketOrderRequest.getBuySell(), false, marketOrderRequest.getOfferId());
            pointSize = this.getPointSize(marketOrderRequest.getOfferId());
            event = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.CreateOpenMarketOrderTime);
            event.start();
            this.ordersManagerEvents.addByOfferAndCustomId(marketOrderRequest.getOfferId(), marketOrderRequest.getCustomId(), event);
            command = this.commandFactory.createSendTrueMarketOrderCommand(marketOrderRequest, clientRate, pointSize, this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator, this.timeController);
            command.execute();
        }
        else {
            this.logger.warning("OrdersManager. Create open market order with error");
            this.generateError(error, marketOrderRequest.getCustomId(), null, null, marketOrderRequest.getOfferId());
        }
    }
    createCloseMarketOrder(closeMarketOrderRequest) {
        let openPosition, clientRate, pointSize, command, buySell, event;
        this.logger.info("OrdersManager. Create close market order");
        this.ordersValidator.checkCloseMarketOrderRequestRequiredFields(closeMarketOrderRequest);
        openPosition = this.getOpenPosition(closeMarketOrderRequest.getTradeId());
        if (openPosition == null) {
            this.generateErrorTradeNotFound(closeMarketOrderRequest.getTradeId());
            return;
        }
        buySell = openPosition.getBuySell();
        clientRate = this.getMarketRate(buySell, true, openPosition.getOfferId());
        pointSize = this.getPointSize(openPosition.getOfferId());
        event = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.CreateCloseMarketOrderTime);
        event.start();
        this.ordersManagerEvents.addByTradeId(closeMarketOrderRequest.getTradeId(), event);
        command = this.commandFactory.createSendCloseMarketOrderCommand(closeMarketOrderRequest, openPosition, clientRate, pointSize, this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator, this.timeController);
        command.execute();
    }
    closeAllPositions(closeAllPositionsRequest) {
        let closePositionDescriptors;
        closePositionDescriptors = this.prepareClosePositionDescriptorsForCommand(closeAllPositionsRequest);
        if (closePositionDescriptors.length > 0) {
            this.runSendCloseAllPositionsCommand(closeAllPositionsRequest, closePositionDescriptors);
        }
    }
    getLastGeneratedErrorText() {
        return this.lastGeneratedErrorText;
    }
    runSendCloseAllPositionsCommand(closeAllPositionsRequest, closePositionDescriptors) {
        let command;
        command = this.commandFactory.createSendCloseAllPositionsCommand(closeAllPositionsRequest, closePositionDescriptors, this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator, this.timeController);
        command.execute();
    }
    prepareClosePositionDescriptorsForCommand(closeAllPositionsRequest) {
        let closePositionDescriptors, openPositions, offerId, side, offer, instrumentDescriptor;
        this.logger.info("OrdersManager. Create close all positions");
        this.checkInstrumentsLoaded();
        offerId = "*";
        side = "*";
        if (closeAllPositionsRequest.isSymbolFilled()) {
            instrumentDescriptor = this.instrumentsProvider.getInstrumentDescriptorBySymbol(closeAllPositionsRequest.getSymbol());
            if (instrumentDescriptor == null) {
                this.generateError("Instrument '" + closeAllPositionsRequest.getSymbol() + "' not found", closeAllPositionsRequest.getCustomId(), null, null, null);
                return [];
            }
            offerId = instrumentDescriptor.getOfferId();
            offer = this.offersProvider.getInternalOfferById(offerId);
            if (offer == null) {
                this.generateError("Offer for instrument '" + closeAllPositionsRequest.getSymbol() + "' not found", closeAllPositionsRequest.getCustomId(), null, null, null);
                return [];
            }
        }
        if (closeAllPositionsRequest.isSideFilled()) {
            side = closeAllPositionsRequest.getSide();
            if (side != "B" && side != "S") {
                this.generateError("Incorrect side '" + side + "'", closeAllPositionsRequest.getCustomId(), null, null, null);
                return [];
            }
        }
        openPositions = this.openPositionsProvider.getInternalOpenPositionsSnapshot();
        closePositionDescriptors = this.createClosePositionDescriptors(openPositions, offerId, closeAllPositionsRequest.getAcctId(), side);
        if (closePositionDescriptors == null) {
            this.generateError(this.createPositionsNotFoundMessage(closeAllPositionsRequest), closeAllPositionsRequest.getCustomId(), null, null, null);
            return [];
        }
        return closePositionDescriptors;
    }
    createPositionsNotFoundMessage(closeAllPositionsRequest) {
        let error;
        error = "Open positions not found";
        if (closeAllPositionsRequest.isSymbolFilled()) {
            error = error + ", instrument: '" + closeAllPositionsRequest.getSymbol() + "'";
        }
        if (closeAllPositionsRequest.isSideFilled()) {
            error = error + ", side: '" + closeAllPositionsRequest.getSide() + "'";
        }
        return error;
    }
    checkInstrumentsLoaded() {
        let errorMessage;
        if (!this.getState().isLoaded()) {
            errorMessage = "OrdersManager.closeAllPositions: orders manager is not loaded yet";
            this.logger.error(errorMessage);
            throw exception.create(0, errorMessage);
        }
        if (!this.openPositionsProvider.getManagerState().isLoaded()) {
            errorMessage = "OrdersManager.closeAllPositions: open positions manager is not loaded yet";
            this.logger.error(errorMessage);
            throw exception.create(0, errorMessage);
        }
    }
    createClosePositionParties(openPositions, offerId, acctId) {
        let openPosition, i, result;
        result = null;
        for (i = 0; i <= openPositions.length - 1; i += 1) {
            openPosition = openPositions[i];
            if (openPosition.getOfferId() == offerId && openPosition.getAccountId() == acctId) {
                if (openPosition.getParties() != null && stdlib.len(openPosition.getParties()) > 0) {
                    result = openPosition.getParties();
                    break;
                }
            }
        }
        return result;
    }
    createClosePositionDescriptors(openPositions, offerId, acctId, side) {
        let sellDescriptorMap, buyDescriptorMap, openPosition, i, openPositionOfferId;
        sellDescriptorMap = new string_map();
        buyDescriptorMap = new string_map();
        for (i = 0; i <= openPositions.length - 1; i += 1) {
            openPosition = openPositions[i];
            openPositionOfferId = openPosition.getOfferId();
            if ((openPositionOfferId == offerId || offerId == "*") && openPosition.getAccountId() == acctId) {
                this.processPosition(openPosition, openPositions, acctId, side, sellDescriptorMap, buyDescriptorMap);
                if (sellDescriptorMap.contains(openPositionOfferId) && buyDescriptorMap.contains(openPositionOfferId) && offerId != "*") {
                    break;
                }
            }
        }
        return this.combineDescriptors(sellDescriptorMap, buyDescriptorMap);
    }
    processPosition(openPosition, openPositions, acctId, side, sellDescriptorMap, buyDescriptorMap) {
        let rate, parties, pointSize, openPositionOfferId;
        openPositionOfferId = openPosition.getOfferId();
        rate = this.getMarketRate(openPosition.getBuySell(), true, openPositionOfferId);
        parties = this.createClosePositionParties(openPositions, openPositionOfferId, acctId);
        pointSize = this.getPointSize(openPositionOfferId);
        if (this.checkSellDescriptorMap(sellDescriptorMap, openPositionOfferId, openPosition, side)) {
            sellDescriptorMap.set(openPositionOfferId, ClosePositionDescriptor.create("S", rate, parties, pointSize, openPositionOfferId));
        }
        if (this.checkBuyDescriptorMap(buyDescriptorMap, openPositionOfferId, openPosition, side)) {
            buyDescriptorMap.set(openPositionOfferId, ClosePositionDescriptor.create("B", rate, parties, pointSize, openPositionOfferId));
        }
    }
    checkSellDescriptorMap(sellDescriptorMap, openPositionOfferId, openPosition, side) {
        return !sellDescriptorMap.contains(openPositionOfferId) && openPosition.getBuySell() == "B" && (side == "B" || side == "*");
    }
    checkBuyDescriptorMap(buyDescriptorMap, openPositionOfferId, openPosition, side) {
        return !buyDescriptorMap.contains(openPositionOfferId) && openPosition.getBuySell() == "S" && (side == "S" || side == "*");
    }
    combineDescriptors(sellDescriptorMap, buyDescriptorMap) {
        let i, j, result, keys;
        if (sellDescriptorMap.length() == 0 && buyDescriptorMap.length() == 0) {
            return null;
        }
        result = new Array(sellDescriptorMap.length() + buyDescriptorMap.length());
        j = 0;
        keys = sellDescriptorMap.keys();
        for (i = 0; i <= keys.length - 1; i += 1) {
            result[j] = sellDescriptorMap.get(keys[i]);
            j = j + 1;
        }
        keys = buyDescriptorMap.keys();
        for (i = 0; i <= keys.length - 1; i += 1) {
            result[j] = buyDescriptorMap.get(keys[i]);
            j = j + 1;
        }
        return result;
    }
    createStopOrder(stopOrderRequest) {
        let command, error, event;
        this.ordersValidator.checkStopOrderRequestRequiredFields(stopOrderRequest);
        error = this.ordersValidator.checkStopLimitFields(stopOrderRequest);
        if (error == "") {
            event = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.CreateStopOrderTime);
            event.start();
            if (stopOrderRequest.getTradeId() != "") {
                this.logger.info("OrdersManager. Create stop order for a trade");
                this.ordersManagerEvents.addByTradeId(stopOrderRequest.getTradeId(), event);
                command = this.commandFactory.createStopOrderForTradeCommand(stopOrderRequest, this.getOpenPosition(stopOrderRequest.getTradeId()), this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator);
            }
            else {
                this.logger.info("OrdersManager. Create stop order for a order");
                this.ordersManagerEvents.addByOrderId(stopOrderRequest.getOrderId(), event);
                command = this.commandFactory.createStopOrderForOrderCommand(stopOrderRequest, this.storage.getOrderById(stopOrderRequest.getOrderId()), this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator);
            }
            command.execute();
        }
        else {
            this.logger.warning("OrdersManager. Create stop order with error");
            this.generateError(error, null, null, null, null);
        }
    }
    createLimitOrder(limitOrderRequest) {
        let command, error, event;
        this.ordersValidator.checkLimitOrderRequestRequiredFields(limitOrderRequest);
        error = this.ordersValidator.checkStopLimitFields(limitOrderRequest);
        if (error == "") {
            event = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.CreateLimitOrderTime);
            event.start();
            if (limitOrderRequest.getTradeId() != "") {
                this.logger.info("OrdersManager. Create stop order for a trade");
                this.ordersManagerEvents.addByTradeId(limitOrderRequest.getTradeId(), event);
                command = this.commandFactory.createLimitOrderForTradeCommand(limitOrderRequest, this.getOpenPosition(limitOrderRequest.getTradeId()), this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator);
            }
            else {
                this.logger.info("OrdersManager. Create stop order for a order");
                this.ordersManagerEvents.addByOrderId(limitOrderRequest.getOrderId(), event);
                command = this.commandFactory.createLimitOrderForOrderCommand(limitOrderRequest, this.storage.getOrderById(limitOrderRequest.getOrderId()), this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator);
            }
            command.execute();
        }
        else {
            this.logger.warning("OrdersManager. Create stop order with error");
            this.generateError(error, null, null, null, null);
        }
    }
    createOcoOrder(entryOrderRequests) {
        let offer, type, offersBidAskCalculated, command, sides, clientRates, pointSizes, i, event;
        if (entryOrderRequests == null) {
            this.logger.error("createOcoOrder(): entryOrderRequests is nil");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "entryOrderRequests is nil");
        }
        for (i = 0; i <= entryOrderRequests.length - 1; i += 1) {
            this.ordersValidator.checkEntryOrderRequestRequiredFields(entryOrderRequests[i]);
        }
        sides = new Array(entryOrderRequests.length);
        clientRates = new Array(entryOrderRequests.length);
        pointSizes = new Array(entryOrderRequests.length);
        for (i = 0; i <= entryOrderRequests.length - 1; i += 1) {
            offer = this.offersProvider.getInternalOfferById(entryOrderRequests[i].getOfferId());
            offersBidAskCalculated = this.offersProvider.calculateBidAsk(offer);
            type = OrdersUtil.getEntryOrderType(entryOrderRequests[i], offersBidAskCalculated.getBid(), offersBidAskCalculated.getAsk());
            if (type == "SE") {
                sides[i] = OrdersUtil.getStopEntryOrderSide(entryOrderRequests[i].getBuySell());
            }
            else {
                sides[i] = OrdersUtil.getLimitEntryOrderSide(entryOrderRequests[i].getBuySell());
            }
            clientRates[i] = this.getClientRate(entryOrderRequests[i].getBuySell(), false, entryOrderRequests[i].getOfferId(), entryOrderRequests[i].getRateRange());
            pointSizes[i] = this.getPointSize(entryOrderRequests[i].getOfferId());
            event = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.CreateEntryOrderTime);
            event.start();
            this.ordersManagerEvents.addByOfferAndCustomId(entryOrderRequests[i].getOfferId(), entryOrderRequests[i].getCustomId(), event);
        }
        command = this.commandFactory.createSendOcoOrderCommand(entryOrderRequests, sides, clientRates, pointSizes, this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator, this.timeController);
        command.execute();
    }
    createEntryOrder(entryOrderRequest) {
        let offer, type, offersBidAskCalculated, error;
        this.ordersValidator.checkEntryOrderRequestRequiredFields(entryOrderRequest);
        error = this.ordersValidator.checkRateFields(entryOrderRequest.getStopRate(), entryOrderRequest.getStopPips());
        if (error == "") {
            error = this.ordersValidator.checkRateFields(entryOrderRequest.getLimitRate(), entryOrderRequest.getLimitPips());
        }
        if (error == "") {
            offer = this.offersProvider.getInternalOfferById(entryOrderRequest.getOfferId());
            offersBidAskCalculated = this.offersProvider.calculateBidAsk(offer);
            type = OrdersUtil.getEntryOrderType(entryOrderRequest, offersBidAskCalculated.getBid(), offersBidAskCalculated.getAsk());
            if (type == "SE") {
                this.createStopEntryOrder(entryOrderRequest);
            }
            else {
                this.createLimitEntryOrder(entryOrderRequest);
            }
        }
        else {
            this.logger.warning("OrdersManager. Create entry order with error");
            this.generateError(error, null, null, null, null);
        }
    }
    createStopEntryOrder(entryOrderRequest) {
        let command, side, clientRate, pointSize, event;
        this.ordersValidator.checkEntryOrderRequestRequiredFields(entryOrderRequest);
        this.logger.info("OrdersManager. Create stop entry order");
        side = OrdersUtil.getStopEntryOrderSide(entryOrderRequest.getBuySell());
        clientRate = this.getClientRate(entryOrderRequest.getBuySell(), false, entryOrderRequest.getOfferId(), entryOrderRequest.getRateRange());
        pointSize = this.getPointSize(entryOrderRequest.getOfferId());
        event = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.CreateEntryOrderTime);
        event.start();
        this.ordersManagerEvents.addByOfferAndCustomId(entryOrderRequest.getOfferId(), entryOrderRequest.getCustomId(), event);
        command = this.commandFactory.createSendEntryOrderCommand(entryOrderRequest, side, clientRate, pointSize, this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator, this.timeController);
        command.execute();
    }
    createLimitEntryOrder(entryOrderRequest) {
        let command, side, clientRate, pointSize, event;
        this.ordersValidator.checkEntryOrderRequestRequiredFields(entryOrderRequest);
        this.logger.info("OrdersManager. Create limit entry order");
        side = OrdersUtil.getLimitEntryOrderSide(entryOrderRequest.getBuySell());
        clientRate = this.getClientRate(entryOrderRequest.getBuySell(), false, entryOrderRequest.getOfferId(), entryOrderRequest.getRateRange());
        pointSize = this.getPointSize(entryOrderRequest.getOfferId());
        event = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.CreateEntryOrderTime);
        event.start();
        this.ordersManagerEvents.addByOfferAndCustomId(entryOrderRequest.getOfferId(), entryOrderRequest.getCustomId(), event);
        command = this.commandFactory.createSendEntryOrderCommand(entryOrderRequest, side, clientRate, pointSize, this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator, this.timeController);
        command.execute();
    }
    removeOrder(orderId) {
        let command, order, event;
        if (orderId == null || stdlib.len(orderId) == 0) {
            this.logger.error("OrdersManager.removeOrder(): OrderId for removeOrder is empty or nil");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "OrderId for removeOrder is empty or nil");
        }
        this.logger.info("OrdersManager. Remove order");
        order = this.storage.getOrderById(orderId);
        if (order == null) {
            this.generateErrorOrderNotFound(orderId);
            return;
        }
        event = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.RemoveOrderTime);
        event.start();
        this.ordersManagerEvents.addByOrderId(orderId, event);
        command = this.commandFactory.createRemoveOrderCommand(order.getAccountId(), orderId, this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator);
        command.execute();
    }
    changeOrder(changeOrderRequest) {
        let command, order, pointSize, error, orderType, event;
        this.ordersValidator.checkChangeOrderRequestRequiredFields(changeOrderRequest);
        this.logger.info("OrdersManager. Change order");
        order = this.storage.getOrderById(changeOrderRequest.getOrderId());
        if (order == null) {
            this.generateErrorOrderNotFound(changeOrderRequest.getOrderId());
            return;
        }
        error = this.ordersValidator.checkRateFields(changeOrderRequest.getRate(), changeOrderRequest.getPips());
        if (error == "") {
            orderType = order.getType();
            pointSize = this.getPointSize(order.getOfferId());
            event = ExecutionTimeEventBuilder.create(ExecutionTimeEventName.ChangeOrderTime);
            event.start();
            this.ordersManagerEvents.addByOrderId(changeOrderRequest.getOrderId(), event);
            command = this.commandFactory.createChangeOrderCommand(order.getAccountId(), changeOrderRequest, pointSize, orderType, this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator);
            command.execute();
        }
        else {
            this.logger.warning("OrdersManager.Change order order with error");
            this.generateError(error, null, null, null, null);
        }
    }
    getRawOrdersForTrade(tradeId) {
        return this.storage.getOrdersForTrade(tradeId);
    }
    getRawOrdersForPrimaryOrderId(primaryOrderId) {
        return this.storage.getOrdersForPrimaryOrderId(primaryOrderId);
    }
    getOrdersSnapshot() {
        let orders, result, i;
        this.logger.info("OrdersManager. Get orders snapshot");
        orders = this.storage.getAllOrders();
        result = new Array(orders.length);
        for (i = 0; i <= orders.length - 1; i += 1) {
            result[i] = this.buildPublicOrderAndStoreCalculatedFields(orders[i]);
        }
        return result;
    }
    getPointSize(offerId) {
        let instrument;
        instrument = this.instrumentsProvider.getInstrumentByOfferId(offerId);
        if (instrument != null) {
            return instrument.getPointSize();
        }
        return 0.0;
    }
    getClientRate(buySell, opposite, offerId, requestRange) {
        let clientRate;
        clientRate = 0.0;
        if (requestRange != 0) {
            clientRate = this.getMarketRate(buySell, opposite, offerId);
        }
        return clientRate;
    }
    getMarketRate(buySell, opposite, offerId) {
        let marketRate, offer, offersBidAskCalculated;
        marketRate = 0.0;
        offer = this.offersProvider.getInternalOfferById(offerId);
        if (offer != null) {
            offersBidAskCalculated = this.offersProvider.calculateBidAsk(offer);
            marketRate = OrdersUtil.getClientRate(buySell, opposite, offersBidAskCalculated.getBid(), offersBidAskCalculated.getAsk());
        }
        return marketRate;
    }
    generateErrorTradeNotFound(tradeId) {
        this.generateError(this.ordersValidator.generateErrorMessageTradeNotFound(tradeId), null, tradeId, null, null);
    }
    generateErrorOrderNotFound(orderId) {
        this.generateError(this.ordersValidator.generateErrorMessageOrderNotFound(orderId), null, null, orderId, null);
    }
    generateError(message, requestTxt, tradeId, orderId, offerId) {
        let errorBuilder;
        errorBuilder = new FXConnectLiteErrorBuilder();
        errorBuilder.setMessage(message);
        this.lastGeneratedErrorText = message;
        this.notifyOrderError(this.createOrderInfo(orderId, tradeId, "R", requestTxt, errorBuilder.build()), offerId);
    }
    getOpenPosition(tradeId) {
        return this.openPositionsProvider.getInternalOpenPosition(tradeId);
    }
    setReceiveNewMessageListener() {
        this.receiveNewMessageListener = OrdersManager.ReceiveNewMessageListener.create(this);
    }
    subscribeOnRequiredMessages() {
        this.messageRouter.subscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.OrderUpdateMessage, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.CreateOrder, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.GetOrders, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.ChangeOrder, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.RemoveOrder, this.receiveNewMessageListener);
    }
    processMessage(message) {
        this.logger.debug("OrdersManager. Receive message: " + message.getType());
        if (message.getType() == MessageType.GetOrders) {
            this.processGetOrders(message);
        } else if (message.getType() == MessageType.CreateOrder) {
            this.processCreateOrder(message);
        } else if (message.getType() == MessageType.ChangeOrder) {
            this.processChangeOrder(message);
        } else if (message.getType() == MessageType.RemoveOrder) {
            this.processRemoveOrder(message);
        } else if (message.getType() == MessageType.OrderUpdateMessage) {
            this.processOrderUpdateMessage(message);
        } else if (message.getType() == MessageType.Disconnected) {
            this.storage.clear();
            this.notifyStateChange(DataManagerState.NOT_LOADED);
        }
    }
    processOrderUpdateMessage(message) {
        let updateOrderMessage;
        updateOrderMessage = message;
        this.updateOrder(updateOrderMessage.getUpdateCommand(), updateOrderMessage.getOrder());
    }
    processCreateOrder(message) {
        let createOrderMessage;
        createOrderMessage = message;
        if (createOrderMessage.getError() != null) {
            this.generateError(createOrderMessage.getError(), createOrderMessage.getRequestTxt(), null, null, createOrderMessage.getOfferId());
        }
    }
    processGetOrders(message) {
        let getOrdersMessage, orders, i;
        getOrdersMessage = message;
        orders = getOrdersMessage.getOrders();
        this.requestsNumber = this.requestsNumber - 1;
        for (i = 0; i <= orders.length - 1; i += 1) {
            this.storage.addOrder(orders[i].getOrder());
        }
        if (!this.getState().isLoaded()) {
            if (this.requestsNumber == 0) {
                this.loadInstrumentsIfRequired();
            }
        }
    }
    loadInstrumentsIfRequired() {
        let offerIds;
        offerIds = this.getOfferIds();
        if (offerIds.length > 0) {
            this.getInstrumentsCallback = GetInstrumentsCallbackWithOffersLoading.create("OrdersManager", offerIds, this.instrumentsProvider, this.instrumentDescriptorsSeparator, this.internalOffersLoader, this.logger, this.completeRefreshAction);
            this.instrumentsProvider.getOrLoadInstrumentsByOfferIds(offerIds, this.getInstrumentsCallback);
        }
        else {
            this.completeRefresh();
        }
    }
    completeRefresh() {
        ExecutionTimeEvenUtil.eventStop(this.eventRefresh);
        this.notifyStateChange(DataManagerState.LOADED);
    }
    getOfferIds() {
        let orders, offerIds, i;
        orders = this.storage.getAllOrders();
        offerIds = new list();
        for (i = 0; i <= orders.length - 1; i += 1) {
            CollectionUtils.addStringToList(offerIds, orders[i].getOfferId());
        }
        return CollectionUtils.stringListToArray(offerIds);
    }
    processChangeOrder(message) {
        let changeOrderMessage, requestTxt, order;
        changeOrderMessage = message;
        if (changeOrderMessage.getError() != null) {
            requestTxt = changeOrderMessage.getRequestTxt();
            if (requestTxt == null || stdlib.len(requestTxt) == 0) {
                order = this.storage.getOrderById(changeOrderMessage.getOrderId());
                if (order != null) {
                    requestTxt = order.getRequestTxt();
                }
            }
            this.generateError(changeOrderMessage.getError(), requestTxt, null, changeOrderMessage.getOrderId(), null);
        }
    }
    processRemoveOrder(message) {
        let removeOrderMessage, requestTxt, order;
        removeOrderMessage = message;
        if (removeOrderMessage.getError() != null) {
            requestTxt = removeOrderMessage.getRequestTxt();
            if (requestTxt == null || stdlib.len(requestTxt) == 0) {
                order = this.storage.getOrderById(removeOrderMessage.getOrderId());
                if (order != null) {
                    requestTxt = order.getRequestTxt();
                }
            }
            this.generateError(removeOrderMessage.getError(), requestTxt, null, removeOrderMessage.getOrderId(), null);
        }
    }
    buildPublicOrderAndStoreCalculatedFields(source) {
        let calculatedFields, result, sourceBuilder, orderTrailingStopData;
        if (source == null) {
            return null;
        }
        result = OrdersMapper.mapInternalToPublic(source);
        calculatedFields = this.ordersCalculator.calculatePublicFields(result);
        OrdersMapper.mergeCalculatedFields(result, calculatedFields);
        orderTrailingStopData = calculatedFields.getOrderTrailingStopData();
        if (orderTrailingStopData != null && (orderTrailingStopData.getTrailRate() != source.getTrailRate() || orderTrailingStopData.getRate() != source.getRate())) {
            sourceBuilder = source;
            sourceBuilder.setTrailRate(orderTrailingStopData.getTrailRate());
            sourceBuilder.setRate(orderTrailingStopData.getRate());
            if (source.getRateMin() != 0.0 && source.getRateMax() != 0.0) {
                sourceBuilder.setRateMin(orderTrailingStopData.getRate());
                sourceBuilder.setRateMax(orderTrailingStopData.getRateRange());
            }
        }
        return result.build();
    }
    updateOrder(updateType, updOrder) {
        let oldOrder, oldOrderBuilder;
        if (updateType == UpdateCommandType.UPDATE) {
            oldOrder = this.storage.getOrderById(updOrder.getOrder().getOrderId());
            if (oldOrder == null) {
                oldOrderBuilder = new OrderBuilder();
            }
            else {
                oldOrderBuilder = oldOrder;
            }
            OrdersUpdater.update(updOrder, oldOrderBuilder);
            if (oldOrder == null) {
                oldOrderBuilder.setOrderId(updOrder.getOrder().getOrderId());
                this.storage.addOrder(oldOrderBuilder.build());
            }
            this.notifyOrderChange(this.createOrderInfo(oldOrderBuilder.getOrderId(), oldOrderBuilder.getTradeId(), oldOrderBuilder.getStatus(), oldOrderBuilder.getRequestTxt(), null));
        } else if (updateType == UpdateCommandType.INSERT) {
            this.processInsertCommand(updOrder.getOrder());
        } else if (updateType == UpdateCommandType.DELETE) {
            this.storage.removeOrder(updOrder.getOrder().getOrderId());
            this.notifyOrderDelete(this.createOrderInfo(updOrder.getOrder().getOrderId(), updOrder.getOrder().getTradeId(), updOrder.getOrder().getStatus(), updOrder.getOrder().getRequestTxt(), null));
        }
    }
    processInsertCommand(order) {
        let instrumentDescriptor;
        instrumentDescriptor = this.instrumentsProvider.getInstrumentDescriptorByOfferId(order.getOfferId());
        if (instrumentDescriptor != null && instrumentDescriptor.getSubscriptionStatus() != "T") {
            this.instrumentsSubscriptionProvider.subscribeInstruments([instrumentDescriptor.getSymbol()], new OrdersManager.DummySubscribeInstrumentsCallback(this));
        }
        else {
            this.dxFeedOffersEnsurer.check([order.getOfferId()], new OrdersManager.DummyEnsureOffersLoadedCallback(this));
        }
        this.storage.addOrder(order);
        this.notifyOrderAdd(this.createOrderInfo(order.getOrderId(), order.getTradeId(), order.getStatus(), order.getRequestTxt(), null));
    }
    isExecuted(status) {
        return status == "F";
    }
    createOrderInfo(orderId, tradeId, status, requestTxt, error) {
        let builder;
        builder = new OrderInfoBuilder();
        builder.setOrderId(orderId);
        builder.setIsExecuted(this.isExecuted(status));
        builder.setTradeId(tradeId);
        builder.setError(error);
        builder.setStatus(status);
        builder.setRequestTxt(requestTxt);
        return builder.build();
    }
    notifyOrderChange(orderInfo) {
        this.checkEvents(orderInfo, null, null);
        this.orderChangePublisher.notifyAction(OrdersManager.OrderChangeAction.create(orderInfo));
    }
    notifyOrderAdd(orderInfo) {
        this.checkEvents(orderInfo, null, null);
        this.orderChangePublisher.notifyAction(OrdersManager.OrderAddAction.create(orderInfo));
    }
    notifyOrderDelete(orderInfo) {
        this.checkEvents(orderInfo, null, null);
        this.orderChangePublisher.notifyAction(OrdersManager.OrderDeleteAction.create(orderInfo));
    }
    notifyOrderError(orderInfo, offerId) {
        this.checkEvents(orderInfo, orderInfo.getError().getMessage(), offerId);
        this.orderChangePublisher.notifyAction(OrdersManager.OrderErrorAction.create(orderInfo));
    }
    checkEvents(orderInfo, error, offerId) {
        let event;
        event = null;
        if (orderInfo.getTradeId() != null && this.ordersManagerEvents.containsTradeId(orderInfo.getTradeId())) {
            event = this.ordersManagerEvents.getByTradeId(orderInfo.getTradeId());
            this.ordersManagerEvents.removeByTradeId(orderInfo.getTradeId());
        } else if (orderInfo.getOrderId() != null && this.ordersManagerEvents.containsOrderId(orderInfo.getOrderId())) {
            event = this.ordersManagerEvents.getByOrderId(orderInfo.getOrderId());
            this.ordersManagerEvents.removeByOrderId(orderInfo.getOrderId());
        } else if (orderInfo.getOrderId() != null) {
            event = this.pocessOrderCase(orderInfo);
        } else if (offerId != null) {
            event = this.pocessOfferCase(orderInfo, offerId);
        }
        if (event != null) {
            if (error == null) {
                event.stop();
                EventManager.getLogger().performance(event.build());
            }
            else {
                event.stopWithError(error);
            }
        }
    }
    pocessOrderCase(orderInfo) {
        let event, order;
        event = null;
        order = this.getOrderById(orderInfo.getOrderId());
        if (order != null) {
            event = this.pocessOfferCase(orderInfo, order.getOfferId());
        }
        return event;
    }
    pocessOfferCase(orderInfo, offerId) {
        let event;
        event = null;
        if (this.ordersManagerEvents.containsOfferAndCustomId(offerId, orderInfo.getRequestTxt())) {
            event = this.ordersManagerEvents.getByOfferAndCustomId(offerId, orderInfo.getRequestTxt());
            this.ordersManagerEvents.removeByOfferAndCustomId(offerId, orderInfo.getRequestTxt());
        }
        return event;
    }
    notifyStateChange(stateStatus) {
        this.logger.debug("OrdersManager. State status changed: " + (stateStatus).toString());
        this.state.setState(stateStatus);
        this.stateChangePublisher.notifyStateChange(this.state);
    }
}
module.exports = OrdersManager
OrdersManager.DummySubscribeInstrumentsCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccess() {
        return void(0);
    }
    onError(errorStr, unsucceededSymbols) {
        this._owner_.logger.error("OrdersManager. Silence subscribe error: " + errorStr);
    }
}
OrdersManager.DummyEnsureOffersLoadedCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        return void(0);
    }
}
OrdersManager.ReceiveNewMessageListener = class {
    owner;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(owner) {
        let instance;
        instance = new OrdersManager.ReceiveNewMessageListener(this);
        instance.owner = owner;
        return instance;
    }
    onNewMessageReceive(message) {
        this.owner.processMessage(message);
    }
}
OrdersManager.OrderChangeAction = class {
    listener;
    orderInfo;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(orderInfo) {
        let result;
        result = new OrdersManager.OrderChangeAction(this);
        result.orderInfo = orderInfo;
        return result;
    }
    setListener(listener) {
        this.listener = listener;
    }
    execute() {
        this.listener.onChange(this.orderInfo);
    }
}
OrdersManager.OrderAddAction = class {
    listener;
    orderInfo;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(orderInfo) {
        let result;
        result = new OrdersManager.OrderAddAction(this);
        result.orderInfo = orderInfo;
        return result;
    }
    setListener(listener) {
        this.listener = listener;
    }
    execute() {
        this.listener.onAdd(this.orderInfo);
    }
}
OrdersManager.OrderDeleteAction = class {
    listener;
    orderInfo;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(orderInfo) {
        let result;
        result = new OrdersManager.OrderDeleteAction(this);
        result.orderInfo = orderInfo;
        return result;
    }
    setListener(listener) {
        this.listener = listener;
    }
    execute() {
        this.listener.onDelete(this.orderInfo);
    }
}
OrdersManager.OrderErrorAction = class {
    listener;
    orderInfo;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(orderInfo) {
        let result;
        result = new OrdersManager.OrderErrorAction(this);
        result.orderInfo = orderInfo;
        return result;
    }
    setListener(listener) {
        this.listener = listener;
    }
    execute() {
        this.listener.onError(this.orderInfo);
    }
}
OrdersManager.GetOrdersStatusListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccess(message) {
        return void(0);
    }
    onError(error) {
        this._owner_.notifyStateChange(DataManagerState.NOT_LOADED);
        this.clear();
    }
    onCancel() {
        this._owner_.notifyStateChange(DataManagerState.NOT_LOADED);
        this.clear();
    }
    clear() {
        this._owner_.requestsNumber = 0;
        this._owner_.storage.clear();
    }
}
OrdersManager.CompleteRefreshAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        this._owner_.completeRefresh();
    }
}
