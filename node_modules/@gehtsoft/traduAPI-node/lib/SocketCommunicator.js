'use strict';
let SocketCommunicatorState = require('./SocketCommunicatorState.js');
let {wsFactory} = require('./importWebSocket');

class SocketCommunicator {
    #ws = null;
    #messageListeners = [];
    #stateListeners = [];
    #closed = false;

    connect(url) {
        let own = this;
        this.initWebsocket(url, 2500, 3)
            .then((socket) => {
                own.#ws = socket;
                own.#ws.onopen = function () {
                };
                own.#ws.onclose = function (event) {
                    own.notifyClosed(event)
                };
                own.#ws.onerror = function (event) {
                    own.onErrorHandler(event)
                };
                own.notifyOpen();
            })
            .catch((errorMessage) => {
                if (errorMessage != null) {
                    own.notifyError(errorMessage);
                } else {
                    own.notifyClosed();
                }
            })
    }

    close() {
        if (this.#ws != null) {
            this.#ws.close();
        }
        this.#closed = true;
    }

    send(message) {
        if (this.#ws != null) {
            this.#ws.send(message);
        }
    }

    getState() {
        return this.prepareStateFunc();
    }

    subscribeStateChange(listener) {
        this.#stateListeners.push(listener);
    }

    unsubscribeStateChange(listener) {
        for (let i = 0; i < this.#stateListeners.length; i++) {
            if (this.#stateListeners[i] === listener) {
                this.#stateListeners.splice(i, 1);
                return;
            }
        }
    }

    subscribeMessageReceive(listener) {
        this.#messageListeners.push(listener);
    }

    unsubscribeMessageReceive(listener) {
        for (let i = 0; i < this.#messageListeners.length; i++) {
            if (this.#messageListeners[i] === listener) {
                this.#messageListeners.splice(i, 1);
                return;
            }
        }
    }

    onMessageHandler(event) {
        if (this.#closed) {
            return;
        }
        let copy = Array.from(this.#messageListeners);
        for (let listener of copy) {
            listener.onReceive(event.data);
        }
    }

    notifyStateChange(state) {
        let copy = Array.from(this.#stateListeners);
        for (let listener of copy) {
            listener.onChange(state);
        }
    }

    notifyOpening() {
        let state = new SocketCommunicatorState();
        state.setState(1);
        this.notifyStateChange(state);
    }

    notifyOpen() {
        let state = new SocketCommunicatorState();
        state.setState(2);
        this.notifyStateChange(state);
    }

    notifyClosed() {
        let state = new SocketCommunicatorState();
        state.setState(0);
        this.notifyStateChange(state);
    }

    onErrorHandler(event) {
        if (event.message != null) {
            this.notifyError(event.message);
        } else {
            this.notifyClosed();
        }
    }

    notifyError(message) {
        let state = new SocketCommunicatorState();
        state.setStateWithError(0, this.createError(message));
        this.notifyStateChange(state);
    }

    createError(message) {
        return {
            getMessage: function () {
                return message
            }
        };
    }

    prepareStateFunc() {
        let result = new SocketCommunicatorState();
        let state = this.#ws != null ? this.#ws.readyState : 3;
        if (state === 0) { // CONNECTING
            result.setState(1);
        } else if (state === 1) { // OPEN
            result.setState(2);
        } else if (state === 2 || state === 3) { // CLOSING, CLOSED
            result.setState(0);
        }
        return result;
    }

    initWebsocket(url, timeoutMs, numberOfRetries) {
        let own = this;
        timeoutMs = timeoutMs ? timeoutMs : 1500;
        numberOfRetries = numberOfRetries ? numberOfRetries : 0;
        let hasReturned = false;
        let promise = new Promise((resolve, reject) => {
            setTimeout(function () {
                if (!hasReturned) {
                    rejectInternal("WebSocket connection time out");
                }
            }, timeoutMs);

            let websocket = wsFactory(url);
            websocket.onopen = function () {
                if (hasReturned) {
                    websocket.close();
                } else {
                    resolve(websocket);
                }
            };
            websocket.onclose = function () {
                rejectInternal();
            };
            websocket.onerror = function (event) {
                rejectInternal(event.message);
            };
            websocket.onmessage = function (event) {
                own.onMessageHandler(event)
            };

            function rejectInternal(message) {
                if (numberOfRetries <= 0) {
                    reject(message);
                } else if (!hasReturned) {
                    hasReturned = true;
                    own.initWebsocket(url, timeoutMs, numberOfRetries - 1).then(resolve, reject);
                }
            }
        });
        promise.then(function () {
            hasReturned = true;
        }, function () {
            hasReturned = true;
        });
        return promise;
    }
}

module.exports = SocketCommunicator;
