'use strict';
let CommandStatusPublisher = require('./CommandStatusPublisher.js');
let LogManager = require('./LogManager.js');
let MessageType = require('./MessageType.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
class TestRequestPdsCommand {
    session;
    login;
    applicationName;
    messageFactory;
    requestNumberGenerator;
    requestNumber;
    publisher;
    messageExecutor;
    periodInMilliseconds;
    pollingScheduler;
    messageExecutorCallback;
    messageRouter;
    receiveNewMessageListener;
    attempts;
    canceled;
    connectionParameters;
    attemptScheduler;
    messageType;
    logger;
    checkRequest;
    testRequestCommandCallback;
    constructor() {
        this.receiveNewMessageListener = new TestRequestPdsCommand.ReceiveNewMessageListener(this);
        this.publisher = new CommandStatusPublisher();
        this.periodInMilliseconds = 30000;
        this.messageExecutorCallback = new TestRequestPdsCommand.MessageExecutorCallback(this);
        this.canceled = false;
        this.attempts = 0;
        this.messageType = this.createMessageType();
        this.requestNumber = 0;
        this.logger = LogManager.getLogger();
        this.checkRequest = new TestRequestPdsCommand.CheckRequest(this);
        this.testRequestCommandCallback = null;
    }
    getCommandName() {
        return "TestRequestPdsCommand";
    }
    createMessageType() {
        return MessageType.TestRequestPds;
    }
    unsubscribeStatusChange(callback) {
        this.publisher.unsubscribe(callback);
    }
    setSession(session) {
        this.session = session;
    }
    subscribeStatusChange(callback) {
        this.publisher.subscribe(callback);
    }
    stop() {
        this.logger.debug("Stop command '" + this.getCommandName() + "'");
        this.messageExecutor.cancel();
        this.canceled = true;
        this.messageRouter.unsubscribeNewMessageReceive(this.messageType, this.receiveNewMessageListener);
        this.pollingScheduler.stop();
        this.attemptScheduler.stop();
    }
    execute() {
        this.logger.debug("Execute command '" + this.getCommandName() + "'");
        this.canceled = false;
        this.attempts = 0;
        this.messageRouter.subscribeNewMessageReceive(this.messageType, this.receiveNewMessageListener);
        this.pollingScheduler.startImmediately();
    }
    setTestRequestCommandCallback(testRequestCommandCallback) {
        this.testRequestCommandCallback = testRequestCommandCallback;
    }
    getSession() {
        return this.session;
    }
    createSchedulers() {
        this.pollingScheduler = scheduler.create(this.periodInMilliseconds, new TestRequestPdsCommand.TestRequestAction(this));
        this.attemptScheduler = scheduler.create(this.connectionParameters.getResilience().getPeriodInMilliseconds(), new TestRequestPdsCommand.AttemptAction(this));
    }
    getTransportMessage() {
        return this.messageFactory.createTestRequestForPdsRequestMessage(this.session, this.requestNumber);
    }
    getTransportMessageInner() {
        return this.getTransportMessage();
    }
    notifySuccess(heartbeatMessage) {
        this.testRequestCommandCallback.onSuccess(heartbeatMessage.getSubscribedSymbolsCheckSum(), heartbeatMessage.getNumberOfSubscribedSymbols(), new Array(0), this.session.getTradingTerminal().getSubId());
    }
    notifySuccessInner(heartbeatMessage) {
        this.notifySuccess(heartbeatMessage);
    }
}
module.exports = TestRequestPdsCommand
TestRequestPdsCommand.CheckRequest = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    isMyRequest(requestId) {
        return true;
    }
}
TestRequestPdsCommand.TestRequestAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        let transportMessage;
        this._owner_.pollingScheduler.stop();
        if (!this._owner_.canceled) {
            this._owner_.requestNumber = this._owner_.requestNumberGenerator.getNextRequestNumber();
            transportMessage = this._owner_.getTransportMessageInner();
            this._owner_.messageExecutor.execute(transportMessage, this._owner_.messageExecutorCallback);
            this._owner_.pollingScheduler.startWithDelay();
        }
    }
}
TestRequestPdsCommand.AttemptAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        this._owner_.attemptScheduler.stop();
        if (!this._owner_.canceled) {
            this._owner_.pollingScheduler.startImmediately();
        }
    }
}
TestRequestPdsCommand.MessageExecutorCallback = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccessSent() {
        this._owner_.logger.debug("Message '" + this._owner_.getCommandName() + "' successfully sent");
        this._owner_.attempts = 0;
    }
    onError(error) {
        this._owner_.attempts = this._owner_.attempts + 1;
        this._owner_.pollingScheduler.stop();
        if (this._owner_.attempts > this._owner_.connectionParameters.getResilience().getAttempts()) {
            this._owner_.messageRouter.unsubscribeNewMessageReceive(this._owner_.messageType, this._owner_.receiveNewMessageListener);
            this._owner_.logger.error("Send message '" + this._owner_.getCommandName() + "' failed: " + error);
            this._owner_.attempts = 0;
            this._owner_.publisher.notifyError(error);
            if (this._owner_.testRequestCommandCallback != null) {
                this._owner_.testRequestCommandCallback.onError(error);
            }
        }
        else {
            this._owner_.logger.warning("Send message '" + this._owner_.getCommandName() + "' failed: " + error);
            this._owner_.attemptScheduler.startWithDelay();
        }
    }
}
TestRequestPdsCommand.ReceiveNewMessageListener = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        let heartbeatMessage;
        this._owner_.logger.debug(this._owner_.getCommandName() + ". Receive message: " + message.getType());
        heartbeatMessage = message;
        if (this._owner_.checkRequest.isMyRequest(heartbeatMessage.getRequestId())) {
            if (this._owner_.testRequestCommandCallback != null) {
                this._owner_.notifySuccessInner(heartbeatMessage);
            }
        }
    }
}
