'use strict';
let jsonNode = require('@gehtsoft/LuaxStdlib-node').jsonNode;
let list = require('@gehtsoft/LuaxStdlib-node').list;
let DXFeedTimeSeriaBuilder = require('./DXFeedTimeSeriaBuilder.js');
let JsonReaderUtil = require('./JsonReaderUtil.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
class DxFeedTimeSeriesDataReader {
    static get CHANNEL() { return "/service/timeSeriesData"; }
    eventSymbolIndex;
    eventTimeIndex;
    eventFlagsIndex;
    indexIndex;
    timeIndex;
    sequenceIndex;
    countIndex;
    openIndex;
    highIndex;
    lowIndex;
    closeIndex;
    volumeIndex;
    vwapIndex;
    bidVolumeIndex;
    askVolumeIndex;
    impVolatilityIndex;
    openInterestIndex;
    parametersNumber;
    constructor() {
        this.eventSymbolIndex = 0;
        this.eventTimeIndex = 1;
        this.eventFlagsIndex = 2;
        this.indexIndex = 3;
        this.timeIndex = 4;
        this.sequenceIndex = 5;
        this.countIndex = 6;
        this.openIndex = 7;
        this.highIndex = 8;
        this.lowIndex = 9;
        this.closeIndex = 10;
        this.volumeIndex = 11;
        this.vwapIndex = 12;
        this.bidVolumeIndex = 13;
        this.askVolumeIndex = 14;
        this.impVolatilityIndex = 15;
        this.openInterestIndex = 16;
        this.parametersNumber = 17;
    }
    read(root) {
        let dXFeedTimeSeria;
        dXFeedTimeSeria = [];
        if (root.getType() == jsonNode.OBJECT) {
            dXFeedTimeSeria = this.parseObject(root, dXFeedTimeSeria);
        }
        return dXFeedTimeSeria;
    }
    parseObject(node, quotes) {
        let dXFeedTimeSeria, channelProperty, data;
        dXFeedTimeSeria = [];
        channelProperty = node.getPropertyByName("channel");
        if (channelProperty != null && channelProperty.getValueAsString() == DxFeedTimeSeriesDataReader.CHANNEL) {
            data = node.getPropertyByName("data");
            if (data != null) {
                dXFeedTimeSeria = this.parseSeries(data);
            }
        }
        return dXFeedTimeSeria;
    }
    parseSeries(root) {
        let n, i, node, dXFeedTimeSeriesList, result;
        n = root.getChildrenCount();
        dXFeedTimeSeriesList = new list();
        for (i = 0; i <= n - 1; i += 1) {
            node = root.getChildByIndex(i);
            if (node.getType() == jsonNode.ARRAY && node.getChildrenCount() == 2) {
                this.tryParseDescription(node);
            } else if (node.getType() == jsonNode.ARRAY && node.getChildrenCount() >= this.parametersNumber) {
                this.parse(node, dXFeedTimeSeriesList);
            }
        }
        result = new Array(dXFeedTimeSeriesList.length());
        for (i = 0; i <= dXFeedTimeSeriesList.length() - 1; i += 1) {
            result[i] = dXFeedTimeSeriesList.get(i);
        }
        return result;
    }
    tryParseDescription(node) {
        let arr, item, n, i;
        if (node.getChildByIndex(0).getType() == jsonNode.STRING && node.getChildByIndex(1).getType() == jsonNode.ARRAY) {
            if (node.getChildByIndex(0).getValueAsString() == "Candle") {
                arr = node.getChildByIndex(1);
                n = arr.getChildrenCount();
                this.parametersNumber = n;
                for (i = 0; i <= n - 1; i += 1) {
                    item = arr.getChildByIndex(i);
                    if (item.getType() == jsonNode.STRING) {
                        this.processDescriptionItem(item.getValueAsString(), i);
                    }
                }
            }
        }
    }
    processDescriptionItem(value, index) {
        if (value == "eventSymbol") {
            this.eventSymbolIndex = index;
        } else if (value == "eventTime") {
            this.eventTimeIndex = index;
        } else if (value == "eventFlags") {
            this.eventFlagsIndex = index;
        } else if (value == "index") {
            this.indexIndex = index;
        } else if (value == "time") {
            this.timeIndex = index;
        } else if (value == "sequence") {
            this.sequenceIndex = index;
        } else if (value == "count") {
            this.countIndex = index;
        } else if (value == "open") {
            this.openIndex = index;
        } else if (value == "high") {
            this.highIndex = index;
        }         else {
            this.processDescriptionItemRest(value, index);
        }
    }
    processDescriptionItemRest(value, index) {
        if (value == "low") {
            this.lowIndex = index;
        } else if (value == "close") {
            this.closeIndex = index;
        } else if (value == "volume") {
            this.volumeIndex = index;
        } else if (value == "vwap") {
            this.vwapIndex = index;
        } else if (value == "bidVolume") {
            this.bidVolumeIndex = index;
        } else if (value == "askVolume") {
            this.askVolumeIndex = index;
        } else if (value == "impVolatility") {
            this.impVolatilityIndex = index;
        } else if (value == "openInterest") {
            this.openInterestIndex = index;
        }
    }
    parse(node, dXFeedTimeSeriesList) {
        let n, len;
        n = 0;
        len = node.getChildrenCount();
        while(n <= len - this.parametersNumber) {
            dXFeedTimeSeriesList.add(this.parseSeria(node, n));
            n = n + this.parametersNumber;
        }
    }
    parseSeria(node, n) {
        let builder, openNode, highNode, lowNode, close;
        builder = new DXFeedTimeSeriaBuilder();
        openNode = node.getChildByIndex(this.openIndex + n);
        highNode = node.getChildByIndex(this.highIndex + n);
        lowNode = node.getChildByIndex(this.lowIndex + n);
        builder.setSymbol(node.getChildByIndex(this.eventSymbolIndex + n).getValueAsString()).setEventTime(node.getChildByIndex(this.eventTimeIndex + n).getValueAsDatetime()).setEventFlags(node.getChildByIndex(this.eventFlagsIndex + n).getValueAsInt()).setIndex(node.getChildByIndex(this.timeIndex + n).getValueAsIntegerString()).setTime(node.getChildByIndex(this.timeIndex + n).getValueAsDatetime()).setSequence(node.getChildByIndex(this.sequenceIndex + n).getValueAsInt()).setCount(node.getChildByIndex(this.countIndex + n).getValueAsInt()).setOpen(JsonReaderUtil.getRealFromJsonNode(openNode)).setHigh(JsonReaderUtil.getRealFromJsonNode(highNode)).setLow(JsonReaderUtil.getRealFromJsonNode(lowNode)).setClose(JsonReaderUtil.getRealFromJsonNode(node.getChildByIndex(this.closeIndex + n))).setVolume(JsonReaderUtil.getRealFromJsonNode(node.getChildByIndex(this.volumeIndex + n))).setVwap(JsonReaderUtil.getRealFromJsonNode(node.getChildByIndex(this.vwapIndex + n))).setBidVolume(JsonReaderUtil.getRealFromJsonNode(node.getChildByIndex(this.bidVolumeIndex + n))).setAskVolume(JsonReaderUtil.getRealFromJsonNode(node.getChildByIndex(this.askVolumeIndex + n))).setImpVolatility(JsonReaderUtil.getRealFromJsonNode(node.getChildByIndex(this.impVolatilityIndex + n))).setOpenInterest(JsonReaderUtil.getRealFromJsonNode(node.getChildByIndex(this.openInterestIndex + n)));
        close = builder.getClose();
        if (openNode.getType() == jsonNode.STRING && stdlib.lower(openNode.getValueAsString()) == "nan" && close > 0.0) {
            builder.setOpen(close);
        }
        if (highNode.getType() == jsonNode.STRING && stdlib.lower(highNode.getValueAsString()) == "nan" && close > 0.0) {
            builder.setHigh(close);
        }
        if (lowNode.getType() == jsonNode.STRING && stdlib.lower(lowNode.getValueAsString()) == "nan" && close > 0.0) {
            builder.setLow(close);
        }
        return builder.build();
    }
}
module.exports = DxFeedTimeSeriesDataReader
