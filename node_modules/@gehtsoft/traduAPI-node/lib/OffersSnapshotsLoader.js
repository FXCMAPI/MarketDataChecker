'use strict';
let LogManager = require('./LogManager.js');
let OffersSnapshotsSubscriptionStatusTracker = require('./OffersSnapshotsSubscriptionStatusTracker.js');
let InstrumentDescriptorSplitterByPriceStream = require('./InstrumentDescriptorSplitterByPriceStream.js');
let list = require('@gehtsoft/LuaxStdlib-node').list;
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let CompositeSubscriptionRequest = require('./CompositeSubscriptionRequest.js');
let SubscriptionInstrumentRequest = require('./SubscriptionInstrumentRequest.js');
let MessageType = require('./MessageType.js');
let FXConnectLiteErrorBuilder = require('./FXConnectLiteErrorBuilder.js');
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let FXConnectLiteErrorCodes = require('./FXConnectLiteErrorCodes.js');
let PriceFeedCommandDescriptorBuilder = require('./PriceFeedCommandDescriptorBuilder.js');
let ExecutionTimeEvenUtil = require('./ExecutionTimeEvenUtil.js');
let ExecutionTimeEventName = require('./ExecutionTimeEventName.js');
class OffersSnapshotsLoader {
    requestNumberGenerator;
    commandFactory;
    instrumentsProvider;
    logger;
    resultList;
    trackNumber;
    subscriptionStatusTracker;
    static create(commandFactory, instrumentsProvider, requestNumberGenerator, messageRouter) {
        let result;
        result = new OffersSnapshotsLoader();
        result.requestNumberGenerator = requestNumberGenerator;
        result.commandFactory = commandFactory;
        result.instrumentsProvider = instrumentsProvider;
        result.logger = LogManager.getLogger();
        result.subscriptionStatusTracker = OffersSnapshotsSubscriptionStatusTracker.createInstance(messageRouter);
        result.trackNumber = -1;
        return result;
    }
    setLogger(logger) {
        this.logger = logger;
    }
    loadOffersSnapshot(offerIds, callback) {
        let command, commandsList, splitter, groupedResult, priceStreams, offerIdsGroupedByStream, i, ex, offerSnapshotCommandCallback, requestNumber, compositeSubscriptionRequest, finishSnapshotAction, commandStatusListener;
        splitter = new InstrumentDescriptorSplitterByPriceStream();
        this.resultList = new list();
        this.subscriptionStatusTracker.setResultList(this.resultList);
        this.trackNumber = -1;
        try {
            groupedResult = splitter.split(this.createInstrumentDescriptors(offerIds));
            priceStreams = groupedResult.getPriceStreams();
            offerSnapshotCommandCallback = new OffersSnapshotsLoader.OfferSnapshotCommandCallback(this);
            offerSnapshotCommandCallback.setLogger(this.logger);
            offerSnapshotCommandCallback.setCallback(callback);
            commandsList = new list();
            compositeSubscriptionRequest = CompositeSubscriptionRequest.create();
            for (i = 0; i <= priceStreams.length - 1; i += 1) {
                requestNumber = this.requestNumberGenerator.getNextRequestNumber();
                offerIdsGroupedByStream = groupedResult.getOffersIds(priceStreams[i]);
                command = this.createOfferSnapshotCommand(offerIdsGroupedByStream, requestNumber, offerSnapshotCommandCallback);
                commandStatusListener = new OffersSnapshotsLoader.CommandStatusListener(this);
                commandStatusListener.setLogger(this.logger);
                commandStatusListener.setCallback(callback);
                command.subscribeStatusChange(commandStatusListener);
                compositeSubscriptionRequest.addRequest(SubscriptionInstrumentRequest.create(requestNumber, MessageType.PriceFeed, offerIdsGroupedByStream));
                commandsList.add(command);
            }
            if (compositeSubscriptionRequest.length() > 0) {
                finishSnapshotAction = new OffersSnapshotsLoader.FinishSnapshotAction(this);
                finishSnapshotAction.setCallback(callback);
                this.trackNumber = this.subscriptionStatusTracker.track(compositeSubscriptionRequest, finishSnapshotAction);
                finishSnapshotAction.startTimeEvent();
                for (i = 0; i <= commandsList.length() - 1; i += 1) {
                    command = commandsList.get(i);
                    command.execute();
                }
            }
        } catch(exTemp1) {
            ex = stdlib.ensureException(exTemp1);
            this.cancel(ex.getMessage(), callback);
        }
    }
    cancel(error, callback) {
        let errorBuilder;
        errorBuilder = new FXConnectLiteErrorBuilder();
        errorBuilder.setMessage(error);
        if (this.trackNumber >= 0) {
            this.subscriptionStatusTracker.cancel(this.trackNumber);
        }
        callback.onError(errorBuilder);
    }
    createInstrumentDescriptors(offerIds) {
        let instrumentDescriptors, instrumentDescriptor, i, errorMessage;
        instrumentDescriptors = new Array(offerIds.length);
        for (i = 0; i <= offerIds.length - 1; i += 1) {
            instrumentDescriptor = this.instrumentsProvider.getInstrumentDescriptorByOfferId(offerIds[i]);
            if (instrumentDescriptor != null) {
                instrumentDescriptors[i] = instrumentDescriptor;
            }
            else {
                errorMessage = "OffersSnapshotsLoader: InstrumentDescriptor not found for offerId='" + offerIds[i] + "'";
                this.logger.error(errorMessage);
                throw exception.create(FXConnectLiteErrorCodes.CODE_DATA_NOT_EXIST, errorMessage);
            }
        }
        return instrumentDescriptors;
    }
    createOfferSnapshotCommand(offerIds, requestNumber, offerSnapshotCommandCallback) {
        let instrumentDescriptors, priceStream;
        instrumentDescriptors = this.createInstrumentDescriptors(offerIds);
        if (instrumentDescriptors.length > 0) {
            priceStream = instrumentDescriptors[0].getPriceStreamId();
        }
        return this.commandFactory.createOfferSnapshotCommand(instrumentDescriptors, this.preparePriceFeedCommandDescriptor(priceStream), requestNumber, offerSnapshotCommandCallback);
    }
    preparePriceFeedCommandDescriptor(priceStreamId) {
        let builder;
        builder = new PriceFeedCommandDescriptorBuilder();
        builder.setSubscriptionRequestType(PriceFeedCommandDescriptorBuilder.SNAPSHOT);
        builder.setMarketDepth(1);
        builder.setMdUpdateType(0);
        builder.setFxcmTimingInterval("0");
        builder.setFxcmDasMessagePriceStream(priceStreamId);
        builder.setIncludeWeekends(true);
        return builder.build();
    }
}
module.exports = OffersSnapshotsLoader
OffersSnapshotsLoader.OfferSnapshotCommandCallback = class {
    logger;
    callback;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setLogger(logger) {
        this.logger = logger;
    }
    setCallback(callback) {
        this.callback = callback;
    }
    onError(error) {
        this.logger.error("OffersSnapshotsLoader.OfferSnapshotCommandCallback.onError(): " + error);
        this._owner_.cancel(error, this.callback);
    }
}
OffersSnapshotsLoader.CommandStatusListener = class {
    logger;
    callback;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setLogger(logger) {
        this.logger = logger;
    }
    setCallback(callback) {
        this.callback = callback;
    }
    onSuccess(message) {
        return void(0);
    }
    onError(error) {
        this.logger.error("OffersSnapshotsLoader.CommandStatusListener.onError(): " + error);
        this._owner_.cancel(error, this.callback);
    }
    onCancel() {
        return void(0);
    }
}
OffersSnapshotsLoader.FinishSnapshotAction = class {
    callback;
    logger;
    executionTimeEvent;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
        this.logger = LogManager.getLogger();
        this.executionTimeEvent = null;
    }
    startTimeEvent() {
        this.executionTimeEvent = ExecutionTimeEvenUtil.eventStart(ExecutionTimeEventName.GetLatestOffersSnapshotTime);
    }
    onSuccess() {
        let offers, i;
        offers = new Array(this._owner_.resultList.length());
        for (i = 0; i <= offers.length - 1; i += 1) {
            offers[i] = this._owner_.resultList.get(i);
        }
        ExecutionTimeEvenUtil.eventStop(this.executionTimeEvent);
        this.callback.onSuccess(offers);
    }
    onError(error, unsucceededSymbols) {
        let builder;
        if (this._owner_.resultList.length() > 0) {
            this.onSuccess();
            return;
        }
        builder = new FXConnectLiteErrorBuilder();
        builder.setMessage(error);
        ExecutionTimeEvenUtil.eventStopWithError(this.executionTimeEvent, error);
        this.callback.onError(builder);
    }
    setCallback(callback) {
        this.callback = callback;
    }
}
