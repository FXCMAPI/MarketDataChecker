'use strict';
let LogManager = require('./LogManager.js');
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let FXConnectLiteErrorCodes = require('./FXConnectLiteErrorCodes.js');
let MathUtil = require('./MathUtil.js');
let variantCast = require('@gehtsoft/LuaxStdlib-node').variantCast;
let OrderTrailingStopData = require('./OrderTrailingStopData.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
class OrderTrailingStopCalculator {
    static get POINT_SIZE_EPSILON() { return 1E-06; }
    static get TRAIL_MOVE_EPSILON() { return 0.0001; }
    calculate(order, offer, instrument, trailingType) {
        let dynamicStopMovePips, isStop, stopMove, trailMove;
        if (order == null) {
            LogManager.getLogger().error("OrderTrailingStopCalculator.calculate(): order is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "order is not set");
        }
        if (instrument == null) {
            LogManager.getLogger().error("OrderTrailingStopCalculator.calculate(): instrument is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "instrument is not set");
        }
        if (trailingType == null) {
            LogManager.getLogger().error("OrderTrailingStopCalculator.calculate(): trailingType is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "trailingType is not set");
        }
        dynamicStopMovePips = MathUtil.pow(0.1, variantCast.fromReal(instrument.getFractionalPipSize()).asInt());
        isStop = this.isStopOrder(order.getBuySell(), order.getSide());
        if (this.isDynamicTrailingStop(trailingType, order.getTrailStep())) {
            stopMove = dynamicStopMovePips;
        }
        else {
            stopMove = variantCast.fromInt(order.getTrailStep()).asReal();
        }
        trailMove = this.calculateTrailMove(order, offer, instrument, isStop, stopMove);
        if (this.isDynamicTrailingStop(trailingType, order.getTrailStep()) && instrument.getPointSize() >= OrderTrailingStopCalculator.POINT_SIZE_EPSILON) {
            return this.calculateDynamicTrailStopData(order, instrument, isStop, stopMove, trailMove);
        }
        return OrderTrailingStopData.create(order.getRate(), order.getRateMax(), order.getTrailRate(), trailMove);
    }
    calculateTrailMove(order, offer, instrument, isStop, stopMove) {
        let trailMove, isBuy, pow10Digits, i, ask, bid;
        ask = 0.0;
        bid = 0.0;
        if (offer != null) {
            ask = offer.getAsk();
            bid = offer.getBid();
        }
        isBuy = order.getBuySell() == "B";
        if (isBuy) {
            trailMove = order.getTrailRate() - ask;
            trailMove = trailMove + instrument.getAskAdjustment();
        }
        else {
            trailMove = bid - order.getTrailRate();
            trailMove = trailMove - instrument.getBidAdjustment();
        }
        if (!isStop) {
            trailMove = trailMove * -1;
        }
        trailMove = trailMove / instrument.getPointSize();
        trailMove = stopMove - trailMove;
        pow10Digits = 1;
        for (i = 0; i <= instrument.getDigits() - 1; i += 1) {
            pow10Digits = pow10Digits * 10;
        }
        trailMove = trailMove * pow10Digits;
        trailMove = stdlib.roundInl(trailMove, variantCast.fromReal(instrument.getFractionalPipSize()).asInt());
        trailMove = trailMove / pow10Digits;
        return trailMove;
    }
    calculateDynamicTrailStopData(order, instrument, isStop, stopMove, inTrailMove) {
        let trlRate, rate, rate3, trailMove, pointSize, stopInc, isBuy;
        isBuy = order.getBuySell() == "B";
        pointSize = instrument.getPointSize();
        trailMove = inTrailMove;
        stopInc = stopMove * pointSize;
        if (isBuy) {
            stopInc = -stopInc;
        }
        if (!isStop) {
            stopInc = -stopInc;
        }
        trlRate = order.getTrailRate();
        if (this.isRangeAndNonPeggedOrder(order)) {
            rate = order.getRateMin();
            rate3 = order.getRateMax();
        }
        else {
            rate = order.getRate();
            rate3 = 0.0;
        }
        while(trailMove <= OrderTrailingStopCalculator.TRAIL_MOVE_EPSILON) {
            trlRate = trlRate + stopInc;
            rate = rate + stopInc;
            rate3 = rate3 + stopInc;
            trailMove = trailMove + stopMove;
        }
        return OrderTrailingStopData.create(rate, rate3, trlRate, trailMove);
    }
    isDynamicTrailingStop(trailingType, trailingStep) {
        if (trailingType.isTrailingDynamic() || trailingType.isTrailingDynamicAndFluctuate()) {
            return trailingStep == 1;
        } else if (trailingType.isTrailingStopDynamic()) {
            return true;
        }
        return false;
    }
    isStopOrder(buySell, side) {
        if (buySell == "B" && side > 0) {
            return true;
        }
        return buySell == "S" && side < 0;
    }
    isRangeAndNonPeggedOrder(order) {
        return order.getRateMin() != 0.0 && order.getRateMax() != 0.0;
    }
}
module.exports = OrderTrailingStopCalculator
