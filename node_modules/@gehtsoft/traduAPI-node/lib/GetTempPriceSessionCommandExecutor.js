'use strict';
let LogManager = require('./LogManager.js');
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let MessageType = require('./MessageType.js');
class GetTempPriceSessionCommandExecutor {
    mTradingTerminal;
    getTemporarySessionCommand;
    timeoutScheduler;
    logger;
    timeoutConnectionCallback;
    mPriceSessionCommandExecutor;
    pdasTempPriceSessionIdProvider;
    constructor() {
        this.logger = LogManager.getLogger();
        this.timeoutScheduler = null;
        this.mPriceSessionCommandExecutor = null;
    }
    static create(commandEnvironment, commandFactory, login, token, tradeSession, priceTerminal, pdasTempPriceSessionIdProvider) {
        let getPriceSessionCommandExecutor;
        getPriceSessionCommandExecutor = new GetTempPriceSessionCommandExecutor();
        getPriceSessionCommandExecutor.getTemporarySessionCommand = commandFactory.createGetTemporaryPriceSessionBySsoTokenCommand(commandEnvironment, tradeSession, priceTerminal, token, login);
        getPriceSessionCommandExecutor.mTradingTerminal = commandEnvironment.getTradingTerminal();
        getPriceSessionCommandExecutor.pdasTempPriceSessionIdProvider = pdasTempPriceSessionIdProvider;
        getPriceSessionCommandExecutor.initScheduler(commandEnvironment);
        return getPriceSessionCommandExecutor;
    }
    initScheduler(commandEnvironment) {
        this.timeoutConnectionCallback = new GetTempPriceSessionCommandExecutor.TimeoutConnectionCallback(this);
        this.timeoutScheduler = scheduler.create(commandEnvironment.getConnectionParameters().getLoginTimeoutInSeconds() * 1000, this.timeoutConnectionCallback);
    }
    setSuccessor(priceSessionCommandExecutor) {
        this.mPriceSessionCommandExecutor = priceSessionCommandExecutor;
    }
    execute(pdasPriceTerminalControllerCallback) {
        let temporarySessionCommandListener;
        this.logger.debug("request price session");
        this.timeoutConnectionCallback.setCallback(pdasPriceTerminalControllerCallback);
        this.timeoutScheduler.startWithDelay();
        temporarySessionCommandListener = new GetTempPriceSessionCommandExecutor.TemporarySessionCommandListener(this);
        temporarySessionCommandListener.setTerminal(this.mTradingTerminal);
        temporarySessionCommandListener.setCallback(pdasPriceTerminalControllerCallback);
        temporarySessionCommandListener.setNextExecutor(this.mPriceSessionCommandExecutor);
        this.getTemporarySessionCommand.subscribeStatusChange(temporarySessionCommandListener);
        this.getTemporarySessionCommand.execute();
    }
    stop() {
        this.timeoutScheduler.stop();
    }
}
module.exports = GetTempPriceSessionCommandExecutor
GetTempPriceSessionCommandExecutor.TimeoutConnectionCallback = class {
    pdasPriceTerminalControllerCallback;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setCallback(pdasPriceTerminalControllerCallback) {
        this.pdasPriceTerminalControllerCallback = pdasPriceTerminalControllerCallback;
    }
    invoke() {
        this._owner_.timeoutScheduler.stop();
        this.pdasPriceTerminalControllerCallback.onError("Timeout");
    }
}
GetTempPriceSessionCommandExecutor.TemporarySessionCommandListener = class {
    tradingTerminal;
    nextExecutor;
    pdasPriceTerminalControllerCallback;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    setTerminal(tradingTerminal) {
        this.tradingTerminal = tradingTerminal;
    }
    setNextExecutor(nextExecutor) {
        this.nextExecutor = nextExecutor;
    }
    setCallback(pdasPriceTerminalControllerCallback) {
        this.pdasPriceTerminalControllerCallback = pdasPriceTerminalControllerCallback;
    }
    onSuccess(message) {
        let getTemporaryPriceSessionMessage, temporaryPriceSession;
        this._owner_.timeoutScheduler.stop();
        this._owner_.getTemporarySessionCommand.unsubscribeStatusChange(this);
        if (message != null && message.getType() == MessageType.GetTemporaryPriceSession) {
            getTemporaryPriceSessionMessage = message;
            temporaryPriceSession = getTemporaryPriceSessionMessage.getTemporaryPriceSession();
            this._owner_.logger.debug("temporary price session received. session: " + temporaryPriceSession);
            this._owner_.pdasTempPriceSessionIdProvider.setSessionId(temporaryPriceSession);
            this.nextExecutor.execute(this.pdasPriceTerminalControllerCallback);
        }
        else {
            this.pdasPriceTerminalControllerCallback.onError("The message in 'Terminal CommandStatusListener' is invalid or has an unexpected type");
        }
    }
    onError(error) {
        this._owner_.getTemporarySessionCommand.unsubscribeStatusChange(this);
        this._owner_.timeoutScheduler.stop();
        this.pdasPriceTerminalControllerCallback.onError("Get temporary price session: " + error);
    }
    onCancel() {
        this._owner_.timeoutScheduler.stop();
        this._owner_.getTemporarySessionCommand.unsubscribeStatusChange(this);
        this.pdasPriceTerminalControllerCallback.onError("Cancel");
    }
}
