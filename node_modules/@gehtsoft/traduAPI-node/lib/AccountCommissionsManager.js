'use strict';
let DataManagerState = require('./DataManagerState.js');
let DataManagerStatePublisher = require('./DataManagerStatePublisher.js');
let LogManager = require('./LogManager.js');
let queue = require('@gehtsoft/LuaxStdlib-node').queue;
let MessageType = require('./MessageType.js');
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let FXConnectLiteErrorCodes = require('./FXConnectLiteErrorCodes.js');
let StateStatusUtils = require('./StateStatusUtils.js');
let list = require('@gehtsoft/LuaxStdlib-node').list;
let StringValueObject = require('./StringValueObject.js');
let GetProfilesQuery = require('./GetProfilesQuery.js');
let CollectionUtils = require('./CollectionUtils.js');
let string_map = require('@gehtsoft/LuaxStdlib-node').string_map;
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let ExecutionTimeEvenUtil = require('./ExecutionTimeEvenUtil.js');
let ExecutionTimeEventName = require('./ExecutionTimeEventName.js');
let StringUtil = require('./StringUtil.js');
class AccountCommissionsManager {
    static get TIMEOUT_INTERVAL() { return 30000; }
    state;
    stateChangePublisher;
    storage;
    messageRouter;
    commandFactory;
    sessionProvider;
    messageFactory;
    requestNumberGenerator;
    messageExecutor;
    receiveNewMessageListener;
    connected;
    logger;
    commissionsCalculator;
    accountsManager;
    instrumentsProvider;
    eventRefresh;
    timeOutScheduler;
    requestAccounts;
    requestsNumber;
    timeoutInterval;
    sendsQueue;
    systemSettingsProvider;
    constructor() {
        this.requestsNumber = 0;
        this.state = new DataManagerState();
        this.stateChangePublisher = new DataManagerStatePublisher();
        this.setReceiveNewMessageListener();
        this.logger = LogManager.getLogger();
        this.timeOutScheduler = null;
        this.requestAccounts = null;
        this.timeoutInterval = AccountCommissionsManager.TIMEOUT_INTERVAL;
        this.sendsQueue = new queue();
    }
    static create(accountsManager, instrumentsProvider, commissionsCalculator, storage, commandFactory, messageRouter, messageExecutor, sessionProvider, messageFactory, requestNumberGenerator, systemSettingsProvider) {
        let result;
        result = new AccountCommissionsManager();
        result.accountsManager = accountsManager;
        result.instrumentsProvider = instrumentsProvider;
        result.commandFactory = commandFactory;
        result.messageRouter = messageRouter;
        result.messageExecutor = messageExecutor;
        result.sessionProvider = sessionProvider;
        result.messageFactory = messageFactory;
        result.requestNumberGenerator = requestNumberGenerator;
        result.storage = storage;
        result.commissionsCalculator = commissionsCalculator;
        result.systemSettingsProvider = systemSettingsProvider;
        result.subscribeOnRequiredMessages();
        return result;
    }
    subscribeOnRequiredMessages() {
        this.messageRouter.subscribeNewMessageReceive(MessageType.GetAccountCommissions, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Connected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Disconnected, this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(MessageType.Reconnecting, this.receiveNewMessageListener);
    }
    setReceiveNewMessageListener() {
        this.receiveNewMessageListener = AccountCommissionsManager.ReceiveNewMessageListener.create(this);
    }
    isCommissionEnabled() {
        return this.systemSettingsProvider.getPropertyByName("COMMISSIONED_UI_ENABLED") != "N";
    }
    getOpenCommission(offer, account, amount, buySell, rate) {
        this.checkGetCommissionParameters(account, buySell, "getOpenCommission");
        if (!this.isCommissionEnabled()) {
            return 0.0;
        }
        return this.commissionsCalculator.getOpenCommission(offer, account, amount, buySell == "B", rate);
    }
    getCloseCommission(offer, account, amount, buySell, rate) {
        this.checkGetCommissionParameters(account, buySell, "getCloseCommission");
        if (!this.isCommissionEnabled()) {
            return 0.0;
        }
        return this.commissionsCalculator.getCloseCommission(offer, account, amount, buySell == "B", rate);
    }
    checkGetCommissionParameters(account, buySell, methodName) {
        if (account == null) {
            this.logger.error("AccountCommissionsManager." + methodName + "(): account is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "account is not set");
        }
        if (buySell == null) {
            this.logger.error("AccountCommissionsManager." + methodName + "(): buySell is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "buySell is not set");
        }
    }
    notifyStateChangeWithError(stateStatus, error) {
        StateStatusUtils.notifyStateChangeWithError(this.state, this.stateChangePublisher, stateStatus, error, this.logger, "AccountCommissionsManager");
    }
    notifyStateChange(stateStatus) {
        this.logger.debug("AccountCommissionsManager. State status changed: " + (stateStatus).toString());
        this.state.setState(stateStatus);
        this.stateChangePublisher.notifyStateChange(this.state);
    }
    subscribeStateChange(listener) {
        if (listener == null) {
            this.logger.error("AccountCommissionsManager.subscribeStateChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.stateChangePublisher.subscribe(listener);
    }
    unsubscribeStateChange(listener) {
        if (listener == null) {
            this.logger.error("AccountCommissionsManager.unsubscribeStateChange(): listener is not set");
            throw exception.create(FXConnectLiteErrorCodes.CODE_REQUIRED_PARAMETER_NOT_SET, "listener is not set");
        }
        this.stateChangePublisher.unsubscribe(listener);
    }
    getState() {
        return this.state;
    }
    refresh() {
        let queueItem, offerIdsList, instrumentDescriptors, instrumentDescriptor, i;
        this.logger.info("AccountCommissionsManager. Load all rollover profiles from server");
        if (!this.connected) {
            this.logger.warning("AccountCommissionsManager. Session not connected");
            return;
        }
        if (this.getState().isLoading()) {
            this.logger.warning("AccountCommissionsManager. Manager is still loading");
            return;
        }
        offerIdsList = new list();
        instrumentDescriptors = this.instrumentsProvider.getAllInstrumentDescriptors();
        for (i = 0; i <= instrumentDescriptors.length - 1; i += 1) {
            instrumentDescriptor = instrumentDescriptors[i];
            if (instrumentDescriptor.getSubscriptionStatus() == "T" || instrumentDescriptor.getSubscriptionStatus() == "V") {
                offerIdsList.add(StringValueObject.create(instrumentDescriptor.getOfferId()));
            }
        }
        queueItem = GetProfilesQuery.create(CollectionUtils.stringListToArray(offerIdsList), new AccountCommissionsManager.ActionStartRefresh(this), new AccountCommissionsManager.ActionStopRefresh(this));
        this.processAccountCommissionsCommandQuery(queueItem);
    }
    processAccountCommissionsCommandQuery(queueItem) {
        if (!this.isCommissionEnabled()) {
            queueItem.getActionStart().invoke();
            queueItem.getActionStop().invoke();
            return;
        }
        this.sendsQueue.enqueue(queueItem);
        if (this.sendsQueue.length() == 1) {
            this.checkQueue();
        }
    }
    checkQueue() {
        let accounts, queueItem, accountIds, getAccountCommissionsCommand, i, timeoutAction;
        if (this.sendsQueue.length() > 0) {
            queueItem = this.sendsQueue.peek();
            accounts = this.accountsManager.getAccountsInfo();
            this.requestsNumber = 0;
            queueItem.getActionStart().invoke();
            this.requestAccounts = new string_map();
            if (queueItem.getOfferIds().length > 0 && accounts.length > 0) {
                timeoutAction = new AccountCommissionsManager.TimeoutAction(this);
                this.timeOutScheduler = scheduler.create(this.timeoutInterval, timeoutAction);
                this.timeOutScheduler.startWithDelay();
                accountIds = new Array(accounts.length);
                this.requestsNumber = accounts.length;
                for (i = 0; i <= accounts.length - 1; i += 1) {
                    accountIds[i] = accounts[i].getId();
                    this.requestAccounts.set(accountIds[i], StringValueObject.create(accountIds[i]));
                }
                getAccountCommissionsCommand = this.commandFactory.createGetAccountCommissionsCommand(accountIds, queueItem.getOfferIds(), this.messageExecutor, this.sessionProvider.getSession(), this.messageFactory, this.requestNumberGenerator);
                getAccountCommissionsCommand.execute();
            }
            else {
                this.logger.warning("AccountCommissionsManager. No instruments descriptors or/and accounts found for checkQueue()");
                this.sendsQueue.dequeue();
                this.checkQueue();
                queueItem.getActionStop().invoke();
            }
        }
    }
    processAccountCommissions(getAccountCommissionsMessage) {
        let accountCommissions, accountId, queueItem, i, offerIds;
        accountCommissions = getAccountCommissionsMessage.getAccountCommissions();
        this.requestsNumber = this.requestsNumber - 1;
        accountId = getAccountCommissionsMessage.getAcctId();
        if (accountId != null) {
            if (this.requestAccounts.contains(accountId)) {
                this.requestAccounts.remove(accountId);
            }
            offerIds = getAccountCommissionsMessage.getOfferIds();
            for (i = 0; i <= offerIds.length - 1; i += 1) {
                this.storage.clearAccountCommissions(accountId, offerIds[i]);
            }
        }
        this.storage.addAccountCommissions(accountCommissions);
        if (this.requestsNumber == 0 && this.sendsQueue.length() > 0) {
            this.stopTimeout();
            queueItem = this.sendsQueue.dequeue();
            this.checkQueue();
            queueItem.getActionStop().invoke();
        }
    }
    processMessage(message) {
        this.logger.debug("AccountCommissionsManager. Receive message: " + message.getType());
        if (message.getType() == MessageType.GetAccountCommissions) {
            this.processAccountCommissions(message);
        } else if (message.getType() == MessageType.Connected) {
            this.connected = true;
        } else if (message.getType() == MessageType.Disconnected) {
            this.stopTimeout();
            this.connected = false;
            this.storage.clear();
            this.notifyStateChange(DataManagerState.NOT_LOADED);
        } else if (message.getType() == MessageType.Reconnecting) {
            this.connected = false;
        }
    }
    stopTimeout() {
        if (this.timeOutScheduler != null) {
            this.timeOutScheduler.stop();
            this.timeOutScheduler = null;
        }
    }
}
module.exports = AccountCommissionsManager
AccountCommissionsManager.ActionStartRefresh = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        this._owner_.eventRefresh = ExecutionTimeEvenUtil.eventStart(ExecutionTimeEventName.AccountCommissionsManagerRefreshTime);
        this._owner_.notifyStateChange(DataManagerState.LOADING);
    }
}
AccountCommissionsManager.ActionStopRefresh = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        ExecutionTimeEvenUtil.eventStop(this._owner_.eventRefresh);
        this._owner_.notifyStateChange(DataManagerState.LOADED);
    }
    invokeWithError(error) {
        ExecutionTimeEvenUtil.eventStopWithError(this._owner_.eventRefresh, error);
        this._owner_.notifyStateChangeWithError(DataManagerState.NOT_LOADED, error);
    }
}
AccountCommissionsManager.TimeoutAction = class {
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        let error, queueItem;
        this._owner_.stopTimeout();
        error = "AccountCommissionsManager timed out on loading commissions";
        if (this._owner_.requestAccounts != null && this._owner_.requestAccounts.keys().length > 0) {
            error = error + " for account(s): " + StringUtil.arrayToString(this._owner_.requestAccounts.keys());
        }
        if (this._owner_.sendsQueue.length() > 0) {
            queueItem = this._owner_.sendsQueue.dequeue();
            this._owner_.checkQueue();
            queueItem.getActionStop().invokeWithError(error);
        }
    }
}
AccountCommissionsManager.ReceiveNewMessageListener = class {
    owner;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(owner) {
        let instance;
        instance = new AccountCommissionsManager.ReceiveNewMessageListener(this);
        instance.owner = owner;
        return instance;
    }
    onNewMessageReceive(message) {
        this.owner.processMessage(message);
    }
}
