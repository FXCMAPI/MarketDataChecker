'use strict';
let LogManager = require('./LogManager.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let FXConnectLiteErrorCodes = require('./FXConnectLiteErrorCodes.js');
class ToAccountCCYConverter {
    instrumentsProvider;
    internalOffersProvider;
    logger;
    constructor() {
        this.logger = LogManager.getLogger();
    }
    static create(instrumentsProvider, internalOffersProvider) {
        let result;
        result = new ToAccountCCYConverter();
        result.instrumentsProvider = instrumentsProvider;
        result.internalOffersProvider = internalOffersProvider;
        return result;
    }
    convert(baseCCY, price, account, traceInfo) {
        return this.plainConvert(baseCCY, price, account.getBaseCurrency(), traceInfo + " - from convert");
    }
    plainConvert(fromCCY, price, toCCY, traceInfo) {
        let summInUsd, instrumentConvertor, errorMessage, offer;
        if (fromCCY == toCCY) {
            return price;
        }
        instrumentConvertor = ToAccountCCYConverter.InstrumentConverter.findAvailableInstrument(this.instrumentsProvider, fromCCY, toCCY);
        if (instrumentConvertor != null) {
            offer = this.internalOffersProvider.getInternalOfferById(instrumentConvertor.getInstrument().getOfferId());
            if (offer != null) {
                return stdlib.roundInl(instrumentConvertor.convertToCurrencyPrice(this.internalOffersProvider, offer, price), instrumentConvertor.getInstrument().getDigits());
            }
            else {
                errorMessage = "ToAccountCCYConverter.plainConvert() [" + traceInfo + " - 1]: Offer not found, offerId='" + instrumentConvertor.getInstrument().getOfferId() + "'";
                this.logger.error(errorMessage);
                throw exception.create(FXConnectLiteErrorCodes.CODE_DATA_NOT_EXIST, errorMessage);
            }
        }
        instrumentConvertor = ToAccountCCYConverter.InstrumentConverter.findAvailableInstrument(this.instrumentsProvider, fromCCY, "USD");
        if (instrumentConvertor == null) {
            errorMessage = "ToAccountCCYConverter.plainConvert(): not found instrument pair for '" + fromCCY + "' and 'USD'";
            this.logger.error(errorMessage);
            throw exception.create(FXConnectLiteErrorCodes.CODE_INSTRUMENT_IS_NOT_FOUND, errorMessage);
        }
        offer = this.internalOffersProvider.getInternalOfferById(instrumentConvertor.getInstrument().getOfferId());
        if (offer != null) {
            summInUsd = instrumentConvertor.convertToCurrencyPrice(this.internalOffersProvider, offer, price);
        }
        else {
            errorMessage = "ToAccountCCYConverter.plainConvert() [" + traceInfo + " - 2]: Offer not found, offerId='" + instrumentConvertor.getInstrument().getOfferId() + "'";
            this.logger.error(errorMessage);
            throw exception.create(FXConnectLiteErrorCodes.CODE_DATA_NOT_EXIST, errorMessage);
        }
        instrumentConvertor = ToAccountCCYConverter.InstrumentConverter.findAvailableInstrument(this.instrumentsProvider, "USD", toCCY);
        if (instrumentConvertor == null) {
            errorMessage = "ToAccountCCYConverter.plainConvert(): not found instrument pair for '" + toCCY + "' and 'USD'";
            this.logger.error(errorMessage);
            throw exception.create(FXConnectLiteErrorCodes.CODE_INSTRUMENT_IS_NOT_FOUND, errorMessage);
        }
        offer = this.internalOffersProvider.getInternalOfferById(instrumentConvertor.getInstrument().getOfferId());
        if (offer != null) {
            return stdlib.roundInl(instrumentConvertor.convertToCurrencyPrice(this.internalOffersProvider, offer, summInUsd), instrumentConvertor.getInstrument().getDigits());
        }
        else {
            errorMessage = "ToAccountCCYConverter.plainConvert() [" + traceInfo + " - 3]: Offer not found, offerId='" + instrumentConvertor.getInstrument().getOfferId() + "'";
            this.logger.error(errorMessage);
            throw exception.create(FXConnectLiteErrorCodes.CODE_DATA_NOT_EXIST, errorMessage);
        }
    }
}
module.exports = ToAccountCCYConverter
ToAccountCCYConverter.InstrumentConverter = class {
    instrument;
    indirect;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    getInstrument() {
        return this.instrument;
    }
    convertToCurrencyPrice(internalOffersProvider, offer, price) {
        let bidAsk, result;
        bidAsk = internalOffersProvider.calculateBidAsk(offer);
        result = (bidAsk.getAsk() + bidAsk.getBid()) / 2;
        if (this.indirect) {
            result = 1 / result;
        }
        return stdlib.roundInl(result * price, this.instrument.getDigits());
    }
    static findAvailableInstrument(instrumentsProvider, currency1, currency2) {
        let instrument, indirect, instance;
        indirect = false;
        instrument = instrumentsProvider.getInstrumentBySymbol(currency1 + "/" + currency2);
        if (instrument == null) {
            instrument = instrumentsProvider.getInstrumentBySymbol(currency2 + "/" + currency1);
            indirect = true;
        }
        if (instrument == null) {
            return null;
        }
        instance = new ToAccountCCYConverter.InstrumentConverter(this);
        instance.instrument = instrument;
        instance.indirect = indirect;
        return instance;
    }
}
