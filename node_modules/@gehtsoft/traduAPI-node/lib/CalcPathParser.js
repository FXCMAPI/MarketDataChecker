'use strict';
let list = require('@gehtsoft/LuaxStdlib-node').list;
let csvParser = require('@gehtsoft/LuaxStdlib-node').csvParser;
let LogManager = require('./LogManager.js');
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let PLCalculationPathItem = require('./PLCalculationPathItem.js');
let PLCalculationPath = require('./PLCalculationPath.js');
let StringValueObject = require('./StringValueObject.js');
class CalcPathParser {
    static get IncorrectPartStartError() { return "CalcPathParser: path has wrong format (part should start with '/' or '\\')"; }
    static get IncorrectPriceIdOfferIdError() { return "CalcPathParser: path has wrong format (incorrect pair 'streamid-offerid')"; }
    static get IncorrectPartSizeError() { return "CalcPathParser: path has wrong format (part is too short)"; }
    static parse(calcPath) {
        let paths, fieldParser, s, i, val, oper, direct, itemsList;
        itemsList = new list();
        fieldParser = new csvParser();
        fieldParser.valueSeparator = "|";
        paths = fieldParser.splitLine(calcPath);
        direct = true;
        if (paths.length > 1) {
            s = CalcPathParser.split(paths[1], ["~", "/", "\\"]);
            for (i = 0; i <= s.length - 1; i += 1) {
                val = s[i];
                if (i == 0 && val == "~") {
                    direct = false;
                    continue;
                }
                oper = CalcPathParser.createOper(val, paths[1]);
                CalcPathParser.fillItemsList(itemsList, val, fieldParser, oper, paths[1]);
            }
        }
        else {
            LogManager.getLogger().error("Calculation path doesn't contain the detailed part: " + calcPath);
        }
        return CalcPathParser.createPLCalculationPath(itemsList, direct);
    }
    static createOper(valSource, src) {
        let oper;
        oper = stdlib.substring(valSource, 0, 1);
        if (oper != "/" && oper != "\\") {
            throw exception.create(0, CalcPathParser.IncorrectPartStartError + ": " + src);
        }
        return oper;
    }
    static fillItemsList(itemsList, valSource, fieldParser, oper, src) {
        let val, ss;
        val = stdlib.substring(valSource, 1, stdlib.len(valSource) - 1);
        if (stdlib.len(val) > 2) {
            fieldParser.valueSeparator = "-";
            ss = fieldParser.splitLine(val);
            if (ss.length < 2) {
                throw exception.create(0, CalcPathParser.IncorrectPriceIdOfferIdError + ": " + src);
            }
            itemsList.add(PLCalculationPathItem.create(oper, ss[1]));
        }
        else {
            throw exception.create(0, CalcPathParser.IncorrectPartSizeError + ": " + src);
        }
    }
    static createPLCalculationPath(itemsList, direct) {
        let items, i;
        items = new Array(itemsList.length());
        for (i = 0; i <= itemsList.length() - 1; i += 1) {
            items[i] = PLCalculationPathItem.getPLCalculationPathItem(itemsList, i);
        }
        return PLCalculationPath.create(direct, items);
    }
    static split(str, separators) {
        let result, resultList, i, j, found, currentLength, currentItem, ch;
        resultList = new list();
        currentLength = 0;
        currentItem = "";
        for (i = 0; i <= stdlib.len(str) - 1; i += 1) {
            ch = stdlib.substring(str, i, 1);
            found = false;
            for (j = 0; j <= separators.length - 1; j += 1) {
                if (separators[j] == ch) {
                    found = true;
                    break;
                }
            }
            if (found) {
                if (currentLength > 0) {
                    resultList.add(StringValueObject.create(currentItem));
                }
                currentLength = 1;
                currentItem = ch;
            }
            else {
                currentLength = currentLength + 1;
                currentItem = currentItem + ch;
            }
        }
        if (currentLength > 0) {
            resultList.add(StringValueObject.create(currentItem));
        }
        result = new Array(resultList.length());
        for (i = 0; i <= resultList.length() - 1; i += 1) {
            result[i] = resultList.get(i).get();
        }
        return result;
    }
}
module.exports = CalcPathParser
