'use strict';
let CommandStatusPublisher = require('./CommandStatusPublisher.js');
let LogManager = require('./LogManager.js');
let exception = require('@gehtsoft/LuaxStdlib-node').exception;
let scheduler = require('@gehtsoft/LuaxStdlib-node').scheduler;
let stdlib = require('@gehtsoft/LuaxStdlib-node').stdlib;
let DateTimeParser = require('./DateTimeParser.js');
//@@DocBrief("The command for getting persistent session")
class AGetPersistentSessionCommand {
    timeoutJulian;
    temporarySession;
    login;
    applicationName;
    messageFactory;
    terminal;
    priceTerminal;
    requestNumberGenerator;
    publisher;
    messageRouter;
    receiveNewMessageListener;
    messageExecutor;
    periodInMilliseconds;
    timeoutInSeconds;
    pollingScheduler;
    canceled;
    logger;
    commandName;
    constructor() {
        this.publisher = new CommandStatusPublisher();
        this.receiveNewMessageListener = new AGetPersistentSessionCommand.ReceiveNewMessageListener(this);
        this.receiveNewMessageListener.emptyMessageType = this.getEmptyMessageType();
        this.receiveNewMessageListener.realMessageType = this.getRealMessageType();
        this.periodInMilliseconds = 300;
        this.timeoutInSeconds = 60;
        this.canceled = false;
        this.logger = LogManager.getLogger();
        this.commandName = "AGetPersistentSessionCommand";
        this.priceTerminal = null;
    }
    getRealMessageType() {
        throw exception.create(0, "getRealMessageType() is not implemented");
    }
    getEmptyMessageType() {
        throw exception.create(0, "getEmptyMessageType() is not implemented");
    }
    getUrl() {
        throw exception.create(0, "getUrl() is not implemented");
    }
    getTerminalUrl() {
        throw exception.create(0, "getUrl() is not implemented");
    }
    getTransportMessageType() {
        throw exception.create(0, "getTransportMessageType() is not implemented");
    }
    execute() {
        let now, getSessionStatusRequestAction;
        this.logger.debug("Execute command '" + this.commandName + "'");
        this.canceled = false;
        this.messageRouter.subscribeNewMessageReceive(this.getRealMessageType(), this.receiveNewMessageListener);
        this.messageRouter.subscribeNewMessageReceive(this.getEmptyMessageType(), this.receiveNewMessageListener);
        getSessionStatusRequestAction = new AGetPersistentSessionCommand.GetSessionStatusRequestAction(this);
        getSessionStatusRequestAction.emptyMessageType = this.getEmptyMessageType();
        getSessionStatusRequestAction.realMessageType = this.getRealMessageType();
        getSessionStatusRequestAction.transportMessageType = this.getTransportMessageType();
        this.pollingScheduler = scheduler.create(this.periodInMilliseconds, getSessionStatusRequestAction);
        now = stdlib.nowutc();
        this.logger.debug("!TMT! start timeout at: " + DateTimeParser.toShortIso(now));
        this.timeoutJulian = stdlib.toJdn(now);
        this.logger.debug("!TMT! julian now: " + (this.timeoutJulian).toString());
        this.timeoutJulian = this.timeoutJulian + this.timeoutInSeconds / 86400;
        this.logger.debug("!TMT! julian timeout at: " + (this.timeoutJulian).toString());
        this.pollingScheduler.startImmediately();
    }
    subscribeStatusChange(callback) {
        this.publisher.subscribe(callback);
    }
    unsubscribeStatusChange(callback) {
        this.publisher.unsubscribe(callback);
    }
    stop() {
        this.logger.debug("Stop command '" + this.commandName + "'");
        this.canceled = true;
        this.pollingScheduler.stop();
        this.messageExecutor.cancel();
    }
}
module.exports = AGetPersistentSessionCommand
AGetPersistentSessionCommand.GetSessionStatusRequestAction = class {
    realMessageType;
    emptyMessageType;
    transportMessageType;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    invoke() {
        let transportMessage, messageExecutorCallback;
        if (this._owner_.pollingScheduler != null) {
            this._owner_.pollingScheduler.stop();
            if (!this._owner_.canceled) {
                transportMessage = this._owner_.messageFactory.createSessionStatusRequestMessage(this._owner_.temporarySession, this._owner_.login, this._owner_.terminal, this._owner_.priceTerminal, this.transportMessageType, this._owner_.requestNumberGenerator);
                messageExecutorCallback = new AGetPersistentSessionCommand.MessageExecutorCallback(this._owner_);
                messageExecutorCallback.emptyMessageType = this.emptyMessageType;
                messageExecutorCallback.realMessageType = this.realMessageType;
                this._owner_.messageExecutor.execute(transportMessage, messageExecutorCallback);
            }
        }
    }
}
AGetPersistentSessionCommand.ReceiveNewMessageListener = class {
    realMessageType;
    emptyMessageType;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onNewMessageReceive(message) {
        let nowJulian, now, sessionMessage, error, emptySessionMessage;
        this._owner_.logger.debug(this._owner_.commandName + ". Receive message: " + message.getType());
        if (message.getType() == this.realMessageType) {
            sessionMessage = message;
            if (this.isMyRequestId(sessionMessage.getRequestId())) {
                this._owner_.messageRouter.unsubscribeNewMessageReceive(this.realMessageType, this._owner_.receiveNewMessageListener);
                this._owner_.messageRouter.unsubscribeNewMessageReceive(this.emptyMessageType, this._owner_.receiveNewMessageListener);
                error = sessionMessage.getError();
                if (error != null) {
                    this._owner_.publisher.notifyError(error);
                }
                else {
                    this._owner_.publisher.notifySuccess(message);
                }
            }
        } else if (message.getType() == this.emptyMessageType) {
            emptySessionMessage = message;
            if (this.isMyRequestId(emptySessionMessage.getRequestId())) {
                now = stdlib.nowutc();
                nowJulian = stdlib.toJdn(now);
                if (nowJulian > this._owner_.timeoutJulian) {
                    this._owner_.logger.debug("!TMT! timeout happened at: " + DateTimeParser.toShortIso(now));
                    this._owner_.logger.debug("!TMT! julian happened: " + (nowJulian).toString());
                    this._owner_.logger.debug("!TMT! julian timeout was set: " + (this._owner_.timeoutJulian).toString());
                    this._owner_.messageRouter.unsubscribeNewMessageReceive(this.realMessageType, this._owner_.receiveNewMessageListener);
                    this._owner_.messageRouter.unsubscribeNewMessageReceive(this.emptyMessageType, this._owner_.receiveNewMessageListener);
                    this._owner_.publisher.notifyError("Persistent session receiving timeout");
                    return;
                }
                this._owner_.pollingScheduler.startWithDelay();
            }
        }         else {
            this._owner_.messageRouter.unsubscribeNewMessageReceive(this.realMessageType, this._owner_.receiveNewMessageListener);
            this._owner_.messageRouter.unsubscribeNewMessageReceive(this.emptyMessageType, this._owner_.receiveNewMessageListener);
            this._owner_.publisher.notifyError("Unexpected message type: " + message.getType());
        }
    }
    isMyRequestId(requestId) {
        return stdlib.indexOf(requestId, this._owner_.temporarySession + "-", false) == 0;
    }
}
AGetPersistentSessionCommand.MessageExecutorCallback = class {
    realMessageType;
    emptyMessageType;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    onSuccessSent() {
        this._owner_.logger.debug("Message '" + this._owner_.commandName + "' successfully sent");
    }
    onError(error) {
        this._owner_.logger.error("Send message '" + this._owner_.commandName + "' failed: " + error);
        this._owner_.messageRouter.unsubscribeNewMessageReceive(this.realMessageType, this._owner_.receiveNewMessageListener);
        this._owner_.messageRouter.unsubscribeNewMessageReceive(this.emptyMessageType, this._owner_.receiveNewMessageListener);
        this._owner_.publisher.notifyError(error);
    }
}
