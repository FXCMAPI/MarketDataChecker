'use strict';
let HPV6PriceTerminalsReader = require('./HPV6PriceTerminalsReader.js');
let HPV6TerminalsReader = require('./HPV6TerminalsReader.js');
let HPV6UrlsReader = require('./HPV6UrlsReader.js');
let xmlParser = require('@gehtsoft/LuaxStdlib-node').xmlParser;
let TerminalFactory = require('./TerminalFactory.js');
let TerminalUrlFactory = require('./TerminalUrlFactory.js');
let TradingTerminalFactory = require('./TradingTerminalFactory.js');
let XmlReaderUtil = require('./XmlReaderUtil.js');
let HostsParserResponseBuilder = require('./HostsParserResponseBuilder.js');
let HostsParserXmlUtils = require('./HostsParserXmlUtils.js');
let TerminalType = require('./TerminalType.js');
let TerminalStatus = require('./TerminalStatus.js');
let list = require('@gehtsoft/LuaxStdlib-node').list;
//@@DocBrief("The parser for Hosts.jsp")
class HostsParserV6 {
    priceTerminalsReader;
    terminalsReader;
    urlsReader;
    constructor() {
        this.priceTerminalsReader = new HPV6PriceTerminalsReader();
        this.terminalsReader = new HPV6TerminalsReader();
        this.urlsReader = new HPV6UrlsReader();
    }
    parse(xml, connection) {
        let parser, root, i, terminalsList, node, chartTerminal, priceTerminals, terminalFactory, terminalUrlFactory, tradingTerminalFactory, errorText, connectionFound, responseBuilder, terminals;
        terminalsList = new HostsParserV6.tradingTerminalsList(this);
        parser = new xmlParser();
        root = parser.parse(xml);
        terminalFactory = new TerminalFactory();
        terminalUrlFactory = new TerminalUrlFactory();
        tradingTerminalFactory = new TradingTerminalFactory();
        chartTerminal = null;
        priceTerminals = null;
        connectionFound = false;
        errorText = null;
        for (i = 0; i <= root.getChildrenCount() - 1; i += 1) {
            node = root.getChild(i);
            if (XmlReaderUtil.isAttrEqualTo(node, "type", "trading")) {
                priceTerminals = this.priceTerminalsReader.buildPriceTerminals(node, root, terminalFactory, terminalUrlFactory);
                chartTerminal = this.buildTerminalByAttr(node, "chart_terminal", root, terminalFactory, terminalUrlFactory);
                terminalsList.add(HostsParserV6.tradingTerminalsListItem.create(this.createTradingTerminal(node, tradingTerminalFactory, terminalUrlFactory, priceTerminals, chartTerminal)));
            } else if (XmlReaderUtil.isAttrEqualTo(node, "type", "global") && XmlReaderUtil.isAttrEqualTo(node, "name", connection)) {
                connectionFound = true;
                if (!XmlReaderUtil.isAttrEqualTo(node, "status", "active")) {
                    errorText = XmlReaderUtil.getAttrValue(node, "inactive_text");
                }
            }
        }
        if (!connectionFound) {
            if (terminalsList.length() > 0) {
                errorText = "INCORRECT_CONNECTION";
            }
            else {
                errorText = "INCORRECT_CREDENTIALS";
            }
        }
        responseBuilder = new HostsParserResponseBuilder();
        terminals = terminalsList.toArray();
        responseBuilder.setTerminals(terminals);
        responseBuilder.setError(errorText);
        return responseBuilder.build();
    }
    buildTerminalByAttr(node, attrName, root, terminalFactory, terminalUrlFactory) {
        let dependentNode, attr;
        attr = node.getAttributeByName(attrName);
        if (attr != null) {
            dependentNode = HostsParserXmlUtils.findNodeByName(attr.getValue(), root);
            if (dependentNode != null) {
                return this.terminalsReader.createTerminal(dependentNode, terminalFactory, terminalUrlFactory);
            }
        }
        return null;
    }
    createTradingTerminal(node, tradingTerminalFactory, terminalUrlFactory, priceTerminals, chartTerminal) {
        let attr, type, name, status, inactiveText, urls, id, subid, description, salt;
        name = "";
        status = "";
        inactiveText = "";
        id = "";
        subid = "";
        description = "";
        salt = "";
        type = TerminalType.TRADING;
        attr = node.getAttributeByName("name");
        if (attr != null) {
            name = attr.getValue();
        }
        attr = node.getAttributeByName("status");
        if (attr != null) {
            status = attr.getValue();
            if (status == "active") {
                status = TerminalStatus.ACTIVE;
            }
            else {
                status = TerminalStatus.INACTIVE;
            }
        }
        attr = node.getAttributeByName("inactive_text");
        if (attr != null) {
            inactiveText = attr.getValue();
        }
        attr = node.getAttributeByName("id");
        if (attr != null) {
            id = attr.getValue();
        }
        attr = node.getAttributeByName("subid");
        if (attr != null) {
            subid = attr.getValue();
        }
        attr = node.getAttributeByName("description");
        if (attr != null) {
            description = attr.getValue();
        }
        attr = node.getAttributeByName("S");
        if (attr != null) {
            salt = attr.getValue();
        }
        urls = this.urlsReader.getUrls(node, terminalUrlFactory);
        return tradingTerminalFactory.createTradingTerminalWithPriceTerminals(type, name, status, inactiveText, urls, id, subid, description, salt, priceTerminals, chartTerminal);
    }
}
module.exports = HostsParserV6
HostsParserV6.tradingTerminalsListItem = class {
    tradingTerminal;
    _owner_;
    constructor(_owner_) {
        this._owner_ = _owner_;
    }
    static create(tradingTerminal) {
        let l;
        l = new HostsParserV6.tradingTerminalsListItem(this);
        l.tradingTerminal = tradingTerminal;
        return l;
    }
}
HostsParserV6.tradingTerminalsList = class extends list {
    _owner_;
    constructor(_owner_) {
        super();
        this._owner_ = _owner_;
    }
    get(index) {
        return super.get(index);
    }
    set(index, value) {
        super.set(index, value);
    }
    add(value) {
        super.add(value);
    }
    toArray() {
        let i, result;
        result = new Array(super.length());
        for (i = 0; i <= super.length() - 1; i += 1) {
            result[i] = super.get(i).tradingTerminal;
        }
        return result;
    }
}
